这是一次非常精彩的逻辑推演！你的推测非常有道理：既然数据分家了，那持有数据的“引路人”（对象头）是不是也要变身？



这听起来似乎矛盾——如果对象头只指在“元空间”，那它是怎么找到“堆”里的静态变量的呢？

答案在于：**元空间里的“图纸”和堆里的“Class对象”，它们私底下互相认识（互为镜像）。**

我们来拆解一下这个精妙的设计。

---

### 1. 对象头（Object Header）里到底有什么？

在 64 位 JVM（开启指针压缩）中，普通对象的对象头通常占用 **12 字节**，包含两部分：

1. **Mark Word (8字节)**：存运行时数据（哈希码、GC分代年龄、锁状态等）。
2. **Klass Pointer (4字节)**：**这就是我们要找的指针。**
* **指向哪里？** 它指向 **元空间 (Metaspace)** 中的 `InstanceKlass`（这是 JVM 层面用来描述类的 C++ 对象）。
* **注意**：它**不指向**堆里的 `java.lang.Class` 对象。



---

### 2. 那它是怎么找到堆里的静态变量的？

这里有一个关键概念叫 **“Java 镜像 (Java Mirror)”**。

JVM 在设计时建立了一个**双向连接**：

* **元空间**里的 `InstanceKlass`（图纸）持有一个指针，指向 **堆**里的 `java.lang.Class`（大管家）。
* **堆**里的 `java.lang.Class`（大管家）持有一个指针，指向 **元空间**里的 `InstanceKlass`（图纸）。

所以，查找路线是“曲线救国”的：

```
普通对象实例 -> 元空间(InstanceKlass) -> 堆(Class对象) -> 静态变量

```

### 3. 可视化：内存中的“三角恋”

看下面这张图，这就解释了为什么对象头不需要存两个地址：



### 4. 为什么要这么设计？（为什么不存两个指针？）

既然静态变量在堆里，为什么不让对象头直接多存一个指针指向堆里的 Class 对象？这样不是更快吗？

**原因 1：寸土寸金**
Java 里的对象成千上万。如果给每个对象的头部都增加 4 字节（或 8 字节）的指针，整个堆内存的消耗会暴增。
**元数据（InstanceKlass）** 全局只有一份，让它去持有堆对象的引用，成本是最低的。

**原因 2：职责分离**

* **对象头** 只需要负责回答“我是什么类型”（通过 Klass Pointer）。
* 至于这个类型对应的“静态属性”在哪里，那是**类型自己**该知道的事，不需要每个具体的对象去操心。

### 总结

你的对象头没有变大。

当你写 `u.count`（通过对象访问静态变量）时，JVM 内部的寻址逻辑大致是：

1. **看对象头**：你是谁？ -> 拿到 Metaspace 里的 `InstanceKlass` 地址。
2. **看元数据**：你的 Java 镜像在哪？ -> 拿到 Heap 里的 `java.lang.Class` 地址。
3. **拿数据**：去那个对象里取出 `count` 的值。

