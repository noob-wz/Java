在工业级开发中，校验是**分层级**的，就像过安检一样，一共要过两道关。

---

### 1. 核心概念：校验的两道关卡

我们要把校验分为 **“格式校验”**和**“业务校验”**。

#### 第一道关：格式校验 (Format Validation) -> **放在 View 层 / Utility 层**

* **这是什么？** 检查输入的数据“长得对不对”。
* **比如**：
  * 用户输入的月租是不是数字？（不能输入 "abc"）
  * 用户输入的姓名是不是太长了？（不能超过 10 个字）
  * 用户输入的性别是不是只有“男/女”？


* **为什么放这里？**
  * **挡在最前面**：如果用户连数字都输错了，根本没必要去麻烦 Service 层，直接在界面层让他重输。
  * **保护程序**：如果把 "abc" 传给 Service 层要求存入 `int rent`，程序在传输过程中就崩了（类型转换异常）。



#### 第二道关：业务校验 (Business Validation) -> **放在 Service 层**

* **这是什么？** 检查数据“合不合规矩”。
* **比如**：
  * **ID 是否存在？**（只有 Service 里的数组知道）
  * **数组是不是满了？**（只有 Service 知道还能不能存）
  * **是否重复添加？**（比如一个人不能租两套房，这需要查库）


* **为什么放这里？**
  * 只有 Service 层手里握着数据（数组），View 层是瞎子，它不知道 ID 1 存不存在。



---

### 2. 小白的核心疑问：如何在“输入前”就拦截？

*场景：新增房屋时，如果数组满了，我不想让用户输了一大堆信息后，才告诉他“满了存不进去”。**

**做法：View 层在启动 Scanner 之前，先问一下 Service 层。**

#### ❌ 错误的流程（用户体验差）

1. View: "请输入姓名、电话..." (用户辛辛苦苦输了半天)
2. View: "给，这是对象，Service 你存一下。"
3. Service: "哎呀，数组满了，存不了，返回 false。"
4. View: "不好意思用户，刚刚白输了，满了。"

#### ✅ 正确的流程（工业标准）

1. **View (预判)**: "Service，现在的房子数量满了吗？" (`service.isFull()`)
2. **Service**: "满了。"
3. **View**: "好的。" -> 直接打印 "已满，无法添加"，**根本不启动 Scanner**。

---

### 3. 代码落地演示

让我们修改一下你的代码，看看这两层校验具体写在哪里。

#### 步骤一：在 Service 层增加“预判”方法 (业务校验)

Service 层不仅提供 `add`，还要提供一个让 View 层查询状态的方法。

```java
// HouseService.java
public class HouseService {
    // ... 原有代码 ...

    // 【新增】提供给 View 层做预判的方法
    public boolean isFull() {
        return houseNums == houses.length;
    }
    
    // 【新增】提供给 View 层判断 ID 是否存在的预判方法
    public boolean idExists(int id) {
        return find(id) != null;
    }
}

```

#### 步骤二：在 View 层利用预判 + 工具类校验 (混合双打)

```java
// HouseView.java
public void addHouse() {
    System.out.println("-------------------------- 添加房屋 --------------------------");
    
    // 【第一道关：业务预判】
    // 在用户动手输入之前，先问 Service
    if (houseService.isFull()) {
        System.out.println("【错误】房屋列表已满，无法添加！");
        return; // 直接结束，不让用户输入了
    }

    // 【第二道关：格式校验】
    // 这里调用 Utility 工具类，如果用户输错了，工具类会让他重输
    // 这就是 View 层的校验
    System.out.print("姓名：");
    String name = Utility.readString(8); // 限制只能输8个字

    System.out.print("月租：");
    int rent = Utility.readInt(); // 限制必须输数字，输abc会提示重输

    // ... 组装对象 ...
    House newHouse = new House(name, ...);
    
    // ... 调用 service.add ...
}

```

---

### 4. 总结图解

可以把这个过程想象成**“漏斗过滤”**：

1. **最上层（View/Utility）**：过滤掉**垃圾数据**（乱码、格式错误、空值）。
   * *手段*：`Utility.readInt()`, `length()` 判断。

2. **中间层（View 调用 Service 预判）**：过滤掉**无效操作**（没库存、没权限）。
   * *手段*：`if (service.isFull()) return;`

3. **最底层（Service 核心逻辑）**：执行**最终数据落库**。
   * *手段*：`houses[i] = house;`

**结论：**

* **格式校验**（能不能输）：在 **View/Utility** 做。
* **状态校验**（能不能存）：逻辑在 **Service** 定义，但 **View** 可以在输入前调用 Service 的方法来提前拦截。