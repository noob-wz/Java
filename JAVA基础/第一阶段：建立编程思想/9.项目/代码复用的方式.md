工程界真正推崇的**复用实战手段**主要有以下 **4 种**。

按照**推荐程度**从高到低排列，它们分别是：

---

### 1. 组合 (Composition) —— 👑 黄金标准

**核心思想**：**Has-A (有一个...)**
这是最灵活、副作用最小的复用方式。不需要成为子类，只需要**持有**那个类的对象，然后让它干活。

* **场景**：你要写一个 `Computer`（电脑），想要复用 `CPU` 的计算功能。
* **做法**：电脑 **不是** CPU，所以不能继承。电脑 **拥有** 一个 CPU。

```java
class CPU {
    public void calculate() { System.out.println("疯狂计算中..."); }
}

class Computer {
    // 1. 组合：在内部持有一个 CPU 对象 (private)
    private CPU cpu = new CPU();

    public void work() {
        // 2. 复用：直接调用 cpu 的方法
        // 这叫“委托 (Delegation)”，老板(Computer)把活派给员工(CPU)干
        cpu.calculate(); 
        System.out.println("电脑显示结果");
    }
}

```

**优点**：

* **黑盒复用**：你不需要知道 CPU 内部怎么实现的，只管用。
* **低耦合**：随时可以把 `cpu = new IntelCPU()` 换成 `cpu = new AMD_CPU()`，不需要改代码（如果配合接口使用）。

---

### 2. 工具类 (Utility Classes) —— 🔧 静态复用

**核心思想**：**无状态逻辑复用**
如果一段逻辑跟具体对象的状态无关（不需要存属性），仅仅是“算一下”，那就做成静态工具方法。

* **场景**：字符串判空、日期格式化、数学计算。
* **做法**：`public static` 方法。

```java
// 工具类
public class StringUtils {
    // 私有构造器，防止被 new（因为它只是个工具箱）
    private StringUtils() {}

    // 静态方法复用
    public static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }
}

// 任何地方都能复用
if (StringUtils.isEmpty(username)) { ... }

```

**优点**：拿来即用，不需要创建对象，效率高。

---

### 3. 接口默认方法 (Interface Default Methods) —— 🧬 现代“混入” (Java 8+)

**核心思想**：**水平复用 (Behavior Injection)**
在 Java 8 之前，接口不能写代码实现。但现在可以了。这允许我们在**不使用继承**的情况下，给毫无关系的类赋予相同的能力。

* **场景**：`Car` 和 `Robot` 都能充电，但它们没有共同父类。
* **做法**：定义一个 `Chargeable` 接口，写好 `charge()` 的默认实现。

```java
interface Chargeable {
    // default 关键字允许在接口里写实现逻辑
    default void charge() {
        System.out.println("通用充电逻辑：检查电压 -> 开始充电");
    }
}

// 汽车复用充电逻辑
class Car implements Chargeable {} 

// 机器人也能复用，尽管它和汽车完全不同
class Robot implements Chargeable {}

// 用法
new Car().charge();   // 复用成功
new Robot().charge(); // 复用成功

```

**优点**：突破了 Java 单继承的限制，实现了类似 C++ 多重继承的复用效果，但更安全。

---

### 4. 继承 (Inheritance) —— ⚠️ 慎用的重武器

**核心思想**：**Is-A (是一个...)**
正如前面所说，只有当逻辑高度重合，且逻辑上真的是父子关系时，才用它来复用。

* **复用手段**：`super.method()`。
* **场景**：`Manager` 复用 `Employee` 的基础工资计算。

---

### 📊 终极对比表：何时用什么？

| 复用手段 | 关系描述 | 耦合度 | 灵活性 | 推荐指数 | 典型例子 |
| --- | --- | --- | --- | --- | --- |
| **组合** | **Has-A** (有一个) | 低 | 🔥 高 (运行时可换) | ⭐⭐⭐⭐⭐ | 电脑里装CPU、汽车里装引擎 |
| **工具类** | **Use-A** (用一个) | 很低 | 中 | ⭐⭐⭐⭐ | `Math.max()`, `Collections.sort()` |
| **默认方法** | **Can-Do** (能做) | 低 | 高 (可多实现) | ⭐⭐⭐ | 只有 Java 8+ 支持 |
| **继承** | **Is-A** (是一个) | 🚨 高 | ❄️ 低 (编译期锁死) | ⭐⭐ | `Dog` 继承 `Animal` |

### 🚀 工程师的决策树

当你想要复用代码时，请按这个顺序问自己：

1. **这代码是纯计算逻辑吗？**
   * Yes -> 用 **静态工具类**。

2. **这两个类有严格的层级关系 (Is-A) 吗？**
   * No -> 坚决不用继承。

3. **我想让这个类拥有某种能力，但它已经是别人的子类了吗？**
   * Yes -> 用 **接口默认方法**。

4. **其他所有情况：**
* 👉 **用组合 (Composition)**。



这就是为什么业界有句名言：**“组合优于继承” (Composition over Inheritance)**。