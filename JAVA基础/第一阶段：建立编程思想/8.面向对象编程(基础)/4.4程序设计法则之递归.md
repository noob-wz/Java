## 法则一：边界法则 (Base Case Rule) — 保证终止与可控

### 详细阐述与业务指导

**核心思想：** 每一个递归函数都必须知道它何时是**最小、最简单**的问题，并直接给出答案，而不是继续调用自身。这个点就是“边界”。

#### 1. 边界的设置与利用（你提出的重点）

> **边界在递归的使用使用是从边界值开始，那么递归的参数一般是相反的边界值。**

- **设计意图：** **控制方向。** 递归参数必须引导递归向着已知的终点移动。如果你从 $N$ 开始递推，终点是 $0$，那么参数应该朝 $0$ 递减。
- **业务指导：**
  - **利用边界：** 边界值不仅仅是停止的标志，它还是**初始返回值**。在“猴子吃桃”问题中，边界 $F(10)=1$ 就是整个逆向计算的起点值。

#### 2. 防止栈溢出 (StackOverflowError)

- **原因：** 如果缺少边界或边界条件设计错误（比如 $N$ 永远无法达到 $0$），JVM 会不断为新的函数调用创建栈帧，直到耗尽线程栈空间，抛出 `StackOverflowError`。
- **指导：** 每次编写递归代码后，**第一件事**就是验证 `if (base_case)` 逻辑是否在所有可能的输入路径上都能被触发。

---

## 法则二：效率法则 (Efficiency & Single Call Rule) — 避免重复计算

### 详细阐述与业务指导

**核心思想：** 在递归的同一层级（同一个栈帧）内，不要为了获取同一个结果而重复执行相同的函数调用。

#### 1. 避免重复调用的必要性

- **设计意图：** **控制复杂度。** 避免指数级的时间复杂度爆炸。例如，未优化的斐波那契数列 $F(n) = F(n-1) + F(n-2)$ 会导致对 $F(n-2)$ 的结果被重复计算无数次。
- **实践要点：**
  1.  **存储结果：** 必须使用局部变量（如 `int tempResult = F(n-1);`）来存储递归调用的结果。
  2.  **一次调用：** 确保每层栈帧只对每个必要的子问题进行**一次**递归调用。

#### 2. 与“备忘录”技术的联系 (Memoization)

- **业务指导：** 当你的递归设计必须重复计算**同一个参数**的结果时（如复杂的动态规划问题），你需要超越这个法则。
- **高级技巧：** 引入 **Memoization（备忘录）** 技术。使用 `Map` 或数组来存储 $F(n)$ 的结果。在调用 $F(n)$ 之前，先检查 `Map` 中是否已经存在 $F(n)$ 的结果。如果存在，直接返回；如果不存在，再进行递归计算。这是一种主动的、跨栈帧的效率优化。

---

## 法则三：假设法则 (The Faith Rule) — 简化思维负担

### 详细阐述与业务指导

**核心思想：** 相信递归函数对**规模更小**的问题是 **绝对正确** 的，从而专注于递推公式的构建。

#### 1. 思维模式的转变

- **设计意图：** **化繁为简。** 将精力从“如何计算所有步骤”转移到“如何将小结果组合成大结果”。
- **指导：** 当你编写 `F(n)` 的主体时，必须停止思考 $F(n-1)$ 是怎么实现的。你只要相信：
  - `F(n-1)` 的返回值是准确的。
  - `F(n-2)` 的返回值是准确的。

#### 2. 应用于递推公式

- **业务指导：** 这种思维模式让你能快速识别 **递推关系**：
  - 求和：`Sum(N) = Sum(N-1) + N`
  - 查找：`Find(List) = Find(List.tail) ? 结果`
  - 逆推（猴子吃桃）：`Peach(Day) = 2 * (Peach(Day+1) + 1)`

---

## 法则四：状态不变性法则 (State Integrity Rule) — 保证可预测性

### 详细阐述与业务指导

**核心思想：** 确保每一次递归调用都处于一个 **纯净、独立** 的状态，避免数据混乱。

#### 1. 避免外部状态依赖

- **设计意图：** **保证可追踪性。** 既然每个递归调用都在一个独立的栈帧中，那么它应该只依赖于其**局部变量**和**传入的参数**。
- **指导：** 避免在递归过程中读取或修改外部的**全局静态变量**或**类成员变量**。如果你需要在递归过程中累加结果，应该：
  - 方法 A：通过**返回值**传递累加的结果（推荐）。
  - 方法 B：将累加器作为**参数**传递给下一次递归调用。

#### 2. 参数的推进性

- **设计意图：** **保证正确性。** 确保传递给下一次调用的参数是**向着边界条件**移动的，且是合法的。
- **指导：** 每次调用 `F(n)` 时，你必须确保传入的参数是 $n-1$ 或 $n/2$ 等，即它在规模上是小于 $n$ 的。如果参数错误地增加了规模（如传入 $n+1$），将立刻导致无限递归。
