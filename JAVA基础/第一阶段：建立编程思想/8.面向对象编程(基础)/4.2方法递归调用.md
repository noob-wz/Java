### 🔑 递归的核心原理：自己调用自己

**定义：** 递归是指在一个方法的内部，直接或间接地调用它自身。

**设计哲学：** 递归将一个大型、复杂的问题，分解成一个与原问题结构相同，但规模**更小**的子问题。这个过程不断重复，直到问题规模小到可以直接求解。

---

### 🧱 递归调用的两大要素

一个正确的、有效的递归方法必须包含以下两个要素，缺一不可：

#### 1\. 终止条件 (Base Case)

这是递归方法**必须停止**的条件。当满足这个条件时，方法不再调用自身，而是直接返回一个确定的值，**本质上就是边界值**

- **作用：** 这是防止程序陷入**无限循环/无限递归**的“安全阀”。
- **示例：** 在计算阶乘 $n!$ 时，$n=1$ 或 $n=0$ 时，结果固定为 $1$。

#### 2\. 递归调用 (Recursive Step)

这是方法调用自身来解决**规模更小**的子问题的逻辑。

- **作用：** 确保每一步调用都在朝着**终止条件**的方向推进。
- **示例：** $n! = n \times (n-1)!$。计算 $n!$ 依赖于计算规模更小的 $(n-1)!$。

---

### 📝 示例：计算阶乘 ($n!$)

计算 $n! = n \times (n-1) \times \dots \times 1$

| 递归要素     | 数学定义               | $\text{Java}$ 代码实现         |
| :----------- | :--------------------- | :----------------------------- |
| **终止条件** | $n = 1$ 时，返回 $1$   | `if (n <= 1) { return 1; }`    |
| **递归调用** | $n! = n \times (n-1)!$ | `return n * factorial(n - 1);` |

```java
public static long factorial(int n) {
    // 1. 终止条件 (Base Case)
    if (n <= 1) {
        return 1;
    }

    // 2. 递归调用 (Recursive Step)
    // 问题规模：n 缩小为 n - 1
    return n * factorial(n - 1);
}

// 调用过程示例：factorial(3)
// 1. factorial(3) -> 3 * factorial(2)
// 2.   factorial(2) -> 2 * factorial(1)
// 3.     factorial(1) -> 返回 1 (达到终止条件)
// 4.   factorial(2) -> 2 * 1 = 2
// 5. factorial(3) -> 3 * 2 = 6
```

---

### 🧠 递归调用与栈内存（Stack）

理解递归，必须理解 **栈内存** 的工作方式：

1.  **栈帧创建：** 每一次方法调用（包括递归调用），$\text{JVM}$ 都会在**栈内存**上创建一个新的**栈帧**。
2.  **LIFO：** 栈帧遵循 **后进先出 (LIFO)** 原则。上一个调用未结束，下一个调用就会压入栈顶。
3.  **递归深度：** 递归的深度（调用自身的次数）决定了栈上创建的栈帧数量。
4.  **栈溢出：** 如果递归缺乏正确的终止条件，方法会无限调用自身，导致栈帧不断累积，最终耗尽栈内存，引发著名的 **`StackOverflowError`**（栈溢出错误）。

### 🌟 递归的应用场景

递归是解决以下问题的理想选择：

1.  **分治算法：** 快速排序、归并排序。
2.  **树结构操作：** 遍历树（深度优先搜索 $\text{DFS}$）、计算树的高度、查找节点。
3.  **图结构操作：** 图的遍历、最短路径查找。
4.  **数学序列：** 斐波那契数列（`Fib(n) = Fib(n-1) + Fib(n-2)`）。

### 💡 总结与建议

| 优点                                         | 缺点                                                            | 建议                                                       |
| :------------------------------------------- | :-------------------------------------------------------------- | :--------------------------------------------------------- |
| **代码简洁优雅**，逻辑清晰，更贴近数学定义。 | 性能开销较大，因为每次调用都涉及栈帧的创建和销毁。              | **优先用于逻辑清晰、结构相似的嵌套问题**（如树、图结构）。 |
| **解决分治问题** 非常高效。                  | 必须**严格**确保终止条件，否则会导致 **`StackOverflowError`**。 | 避免在简单循环可解决的问题中使用递归。                     |
