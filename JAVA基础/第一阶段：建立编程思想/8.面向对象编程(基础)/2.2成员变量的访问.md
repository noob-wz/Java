这是一个非常核心的问题！你已经理解了成员变量是如何声明的，现在我们就要关注如何**访问**和**操作**这些变量，而这正是体现 Java 面向对象设计中**封装性**的关键所在。

我是 Java 设计团队的一员，我将为你详细解释访问成员变量的两种主要方式，并重点强调**为什么**要选择受控的访问方式。

---

### 🔑 访问成员变量的两种方式

访问成员变量的方式取决于你在哪里进行访问，以及该变量的**访问修饰符**。

#### 方式一：内部访问（直接访问）

**适用场景：**
在**该成员变量所属的类内部**的任何方法中。

**实现方式：**
可以直接使用变量名访问和修改，无需任何特殊语法。如果你想区分同名的局部变量或参数，可以使用 `this` 关键字。

**代码示例：**

```java
public class Account {
    // 成员变量，设置为 private，体现封装
    private double balance;

    // 构造方法：内部访问 balance 进行初始化
    public Account(double initialDeposit) {
        // 直接访问和赋值
        this.balance = initialDeposit;
    }

    // 类内部方法：直接访问和修改 balance
    public void deposit(double amount) {
        if (amount > 0) {
            // 直接访问和修改 balance
            this.balance += amount;
            System.out.println("存款成功。");
        }
    }

    // 类内部方法：直接访问 balance 进行读取
    public double getBalanceInternal() {
        return this.balance; // 直接读取 balance
    }
}
```

> **设计者视角：** 在类内部，我们相信设计者对自己的数据结构了如指掌，所以允许直接访问。但一旦数据要暴露给外部，就必须受到保护。

---

#### 方式二：外部访问（通过属性受控访问）

**适用场景：**
从**该类外部**的另一个类或方法中访问该成员变量。

**实现方式：**
通过该类提供的**公共方法**（即 Getter 和 Setter 方法，也就是我们所说的**属性**）进行间接访问。

#### 1\. Getter 方法（读取访问）

- **目的：** 允许外部世界安全地**读取**内部私有成员变量的值。
- **命名规范：** 通常是 `public` 的，方法名以 `get` 开头（例如：`getName()`, `getBalance()`），对于布尔类型，也可以使用 `is` 开头（例如：`isLoggedIn()`）。

#### 2\. Setter 方法（写入访问）

- **目的：** 允许外部世界安全地**修改**内部私有成员变量的值。
- **命名规范：** 通常是 `public` 的，方法名以 `set` 开头（例如：`setName(String name)`, `setBalance(double amount)`）。

**代码示例 (基于上面的 `Account` 类添加 Getter/Setter)：**

```java
public class Account {
    private double balance;
    // ... 构造方法和 deposit 方法保持不变 ...

    // Getter 方法：外部读取 balance 的接口
    public double getBalance() {
        // 【设计者审查点 1】: 你可以在这里添加日志、权限检查等逻辑
        return this.balance;
    }

    // Setter 方法：外部修改 balance 的接口 (虽然银行账户不常用 setBalance，但用于演示)
    public void setBalance(double newBalance) {
        // 【设计者审查点 2】: 外部数据校验，确保 balance 永远是有效状态
        if (newBalance < 0) {
            throw new IllegalArgumentException("余额不能为负数!");
        }
        this.balance = newBalance;
    }
}

// 外部类如何访问
public class Bank {
    public static void main(String[] args) {
        Account userAccount = new Account(100.0);

        // **读取访问 (Getter)**
        double current = userAccount.getBalance();
        System.out.println("当前余额: " + current); // 输出 100.0

        // **写入访问 (Setter)**
        userAccount.setBalance(500.0); // 正常修改

        // 尝试非法写入，Setter 会阻止
        // userAccount.setBalance(-10.0); // 抛出异常，防止内部状态被破坏
    }
}
```

---

### 💡 为什么必须使用 Getter 和 Setter？ (设计哲学)

你可能会问，如果把成员变量直接声明为 `public` 岂不是更简单？

从设计者的角度看，对成员变量的访问修饰符的选择，本质上是在权衡：

$$\text{访问修饰符的选择} = \text{控制力} \times \text{安全性}$$

我们设计 Java 的**封装原则**要求你**不要**直接暴露 `public` 成员变量，原因如下：

1.  **数据校验与保护：** Getter/Setter 让你有机会在数据**写入**（Setter）或**读取**（Getter）时介入，进行必要的**校验**和**逻辑处理**。如上面示例，我们阻止了负数余额的写入，保证了 `Account` 对象始终处于一个**合法且有效**的状态。
2.  **代码灵活性：** 如果将来你决定修改成员变量的内部存储方式（例如，将 `double balance` 改为 `BigDecimal balance` 以提高精度），你只需要修改类内部的 Getter/Setter 逻辑，而**外部调用者不需要修改任何代码**，因为外部依赖的是方法签名，而不是内部的实现细节。
3.  **只读/只写控制：** 你可以只提供 Getter（实现**只读属性**），或者只提供 Setter（实现**只写属性**，虽然较少见），从而实现对数据访问的**精细化控制**。

**总结：** 访问成员变量是编程中的基础操作，但通过 Getter/Setter（属性）进行**受控访问**，则是将 Java 代码从“能运行”提升到“**符合面向对象设计规范**”的关键一步。
