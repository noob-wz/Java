# 🔑 访问成员变量的两种方式

**访问成员变量的方式取决于：**  
（1）**是否被 `static` 修饰** ，这决定了访问的具体“身份”，是**类变量还是对象变量** ；  
（2）然后取决于你**在哪里进行访问（内部 or 外部）** ；  
（3）以及它的**访问权限** (`private`/`public`等)。

## 一、 内部访问机制 (Internal Access Mechanisms)

内部访问指的是在 **当前类的方法体、构造器或初始化块中** 访问本类定义的成员变量。访问的规则取决于该成员是否为 `static`。

### 1\. 访问实例变量 (Non-Static Fields)

- **规则：** 实例变量必须通过一个 **对象实例** 才能访问。
- **代码位置：** 只能在 **非静态方法**（实例方法）和 **构造方法** 中直接访问。
- **隐式 `this`：** 当你在实例方法中直接写 `age` 时，编译器在底层会自动将其编译为 `this.age`。

| 访问情景       | 访问方式                 | 示例                                               |
| :------------- | :----------------------- | :------------------------------------------------- |
| **标准访问**   | 直接使用变量名。         | `age = 20;` (编译器自动解析为 `this.age`)          |
| **解决隐藏**   | 必须使用 `this.变量名`。 | `this.age = age;` (区分局部参数和实例变量)         |
| **静态方法中** | **❌ 禁止直接访问！**    | 静态方法没有 `this` 引用，无法定位堆上的实例数据。 |

> **设计者警告：** 静态方法不能直接访问实例变量，是 Java 最基础的规则。若要访问，必须通过传入一个对象引用，如 `public static void method(User user)`，然后使用 `user.age`。

### 2\. 访问静态变量 (Static Fields)

- **规则：** 静态变量属于类，与对象无关，可以直接使用。
- **代码位置：** 可以在 **任何方法** 中（包括静态方法和非静态方法）直接访问。
- **最佳实践：** 尽管可以直接使用变量名，但在代码中明确使用 `类名.变量名` 是最佳实践，以增强可读性和避免变量隐藏。

| 访问情景     | 访问方式                 | 示例                                           |
| :----------- | :----------------------- | :--------------------------------------------- |
| **标准访问** | 直接使用变量名。         | `count = 10;`                                  |
| **最佳实践** | 显式使用 `类名.变量名`。 | `User.count = 10;` (推荐)                      |
| **解决隐藏** | 必须使用 `类名.变量名`。 | `User.count = count;` (区分局部变量和静态变量) |

---

### 3\. 变量隐藏 (Shadowing) 的内部解决机制

变量隐藏发生在 **局部变量或方法参数** 与 **成员变量** 同名时。在作用域更小的局部环境中，局部变量具有最高的优先级。

| 隐藏类型         | 隐藏者        | 被隐藏者 | 解决机制 (强制访问)        |
| :--------------- | :------------ | :------- | :------------------------- |
| **实例变量隐藏** | 局部变量/参数 | 实例变量 | 强制使用 **`this.变量名`** |
| **静态变量隐藏** | 局部变量/参数 | 静态变量 | 强制使用 **`类名.变量名`** |

#### 💡 代码示例： `this` 和 `ClassName` 的作用

```java
public class ShadowDemo {
    // 实例变量 (被隐藏)
    private int value = 10;
    // 静态变量 (被隐藏)
    private static int COUNT = 100;

    // 实例方法
    public void set(int value, int COUNT) { // 参数变量 (隐藏了成员变量)

        // 1. 访问局部参数 (优先级最高)
        System.out.println("局部 value: " + value); // 打印方法的参数 value

        // 2. 访问实例变量 (被隐藏，需用 this)
        this.value = value; // 将局部参数赋值给实例变量

        // 3. 访问静态变量 (被隐藏，需用 ClassName)
        ShadowDemo.COUNT = COUNT; // 将局部参数赋值给静态变量
    }
}
```

---

## 二、 外部访问机制与内存解析

成员变量定义完成后，在其他类（外部）中如何使用它，取决于它**是否被 `static` 修饰（是对象变量还是类变量），以及它的访问权限 (`private`/`public`等)** 。

我们主要关注 **“如何找到变量”** 这一动作。

### 场景 A：访问实例变量 (Instance Variables) —— 必须先有对象

实例变量存储在**堆内存 (Heap)** 的对象内部。如果没有创建对象，实例变量就不存在。

- **规则：** 必须先通过 `new` 关键字实例化对象，然后通过**对象引用**来访问。
- **语法：** `对象引用.变量名`
- **设计者视角：** 你必须先盖好房子（`new`），才能进门去拿房子里的椅子（实例变量）。

<!-- end list -->

```java
public class Hero {
    public String name; // 实例变量 (非 static)
}

// --- 在外部类中 ---
// Hero.name = "Zilong"; // ❌ 错误！类不能直接访问实例变量，因为内存中还没有对象。

Hero hero1 = new Hero(); // 1. 先创建对象 (在堆上分配空间)
hero1.name = "Zilong";   // 2. 通过对象引用访问
System.out.println(hero1.name);
```

### 场景 B：访问静态变量 (Static Variables) —— 直接找类

静态变量存储在**方法区 (Method Area / Metaspace)**，属于类本身。只要类被加载，变量就存在了。

- **规则：** 不需要创建对象，直接通过**类名**访问。
- **语法：** `类名.变量名`
- **特殊情况：** 虽然 Java 允许通过 `对象引用.变量名` 来访问静态变量，但这被视为**糟糕的实践**（Bad Practice），因为它会误导阅读者以为这是个实例变量。
- **设计者视角：** 这是“公共设施”。你不需要自己盖房子，直接去市中心的广场（类）就能找到。

<!-- end list -->

```java
public class Config {
    public static int maxUsers = 100; // 静态变量
}

// --- 在外部类中 ---
Config.maxUsers = 200; // ✅ 推荐！直接通过类名访问

// Config c = new Config();
// c.maxUsers = 200;    // ⚠️ 不推荐！虽然编译器允许，但容易产生歧义。
```

---

### 场景 C：封装的影响 (Getter/Setter) —— 现实世界的标准做法

上面的 A 和 B 场景假设变量是 `public` 的。但在实际开发中，根据**封装原则**，成员变量通常是 `private` 的。

- **规则：** 当变量为 `private` 时，**点号 (`.`) 直接访问将被禁止**。外部必须通过类提供的 `public` 方法（Getter/Setter）来间接访问。
- **语法：** `对象引用.get变量名()` 或 `类名.get变量名()`

| 变量类型     | 可见性    | 外部访问代码示例           | 评价                           |
| :----------- | :-------- | :------------------------- | :----------------------------- |
| **实例变量** | `public`  | `user.name = "Tom";`       | **不安全**，破坏封装。         |
| **实例变量** | `private` | `user.setName("Tom");`     | **最佳实践**。                 |
| **静态变量** | `public`  | `Config.MAX_COUNT`         | 常用作**全局常量** (`final`)。 |
| **静态变量** | `private` | `Config.setMaxCount(100);` | 用于控制类级别的配置。         |

---

### 🧠 内存视角的深度对比 (Memory Perspective)

为了彻底理解“为什么访问方式不同”，请看这张内存逻辑图：

1.  **访问 `static` 变量：**

    - JVM 看到 `Hero.count`。
    - JVM 直接去 **方法区** 找到 `Hero` 类的静态区。
    - **不需要** 经过堆内存。

2.  **访问实例变量：**

    - JVM 看到 `hero1.name`。
    - JVM 先看 `hero1` 变量（在栈上），拿到**堆内存地址**。
    - JVM 顺着地址找到 **堆** 上的具体对象。
    - JVM 在对象内部找到 `name` 字段。

### 📝 总结

- **实例变量** $\rightarrow$ **属于对象** $\rightarrow$ **必须 `new`** $\rightarrow$ 用 **`引用.`** 访问。
- **静态变量** $\rightarrow$ **属于类** $\rightarrow$ **无需 `new`** $\rightarrow$ 用 **`类名.`** 访问。
- **私有变量** $\rightarrow$ **拒绝直接访问** $\rightarrow$ 用 **`get/set`** 方法。
