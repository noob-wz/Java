前面清楚地了解了对象是如何在堆内存中诞生的（`new` 的工作原理），那么下一个逻辑问题就是：**当这些对象不再需要时，它们是如何从堆内存中消失的？**

这就是 Java 自动内存管理的核心——**垃圾回收（Garbage Collection, GC）**机制。

### 🗑️ 垃圾回收（GC）机制（底层原理）

垃圾回收是 Java 语言相较于面向过程语言（如 C）在工程实践中最重要的改进之一。它彻底消除了程序员手动管理内存的负担和由此产生的绝大多数内存错误。

#### 1. 核心挑战：判定对象“已死亡”

GC 的首要任务是判断堆内存中的对象是否仍然“存活”。如果一个对象不再可能被程序中的任何代码访问或使用，那么它就可以被回收。

- **设计者视角：** 我们在设计 JVM 时，选择了 **可达性分析（Reachability Analysis）** 算法作为主流的判定方式，因为它比传统的引用计数法更健壮，能解决对象循环引用的问题。

#### 2. 可达性分析（Reachability Analysis）机制

可达性分析通过定义一组被称为 **GC Roots** 的起始点，从这些点向下搜索，形成一个引用链（Reference Chain）。

- **GC Roots 是什么？** 它们是程序运行中“必然存活”的对象，是引用链的起点，主要包括：
  - **栈中引用的对象：** 比如 `main` 方法中声明的局部变量（`BankAccount account`）。
  - **方法区中的静态成员变量引用的对象：** 比如类中定义的 `static final` 常量。
  - **JNI（Native）方法栈中引用的对象** 等。
- **判定标准：** 任何对象，如果从任一 GC Root 出发，都**无法**通过引用链到达，则被判定为“不可达”，即可以被回收。

#### 3. 垃圾回收的底层意义（健壮性与安全性）

| 机制             | Java (GC)                                                                                                                 | 传统面向过程语言 (C/C++)                                                       |
| :--------------- | :------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------- |
| **内存管理**     | **自动化**：JVM 负责回收。                                                                                                | **手动化**：程序员调用 `free()` 释放。                                         |
| **风险规避 (1)** | **杜绝内存泄漏**：即使程序员忘记取消引用，GC 最终也会回收不可达对象。                                                     | **内存泄漏**：如果忘记调用 `free()`，程序将持续占用内存直至耗尽。              |
| **风险规避 (2)** | **杜绝野指针**：GC 回收内存后，会清除所有引用，或在对象被回收前确保不会有引用在使用，因此不会出现访问到已释放内存的错误。 | **野指针**：释放内存后，变量仍可能保留原地址，导致访问到危险区域或不确定数据。 |

#### 4. 堆的分代管理（简要提及）

为了提高 GC 效率，我们通常将 **堆** 分为不同的区域，即 **分代（Generational）**：

- **新生代（Young Generation）：** 存放新创建的对象。这里对象生命周期短，GC 频繁且效率高。
- **老年代（Old Generation）：** 存放经过多次 GC 仍然存活的对象（即生命周期长的对象）。GC 不频繁，但耗时较长。

**总结：** GC 机制是将面向对象从理论推向大规模应用实践的工程保障。它让 Java 程序更安全、更稳定，同时也是对我们前面讲到的**堆内存**对象的最终管理。

---
