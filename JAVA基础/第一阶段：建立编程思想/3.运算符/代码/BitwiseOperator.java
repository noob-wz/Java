// 目的：了解按位逻辑运算符的使用

public class BitwiseOperator {
    public static void main(String[] args) {
        // 2 & 3 推导过程
        // 1. 先得到2的补码：  
        //      2的原码 00000000 00000000 00000000 00000010
        //      2的补码 00000000 00000000 00000000 00000010 （计算机中存储的）
        // 2. 先得到3的补码：  
        //      3的原码 00000000 00000000 00000000 00000011
        //      3的补码 00000000 00000000 00000000 00000011 （计算机中存储的）
        // 3. 按位 &
        //      2 & 3 的结果：
        //          2的补码 00000000 00000000 00000000 00000010
        //          3的补码 00000000 00000000 00000000 00000011
        //          2 & 3: 000000000 00000000 00000000 0000010 （依然是补码，人需要看原码来找十进制数，不过正数同原码）
        // 运算后的补码和原码相同，所以2&3的原码对应的十进制为2
        System.out.println(2 & 3); // 2

        // ~-2 推导过程
        // 1. 先得到-2的补码：
        //     -2的原码 10000000 00000000 00000000 00000010
        //     -2的反码 11111111 11111111 11111111 11111101
        //     -2的补码 11111111 11111111 11111111 11111110 （计算机中存储的）
        //     -2的取反 00000000 00000000 00000000 00000001 （依然是补码，人需要转换成原码来看十进制，正数相同）
        // // 运算后的补码和原码相同，所以～-2的原码对应的十进制为2
        System.out.println(~-2); // 1

        // ~2 推导过程
        // 1. 先得到2的补码：
        //      2的原码 00000000 00000000 00000000 00000010
        //      2的反码 00000000 00000000 00000000 00000010
        //      2的补码 00000000 00000000 00000000 00000010
        //      2的取反 11111111 11111111 11111111 11111101 （依然是补码，人需要转换成原码来看十进制）
        // 转回原码先-1  11111111 11111111 11111111 11111100 （反码）
        //     反码取反  10000000 00000000 00000000 00000011 （原码）
        // // 运算后的补码和原码相同，所以～2的原码对应的十进制为-3
        System.out.println(~2); // -3

    }
}
