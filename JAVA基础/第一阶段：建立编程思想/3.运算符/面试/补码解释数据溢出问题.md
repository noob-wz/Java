```java
// 假设 int 是 32 位
int a = 128;
byte b = (byte) a; // byte 只有 8 位，最大值是 127
System.out.println(b);
```

问： b 打印出来是多少？ （提示：这不是截断那么简单，这是 **“溢出轮回”** ）。

答：-128

---

### 面试题：为什么 `int a = 128; byte b = (byte)a;` 的结果是 -128？

#### 1. 第一步：还原现场 (int 的存储)

首先，`int` 类型占 **32 位** (4 字节)。
数字 `128` 的二进制表示是：**1 后面跟 7 个 0**。

在内存中，`int a = 128` 是这样存的（注意看最低的 8 位）：

```text
00000000 00000000 00000000 10000000
^                          ^
高24位 (全是0)              低8位 (这就是128)

```

#### 2. 第二步：暴力截断 (强制转换动作)

当你执行 `(byte) a` 时，是将一个 **32 位** 的大容器倒入 **8 位** 的小容器。
Java 的规则非常简单粗暴：**直接砍掉前面多余的 24 位，只保留最后面 (最低) 的 8 位。**

截断后的结果（留在 byte 里的数据）：

```text
10000000

```

#### 3. 第三步：补码解读 (结果认定)

现在的关键是：**如何理解 `10000000` 这串二进制？**

在计算机中，有符号数（Signed Integer）是遵循 **补码 (Two's Complement)** 规则的：

- **最高位（第一位）是符号位：** `0` 代表正数，`1` 代表负数。
- **当前二进制：** `10000000`。
- **判定：** 首位是 `1`，说明它是 **负数**。

**它是多少呢？**
在 8 位二进制补码系统中：

- `01111111` 是最大正数 (+127)
- `10000000` 是规定好的**最小负数 (-128)**

---

### 🎙️ 面试满分回答话术（请背诵）

> “这道题涉及到底层的二进制截断机制。
>
> 1. 首先，`int` 是 32 位的，128 的二进制补码是 `00...00 1000 0000`。
> 2. 当我们强制转换为 `byte` 时，会发生**截断 (Truncation)**，高 24 位被丢弃，只保留最低的 8 位。
> 3. 此时 `byte` 内部的二进制变成了 `1000 0000`。
> 4. 在计算机补码表示法中，byte 的最高位是符号位。`1` 开头代表负数，而 `1000 0000` 正好是 8 位有符号整数能表示的最小值，即 **-128**。
>
> 所以，结果发生了**数据溢出**，从正数变成了负数。”
