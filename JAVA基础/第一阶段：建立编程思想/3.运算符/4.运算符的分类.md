## 一、 算术运算符（Arithmetic Operators）

用于数学计算。

| 运算符 | 名称       | 示例           | 描述                                                                                             |
| :----- | :--------- | :------------- | :----------------------------------------------------------------------------------------------- |
| `+`    | 正号/加法  | `+7` `a + b`   | 也用于字符串连接。                                                                               |
| `-`    | 减法/负号  | ` -b` `a - b ` |                                                                                                  |
| `*`    | 乘法       | `a * b`        |                                                                                                  |
| `/`    | 除法       | `a / b`        | **结果和 操作数的最高数据类型保持一致**                                                          |
| `%`    | 取模(求余) | `a % b`        | 计算两数相除后的余数。注意：区别于 C 语言，**java 中取余的操作数不必非得是整数，也可以是浮点数** |

> 在 Java 的二元算术运算中 **（加/减/乘/除/取余）**
>
> - (1)操作数会提升至两者中**最高精度的数据类型**，而且**结果与最高精度类型保持一致**
>
> - (2)此过程中操作数**最低精度必须是 `int`** ，所以任何**小于 int 的类型（`char`, `byte`, `short`)在参与运算时，都自动会被提升为 int 类型**。
> - (3)余数的符号，永远与被除数（即操作符左边的数）的符号保持一致。因为`a % b = a - a / b * b`

### 自增与自减运算符（`++` 和 `--`）

用于将变量的值增加或减少 1

| 运算符 | 名称     | 示例      | 描述                                                                |
| :----- | :------- | :-------- | :------------------------------------------------------------------ |
| `i++`  | 后置增量 | `y = i++` | **先返回，后自增（副作用）。** 先返回 `i` 的值，然后 `i` 自身加 1。 |
| `++i`  | 前置增量 | `y = ++i` | **先自增（副作用），后返回。** 先将 `i` 自身加 1，然后再返回 i。    |

[自增和自减运算符的详细说明](3.自增和自减运算符.md)

---

## 二、 关系运算符（比较运算符）

用于比较两个值。比较结果总是 **布尔值（`boolean`）**：`true` 或 `false`。

| 运算符 | 描述             | 示例     |
| :----- | :--------------- | :------- |
| `==`   | 等于（Equality） | `a == b` |
| `!=`   | 不等于           | `a != b` |
| `>`    | 大于             | `a > b`  |
| `<`    | 小于             | `a < b`  |
| `>=`   | 大于等于         | `a >= b` |
| `<=`   | 小于等于         | `a <= b` |

- 关系运算符的结果都是 `boolean`类型，也就是要么是 `true`，要么是 `false`
- 关系表达式经常用在`if`结构的条件或循环结构的条件中
- **关系表达式两边的操作数同算数运算一样，会发生数据类型提升然后再进行比较**

---

## 三、 逻辑运算符（Logical Operators）

逻辑运算符的**结果总是 `boolean`** 。

### 1. 短路逻辑（Short-Circuiting）

这是最常用的逻辑运算符，它们具有**短路特性**，用于提高效率。

| 运算符 | 名称         | 描述                                                    | 短路特性                                                                     |
| :----- | :----------- | :------------------------------------------------------ | :--------------------------------------------------------------------------- |
| `&&`   | 逻辑与 (AND) | 只有当左右两边的表达式都为 `true` 时，结果才为 `true`。 | **如果左边为 `false`，则右边的表达式不再执行**（因为结果已确定为 `false`）。 |
| `\|\|` | 逻辑或 (OR)  | 只要左右两边有一个表达式为 `true`，结果就为 `true`。    | **如果左边为 `true`，则右边的表达式不再执行**（因为结果已确定为 `true`）。   |

> 说明
>
> 1\. 短路运算符是 Java 中 **最常用的** 逻辑运算符，它们的特点是：**如果第一个操作数的结果已经能够确定整个表达式的值，则第二个操作数将不再执行求值。**
> 2\. 大多数情况下用的短路逻辑运算符，以提高效率并避免不必要的副作用和潜在的错误

### 2. 非短路逻辑

| 运算符 | 名称           | 描述                                    |
| :----- | :------------- | :-------------------------------------- |
| `&`    | 逻辑与 (AND)   | 必须计算两侧的表达式。                  |
| `\|`   | 逻辑或 (OR)    | 必须计算两侧的表达式。                  |
| `!`    | 逻辑非 (NOT)   | 对布尔值取反。                          |
| `^`    | 逻辑异或 (XOR) | 两边不同时为 `true`，相同时为 `false`。 |

> 说明
>
> 非短路运算符 (`&` 和 `|`) 的主要用途是位运算符 。当它们用于布尔类型时，被称为逻辑运算符，但它们**不具备短路机制，即无论左侧结果怎样，都会对两侧进行求值**
>
> - **当非短路运算符 (`&` 和 `|`)作为位运算符时，意义重大**
> - 非短路运算符 (`&` 和 `|`)作为逻辑运算符，意义不大，通常**不推荐**

---

## 四、 位运算符和移位运算符（Bitwise and Shift Operators）

直接对整数类型的**二进制位**进行操作（适用于 `byte`, `short`, `int`, `long`, `char`）。

### 1. 位运算符 (Bitwise)

| 运算符 | 名称     | 描述                              |
| :----- | :------- | :-------------------------------- |
| `&`    | 按位与   | 两位都为 1 时，结果为 1。         |
| `\|`   | 按位或   | 两位中至少一位为 1 时，结果为 1。 |
| `^`    | 按位异或 | 两位不同时，结果为 1。            |
| `~`    | 按位取反 | 0 变 1，1 变 0（包括符号位）。    |

### 2. 移位运算符 (Shift)

| 运算符 | 名称           | 描述                                                                        |
| :----- | :------------- | :-------------------------------------------------------------------------- |
| `<<`   | 左移           | 所有位向左移动指定的位数，低位补 0。                                        |
| `>>`   | **带符号右移** | 所有位向右移动，高位根据原符号位填充（保持正负不变）。                      |
| `>>>`  | **无符号右移** | 所有位向右移动，**高位始终用 0 填充**（不保留符号位，主要用于处理位掩码）。 |

---

## 五、 赋值运算符（Assignment Operators）

### 1. 简单赋值

| 运算符 | 示例     | 描述                       |
| :----- | :------- | :------------------------- |
| `=`    | `a = 10` | 将右侧的值赋给左侧的变量。 |

### 2. 复合赋值（Compound Assignment）

将算术或位操作与赋值结合在一起。

| 运算符               | 示例     | 等价形式                | **关键特性**                                                                |
| :------------------- | :------- | :---------------------- | :-------------------------------------------------------------------------- |
| `+=`                 | `a += 5` | `a = (a的类型) (a + 5)` | **具有隐式类型转换（Casting）功能。**                                       |
| `-=`                 | `a -= 5` | `a = (a的类型) (a - 5)` | 例如：`byte b = 1; b += 1;` **编译通过，因为 JVM 自动进行了强制类型转换。** |
| `*=`                 | `a *= 5` |                         | 但 `byte b = 1; b = b + 1;` **会编译报错** ，因为缺少强制类型转换。         |
| `%=`, `/=`           | ...      |                         |                                                                             |
| `&=`, `              | ...      | ...                     |                                                                             |
| `<<=`, `>>=`, `>>>=` | ...      |                         |                                                                             |

> 总结
>
> 1\. 赋值操作符**本身也是一个表达式** ，具有**返回值** 和**副作用** ：
>
> - 副作用 ： 将右侧的值写入左侧变量的内存位置（这是赋值的**核心目的**）。
> - 返回值 ： 赋值操作完成后，**整个表达式返回被赋的值**。
>
> 2\. 当使用复合赋值运算符时，虽然在执行底层运算时会遵循数据类型提升规则，但 Java 会自动执行一个隐式的强制类型转换，而基本赋值运算符不会
>
> $$a \ op= b \ \text{等价于} \ a = (\text{类型 } a) (a \ op \ b)$$
>
> - 假如声明 `byte b`：
>   - 标准赋值：`b = b + 1;` // **编译报错**。因为 `b + 1` 的结果是 `int`，不能直接赋给 `byte`，需要手动写成 `b = (byte)(b + 1);`
>   - 复合赋值：`b += 1;` // **编译通过**。编译器自动添加了强制类型转换，等价于 `b = (byte)(b + 1);`

---

## 六、 其他特殊运算符

| 运算符       | 名称                  | 语法                    | 描述                                                     |
| :----------- | :-------------------- | :---------------------- | :------------------------------------------------------- |
| `(type)`     | 强制类型转换          | `(int) myDouble`        | 将值从一种类型显式转换为另一种类型。                     |
| `?:`         | 条件运算符/三元运算符 | `A ? B : C`             | 如果 A 为 `true`，返回 B；否则返回 C。                   |
| `instanceof` | 类型比较              | `obj instanceof String` | 检查左侧的对象是否是右侧类型（或其子类、实现类）的实例。 |
| `new`        | 对象创建              | `new MyObject()`        | 用于创建新的对象实例。                                   |
| `.`          | 成员访问              | `obj.method()`          | 用于访问对象的成员变量或方法。                           |

> 总结
>
> 1\. 条件运算符 `条件表达式 ? 表达式A : 表达式B`
>
> - **副作用控制：** 尽量确保 表达式 A 和 表达式 B 是**纯粹的，没有副作用**。如果在其中引入副作用，会使得代码更难调试
> - 条件表达式可以转化为 `if-else` 语句。尽量不要嵌套使用条件表达式，如果条件复杂，可以使用 `if-else`

---

## 七、 优先级和结合性总结

运算符的**优先级**决定了表达式中哪个运算先执行（如乘法高于加法）。当优先级相同时，**结合性**决定了执行顺序（通常从左到右）。

以下是 Java 运算符的优先级表，**优先级从上到下依次递减**（第一行优先级最高，最后一行优先级最低）：

### 🔢 Java 运算符优先级表

|  优先级  | 运算符                                                        | 名称/描述                                                     | 结合性 (Associativity) |
| :------: | :------------------------------------------------------------ | :------------------------------------------------------------ | :--------------------- |
| **最高** | `[]` `.` `()` (方法调用) ` ,` `{}` `;`                        | 数组下标、成员访问、方法调用                                  | 左到右                 |
|          | `++` `--` (后置)                                              | 后置递增/递减                                                 | 左到右                 |
|          | `++` `--` (前置) `+` (一元) `-` (一元) `!` `~` `new` `(type)` | 前置递增/递减、一元正负号、逻辑非、逻辑非、对象创建、类型转换 | **右到左**             |
|          | `*` `/` `%`                                                   | 乘法、除法、取模                                              | 左到右                 |
|          | `+` `-`                                                       | 加法、减法                                                    | 左到右                 |
|          | `<<` `>>` `>>>`                                               | 左移、带符号右移、无符号右移                                  | 左到右                 |
|          | `<` `<=` `>` `>=` `instanceof`                                | 关系运算符、类型检查                                          | 左到右                 |
|          | `==` `!=`                                                     | 相等性判断、不相等判断                                        | 左到右                 |
|          | `&`                                                           | 按位与                                                        | 左到右                 |
|          | `^`                                                           | 按位异或                                                      | 左到右                 |
|          | `\|`                                                          | 按位或                                                        | 左到右                 |
|          | `&&`                                                          | 逻辑与                                                        | 左到右                 |
|          | `                                                             |                                                               | `                      |
|          | `?:`                                                          | 条件运算符（三元运算符）                                      | **右到左**             |
| **最低** | `=` `+=` `-=` `*=` `/=` 等所有赋值运算符                      | 赋值、复合赋值                                                | **右到左**             |

---

### 💡 记住关键点

#### 关键点 1

从局部（操作数）到整体的顺序分类来理解优先级( **优先级从高到低** )：

1.  **括号永远优先：** 如果你不确定优先级，或者想改变默认的计算顺序，使用**圆括号 `()`**。
2.  **单目运算符最高**：因为它通常是**针对一个数**进行操作的，像 `++`、`--`、`!` 这样的操作通常具有很高的优先级
3.  **算术运算：** **先乘除模 (`* / %`)，后加减 (`+ -`)**。这和我们数学中的规则一致。
4.  **位移运算符**
5.  **关系和逻辑：** 关系运算符 (`< > ==`) 优先于逻辑运算符 (`&& ||`)。
6.  **右结合性：** 大多数运算符都是**左到右**结合（如 $a + b - c$ 等价于 $(a+b) - c$），但**单目运算符、条件运算符 (`?:`) 和赋值运算符 (`=`)** 是**右到左**结合的。
    - 为什么说条件运算符的结合性也是从右往左的。首先看结合性的目的是为了解决同级冲突，所以条件运算符`?:`本身是一个整体，当存在复合条件运算符时，以一个完整单位看条件运算符，不同的条件运算符之间时从右往左的

#### 例子：

$$1 \ll 3 + 2 \& 7$$

- 首先计算优先级最高的加法：$3 + 2 = 5$
- 然后计算移位：$1 \ll 5 = 32$
- 最后计算按位与：$32 \& 7 = 0$

最终表达式等价于：

$$
(1 \ll (3 + 2)) \& 7
$$

> 为了代码的可读性，**强烈建议使用括号**来明确运算顺序，而不是**过度依赖优先级规则**。

#### 关键点 2

**凡是需要将两个数值操作数进行结合或比较的二元运算符（包括算数运算符、比较运算符和位运算符、复合赋值运算符），都必须先保证操作数的类型一致，因此都会触发数值提升机制**

#### 关键点 3

**常规的基本表达式在计算过程中，其操作数和中间结果都会先存储到临时空间（如 CPU 寄存器或操作数栈）**

- 操作数栈的**作用：** 用作计算表达式的临时工作区（您说的“临时空间”）和中间结果存储区。

（示例说明）

```java
int a = 10;
int b = a + 10;
```

以下是 `int b = a + 5;` 的执行步骤：

|    步骤    | 字节码指令 (JVM) 概念 | 操作数栈状态 (临时空间) | 局部变量表状态 (永久存储) | 核心说明                                                                                                            |
| :--------: | :-------------------- | :---------------------- | :------------------------ | :------------------------------------------------------------------------------------------------------------------ |
| **Step 1** | **加载变量 a**        | 栈顶：`[10]`            | `a=10, b=?`               | 右边表达式的计算，JVM 将变量 `a` 的值 `10` **复制**到操作数栈。                                                     |
| **Step 2** | **加载常量 5**        | 栈顶：`[10, 5]`         | `a=10, b=?`               | JVM 将常量 `5` 推入操作数栈。                                                                                       |
| **Step 3** | **执行加法**          | 栈顶：`[15]`            | `a=10, b=?`               | JVM 执行 `iadd` 指令，弹出 `10` 和 `5`，计算 $10+5=15$，并将结果 `15` 推回操作数栈。                                |
| **Step 4** | **存储变量 b**        | 栈顶：`[]` (空)         | `a=10, b=15`              | JVM 执行 `istore` 指令，将操作数栈顶的值 `15` **弹出**，并存储到 `b` 的永久位置，并且**此时操作数栈上的 15 被清除** |
