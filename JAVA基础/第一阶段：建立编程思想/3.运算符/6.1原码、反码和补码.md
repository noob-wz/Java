通过进制，理解了“数”可以有不同的书写方式（二进制、十进制）。但可以发现，这存在一个大问题：**我们人类写数字有“正负号”（+ -），但 **计算机只有 0 和 1，也就是二进制** ，它怎么区分正数和负数呢？**

而且，计算机其实很“笨”，它最擅长做加法。如果你能让它**把减法也当成加法做** （比如 $5 - 3$ 变成 $5 + (-3)$），那电路设计就能省下几十亿美元的成本。

为了解决这两个问题（**表示正负** 和 **简化运算** ），计算机科学家们经历了一场“进化的三部曲”：**原码 $\rightarrow$ 反码 $\rightarrow$ 补码** 。

> 【重要补充说明】现代计算机里都是以 **补码** 的形式存储**有符号数据** 这个过程发生在 **编译阶段** ，编译器将 **文本二进制转化成 `utf-16` 二进制之后** ，生成逻辑树（**这个过程依然是文本二进制** ），然后在逻辑树生成字节码文件的过程中，**带符号数值类型会被转化为补码格式进行存储，但字符数据（即无符号整数）仍然保持其无符号的字符编码格式（utf-16）** 。

| 编译阶段产物        | 存储内容                       | 存储形式                        | 是否使用补码 (Two's Complement)? |
| :------------------ | :----------------------------- | :------------------------------ | :------------------------------- |
| **`.class` 常量池** | 字符串字面量                   | Modified UTF-8 (无符号字节序列) | **否**                           |
| **`.class` 字节码** | **带符号整数** (`int`, `long`) | 补码                            | **是** (用于表示负数)            |
| **`.class` 字节码** | 指令操作码、无符号索引/地址    | 无符号整数                      | **否**                           |

---

### 一、原码

（以一个字节为例）
**这是什么？**
原码就是人类最本能的想法：**给二进制数贴个标签分正负。**

在计算机里，我们规定：**最左边的第一位**，不表示大小，只表示**符号**。

- **0** 代表 **+** (正数)
- **1** 代表 **-** (负数)

**怎么写？**
比如我们要写数字 **1**：

1.  **+1**：最左边写 `0`（代表正），后面写 `001`（代表 1）。
    - 结果：`0000 0001`
2.  **-1**：最左边写 `1`（代表负），后面写 `001`（代表 1）。
    - 结果：`10000001`

**原码的问题（为什么它不够好）：**
如果你让计算机做加法：**$1 + (-1)$**，按理说应该等于 **0** 对吧？
但在原码里，计算机直接把它们加起来：

```text
  00000001 (+1)
+ 10000001 (-1)
-------
  10000010
```

结果是 `10000010`。符号位是 1（负），后面是 2。结果变成了 **-2**。
**这显然算错了！**

> **总结原码：**
> 原码**容易看懂**（人眼一看就知道是多少），但**不好计算**（计算机直接相加会出错）。

---

### 二、反码的原理与设计目的 (试图解决计算问题)

**这是什么？**
为了解决上面那个“算错数”的问题，科学家想：既然负数导致算错，那我们把负数“变身”一下试试？
这就有了反码。

#### 1. 🔍 反码的原理

反码的原理主要涉及以下两个方面：

##### A. 正数的表示

- **定义：** 正数的反码就是其 **原码** 本身。
- **原码的原理：** 在一个 $N$ 位的二进制数中，最高位（最左边一位）被用作**符号位（Sign Bit）**：
  - **0** 表示这是一个**正数**。
  - **1** 表示这是一个**负数**。
- **示例 (8 位)：**
  - 数字 **+5** 的二进制原码是 $00000101$。
  - 因此，**+5** 的反码也是 $00000101$。

##### B. 负数的表示

- **定义：** 负数的反码是符号位**不变**，其它**所有位取反**
  - “取反”指：将 $0$ 变为 $1$，将 $1$ 变为 $0$。
- **步骤：**
  1.  写出该负数的二进制原码。
  2.  对这个原码符号位以外的**所有位**进行取反操作。
- **示例 (8 位)：**
  - 求数字 **-5** 的反码：
    1.  **-5** 的原码是 $10000101$。
    2.  将 $00000101$ 的所有位取反：$11111010$。
    3.  因此，**-5** 的反码是 $11111010$。

---

#### 2. 🎯 反码的设计目的

反码的设计核心目的是为了简化计算机中的**减法运算**，使其能够转化为**加法运算**。

##### A. 简化减法运算 (主要目的)

在计算机中，设计单独的减法电路比设计加法电路复杂。如果能将减法 $A - B$ 转换为加法 $A + (-B)$，那么只需要一套加法电路就能处理所有算术运算。

- **目的：** 使用反码表示负数，使得 $A + (-B)$ 的二进制加法结果，在**不考虑溢出位**的情况下，能够正确地代表 $A - B$ 的数学结果。

- **示例：** 计算 $5 - 3$ (即 $5 + (-3)$ )
  - **+5** 的反码：$00000101$
  - **-3** 的反码：$11111100$ ( $-3$ 的原码是 $10000011$)
  - 进行加法运算：
    $$
    \begin{array}{rcl}
    & 00000101 & (+5) \\
    + & 11111100 & (-3) \\
    \hline
    (1) & 00000001 &
    \end{array}
    $$
  - **结果处理：** 在反码系统中，如果最高位产生了进位（即上例中的 $(1)$ ），这个进位需要 **回卷** 加到结果的最低位上。
  - $00000001 + 1 = 00000010$
  - $00000010$ 对应的正数是 $+2$，结果正确。

##### B. 表示负数 (基本目的)

- **目的：** 提供一种标准化的方法来区分和表示正数和负数，以便计算机的电路可以识别并进行处理。

---

#### 3. ⚠️ 反码的缺点

虽然反码实现了用加法进行减法的目标，但它有一个致命的缺陷，这也是它最终被补码取代的主要原因：

##### A. 存在“正零”和“负零”

在 $N$ 位反码系统中，数字 **0** 有两种表示形式：

| 名称          | 二进制表示 (8 位) |
| :------------ | :---------------- |
| **正零 (+0)** | $00000000$        |
| **负零 (-0)** | $11111111$        |

- **问题：** 存在两种表示形式来表示同一个数学值（零），这会浪费一个编码空间，更重要的是，它会使计算机在判断一个数是否为零时，需要进行额外的比较操作（判断是 $00...0$ 还是 $11...1$），增加了电路设计的复杂性。

##### B. “回卷进位”的操作复杂

如上面示例所示，反码运算在产生溢出进位时，需要执行一个额外的“回卷加 $1$ ”的操作。这增加了算术逻辑单元（ALU）的复杂性和处理时间。

**总结来说：** 反码通过将减法转化为加法，简化了运算电路的设计理念，但由于存在 **双零** 和复杂的 **回卷进位** 操作，它最终让位于设计更精巧、效率更高的**补码**系统。

[反码运算动画演示](6.2反码运算动画演示.html)

---

### 三、补码 (最终的完美方案)

**这是什么？**
这是现在所有计算机里真正存储数字的方式。它解决了所有问题。

**怎么变？**

- **正数**：**还是不用变！**（正数 原码=反码=补码，永远是 `0001`）
- **负数**：在**反码**的基础上，**加 1**。

**让我们一步步求 -1 的补码：**

1.  **第一步（找原码）**：写出 -1 的原码 $\rightarrow$ `1001`
2.  **第二步（变反码）**：符号位不变，后面取反 $\rightarrow$ `1110`
3.  **第三步（加 1）**：在 `1110` 后面加 1 $\rightarrow$ **`1111`**

所以，在计算机里，**-1** 长这个样子：**`1111`**。

**为什么补码完美？（见证奇迹）**
我们再来做那个 $1 + (-1)$ 的加法：

- \+1 是 `0001`
- \-1 是 `1111` (这是刚才算出来的补码)

<!-- end list -->

```text
   0001
+  1111
-------
  10000
```

注意！我们只有 **4 位** 格子。
那个最左边算出来的 **1**（进位），因为没有第 5 个格子放，直接被**丢掉了**。
剩下的结果就是：**`0000`**。

**看！$1 + (-1) = 0$。算对了！**

---

### 最终复习（手把手转换表）

假设我们要处理数字 **-5**（使用 4 位二进制是不够存 5 的，我们假设用 8 位）：

1.  **原码**（先写出样子）：
    符号位是 1，数值是 5(101)。
    $\rightarrow$ `1000 0101`

2.  **反码**（符号不动，后面取反）：
    $\rightarrow$ `1111 1010`

3.  **补码**（反码 + 1）：
    $\rightarrow$ `1111 1011`

**这就是计算机硬盘里实际存 -5 的样子。**

---
