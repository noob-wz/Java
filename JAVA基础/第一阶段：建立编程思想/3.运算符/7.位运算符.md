在 Java 中，**位运算符（Bitwise Operators）** 直接对整数类型（`byte`, `short`, `char`, `int`, `long`）的**二进制位**进行操作。

位运算通常比普通的算术运算（加减乘除）**速度更快**，因为它们直接对应 CPU 的指令。

因为 java 中存储基本数据类型的数都是补码，所以**以下的二进制都是针对补码来讲的** 。来看 Java 中位运算符的详细分类和讲解：

---

### 1\. 逻辑位运算符 (Bitwise Logical Operators)

这些运算符逐位比较两个数字。假设我们有两个整数：

- **A = 60** (二进制: `0011 1100`)
- **B = 13** (二进制: `0000 1101`)

| 运算符   | 名称           | 描述                                                                        | 示例 (A, B) | 结果 (二进制) | 结果 (十进制) |
| :------- | :------------- | :-------------------------------------------------------------------------- | :---------- | :------------ | :------------ |
| **`&`**  | **与 (AND)**   | 只有两个位对应**都为 1** 时，结果才为 1。                                   | `A & B`     | `0000 1100`   | 12            |
| **`\|`** | **或 (OR)**    | 只要有**一个位为 1**，结果就为 1。                                          | `A          | B`            | `0011 1101`   |
| **`^`**  | **异或 (XOR)** | 两个位**不同**时结果为 1，相同时为 0。                                      | `A ^ B`     | `0011 0001`   | 49            |
| **`~`**  | **非 (NOT)**   | **取反**。0 变 1，1 变 0 (一元运算符)。**特别说明：取反后的结果依然是补码** | `~A`        | `1100 0011`   | -61           |

> **注意关于 `~` 取反：**
> Java 使用**补码 (Two's Complement)** 表示负数，非反码。
> 公式为：$~x = -(x + 1)$
> 例如：`~60` 的结果是 `-61`。

---

### 2\. 移位运算符 (Bitwise Shift Operators)

移位运算符将数字的二进制位向左或向右移动。

#### **A. 左移运算符 (`<<`)**

- **符号：** `val << num`
- **规则：** 将位向左移动 `num` 位，右边空出的位**补 0**。
- **数学意义：** **$x \ll n$ 等效于 $x \times 2^n$** 。

**示例：**

```java
int a = 2; // 二进制: 0000 0010
int b = a << 2;
// 移动后: 0000 1000 (即十进制 8)
// 2 * 2^2 = 8
```

#### **B. 有符号右移运算符 (`>>`)**

> **本质**：有符号右移运算符 >> 等价于对 $x$ 执行 $x / 2^n$ 的操作，然后对结果进行向下取整（向负无穷方向）。

- **符号：** `val >> num`
- **规则：** 将位向右移动 `num` 位。
  - 如果原数是**正数**，高位**补 0**。
  - 如果原数是**负数**，高位**补 1** (保持符号不变)。
- **数学意义：** ** $x \gg n$ 等效于 $x / 2^n$ (向下取整)。**

**示例：**

```java
int a = 8;  // 0000 1000
int b = a >> 2; // 0000 0010 (结果 2)

int c = -8; // 1111 ... 1000 (补码表示)
int d = c >> 2; // 1111 ... 1110 (结果 -2)
```

#### **C. 无符号右移运算符 (`>>>`)**

- **符号：** `val >>> num`
- **规则：** 将位向右移动，**无论原数是正还是负，高位一律补 0**。
- **用途：** 这种运算通常用于处理不考虑符号位的逻辑数据（如哈希码、位图）。对于负数，结果会变成一个非常大的正数。

**示例：**

```java
int a = -1;
// 二进制(32位): 11111111 11111111 11111111 11111111

System.out.println(a >> 1);
// 结果: -1 (高位补1，仍然全是1)

System.out.println(a >>> 1);
// 结果: 2147483647 (Integer.MAX_VALUE)
// 二进制变为: 01111111 11111111 11111111 11111111 (高位补0)
```

---

### 3\. 复合赋值运算符

和其他运算符一样，位运算也有复合形式：

- `&=` (按位与赋值)
- `|=` (按位或赋值)
- `^=` (按位异或赋值)
- `<<=` (左移赋值)
- `>>=` (右移赋值)
- `>>>=` (无符号右移赋值)

---

### 4\. 实战应用场景 (为什么要用位运算？)

在日常业务开发中可能用得少，但在底层源码（如 HashMap）、算法题或高性能场景中非常常见。

#### **A. 判断奇偶数**

比取模 `%` 更快。

- 如果最后一位是 1，则是奇数；是 0，则是偶数。

<!-- end list -->

```java
if ((n & 1) == 1) { /* 奇数 */ }
if ((n & 1) == 0) { /* 偶数 */ }
```

#### **B. 权限控制 (Flag Masking)**

使用一个整数的不同位来表示不同的开关或权限。

```java
int READ = 1 << 0;   // 0001
int WRITE = 1 << 1;  // 0010
int EXEC = 1 << 2;   // 0100

int myPermission = READ | WRITE; // 0011 (既有读又有写)

// 检查是否有写权限
boolean canWrite = (myPermission & WRITE) != 0;
```

#### **C. 交换两个数 (不使用临时变量)**

这是一个经典的面试技巧（基于异或的可逆性：`a ^ b ^ b = a`）。

```java
int a = 5, b = 3;
a = a ^ b;
b = a ^ b; // 此时 b 变成了原来的 a
a = a ^ b; // 此时 a 变成了原来的 b
```

#### **D. 2 的幂次运算**

HashMap 源码中大量使用，计算容量或索引时非常高效。

- `x * 2` $\to$ `x << 1`
- `x / 2` $\to$ `x >> 1`

---

### 5\. 关键注意事项 (坑点)

1.  **类型提升 (Promotion)：**
    对 `byte`, `short`, `char` 进行位运算时，它们会先被自动提升为 `int` 类型再进行计算。
2.  **移位数的模运算：**
    - 如果对 `int` 移位，系统实际移动的是 `k % 32` 位。例如 `1 << 33` 等同于 `1 << 1`。
    - 如果对 `long` 移位，系统实际移动的是 `k % 64` 位。
3.  **运算符优先级：**
    位运算符的优先级通常**低于**算术运算符，但高于赋值运算符。
    - **建议：** 总是加上括号 `()` 以确保逻辑正确。
    - 错误写法：`val & 0x0F == 0` (会先算 `0x0F == 0`)
    - 正确写法：`(val & 0x0F) == 0`

---

### 总结

- **`&`, `|`, `^`, `~`**: 用于修改或读取特定的位（掩码操作）。
- **`<<`, `>>`**: 用于高效的乘除法（乘以或除以 2 的幂）。
- **`>>>`**: Java 特有的无符号右移，处理非数值逻辑位操作时必备。

**下一步建议：**
你想看一个具体的代码示例，演示如何使用\*\*位运算来实现一个简单的“权限管理系统”\*\*吗？
