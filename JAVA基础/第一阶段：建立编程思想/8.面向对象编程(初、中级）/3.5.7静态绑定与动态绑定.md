# ☕ Java 核心原理：静态绑定与动态绑定的本质区别

## 📖 前言：同一个对象，不同的命运

在 Java 继承体系中，最令人困惑的现象莫过于下面的代码：

```java
// 父类
class Father {
    int money = 100;
    void say() { System.out.println("我是爸爸"); }
}

// 子类
class Son extends Father {
    int money = 200; // 属性重名（遮蔽）
    @Override
    void say() { System.out.println("我是儿子"); } // 方法重写（覆盖）
}

public class Test {
    public static void main(String[] args) {
        // ⚠️ 关键点：引用类型是 Father，实际对象是 Son
        Father obj = new Son();
        
        System.out.println(obj.money); // 输出 100 (看引用类型)
        obj.say();                     // 输出 "我是儿子" (看实际对象)
    }
}

```

为什么访问属性 `money` 时，它无视了对象里的新值（200），非要拿旧值（100）？
而调用方法 `say()` 时，它又变得聪明了，知道去执行子类的逻辑？

根本原因在于：**属性访问是编译器的“独裁指令”（静态绑定），而方法调用是 JVM 的“运行时决策”（动态绑定）。**

---

## 🏛 第一部分：属性访问 —— 编译器的独裁 (Static Binding)

[可见java底层属性访问机制](3.5.6Java的属性访问机制.md)

### 1.1 定义与核心规则

**属性（Fields）访问是纯粹的编译器行为。**

* **规则**：**“看左边”**。即看变量声明时的 **引用类型 (Reference Type)**。
* **本质**：编译器在编译阶段，就已经把要访问的内存地址（偏移量）写死了。

### 1.2 底层原理：字节码中的“硬编码”

当你写下 `obj.money` 时，编译器（`javac`）是这样思考的：

1. **检查引用类型**：编译器看到 `obj` 的类型是 `Father`。
2. **查找定义**：编译器去 `Father` 类里找 `money` 属性。
3. **计算偏移量 (Offset)**：编译器根据 `Father` 类的内存布局，算出 `money` 位于对象头的后面，假设偏移量为 **12**。
4. **生成指令**：编译器生成字节码 `getfield`，并指明：“去读 `Father.money`”。

**生成的字节码 (javap -v)：**

```bytecode
// 这里的 #2 指向常量池中的 "Father.money"
getfield #2

```

### 1.3 运行时的“刻舟求剑”

当这段代码在 JVM 运行时：

1. **内存现状**：堆中的 `Son` 对象其实有两个 `money`。
* `Father.money` (值 100) 位于偏移量 12。
* `Son.money` (值 200) 位于偏移量 16。


2. **执行指令**：JVM 执行 `getfield`。
* 指令告诉 JVM：“去常量池 #2 看看”。
* 解析后发现是 `Father.money`，对应的**固定偏移量是 12**。


3. **结果**：JVM 闭着眼睛读取偏移量 12 的数据（100）。它根本不关心后面偏移量 16 处是不是还有一个 `Son.money`。

### 1.4 结论

* **不存在“多态”**：属性没有多态性。
* **就近原则（编译期）**：编译器只在“引用类型”（Father）里找最近的定义。找到了，就锁死那个位置。

---

## 🎭 第二部分：方法调用 —— JVM 的运行时民主 (Dynamic Binding)

[可见方法调用底层原理](3.5.4Java方法调用的底层原理.md)

### 2.1 定义与核心规则

**普通实例方法调用是编译器与 JVM 的合作行为。**

* **规则**：**“看右边”**。即看内存中 **实际对象的类型 (Actual Type)**。
* **本质**：编译器只负责“安检”，真正的目标地址由 JVM 在运行时通过 **虚方法表 (vtable)** 查找决定。

### 2.2 编译器的角色：只发“通行证”

当你写下 `obj.say()` 时，编译器做了什么？

1. **安检**：编译器检查 `Father` 类（引用类型）里有没有 `say()` 方法？
* 如果有，编译通过。
* 如果没有，报错（即使 `Son` 类里有也不行，因为编译器只看父类）。


2. **生成指令**：编译器生成 `invokevirtual` 指令。
* **关键点**：编译器**不敢**把 `say()` 的地址写死。
* 它生成的指令含义是：“JVM 兄弟，等会儿运行的时候，你帮我看看这个对象到底是谁，然后执行它自己的 `say` 方法。”



**生成的字节码：**

```bytecode
// 这里的 #3 是符号引用 "Father.say"，只是一个名字，不是物理地址
invokevirtual #3

```

### 2.3 运行时的“偷天换日”

当 JVM 执行 `invokevirtual` 时，魔法发生了：

1. **获取实际对象**：JVM 拿到 `obj` 指向的堆内存地址。
2. **查看身份证**：通过对象头（Header），JVM 发现这个对象是 **`Son` 类型**。
3. **查找虚方法表 (vtable)**：
* JVM 找到 `Son` 类的 vtable。
* 在表中查找 `say` 方法的入口。
* **发现重写**：由于 `Son` 重写了 `say`，vtable 里记录的地址是 **`Son.say` 的代码地址**（覆盖了父类的地址）。


4. **跳转执行**：JVM 跳转到 `Son.say` 的代码块执行。

### 2.4 特殊情况：方法何时会变成“静态绑定”？

并非所有方法都是动态绑定的。在以下 4 种情况下，编译器会认为“不可能发生重写”，从而直接锁死地址（像属性一样处理）：

1. **`static` 方法**：属于类，不属于对象。
2. **`private` 方法**：子类看不见，无法重写。
3. **`final` 方法**：明确禁止重写。
4. **`super.method()`**：显式调用父类，强制绕过动态查找。
* *注：构造器 `<init>` 也是静态绑定的。*



---

## 📝 终极总结：属性 vs 方法

为了方便记忆，我们可以将两者对比整理如下：

| 维度 | 属性 (Fields) | 方法 (Methods) |
| --- | --- | --- |
| **行为模式** | **静态绑定 (Static Binding)** | **动态绑定 (Dynamic Binding)** |
| **决策者** | **编译器 (Javac)** | **虚拟机 (JVM)** |
| **依据** | **引用类型** (左边 `Father obj`) | **实际对象** (右边 `new Son()`) |
| **底层机制** | **固定偏移量 (Fixed Offset)** | **虚方法表 (vtable Lookup)** |
| **处理重名时** | **遮蔽 (Shadowing)**<br><br>父子同时存在，看类型拿数据。 | **覆盖 (Overriding)**<br><br>父类逻辑被子类替换，只留一份逻辑。 |
| **执行指令** | `getfield` / `putfield` | `invokevirtual` (普通)<br><br>`invokespecial` (构造/私有/super) |

### 🚀 核心总结

> **静态绑定在类加载期就解析出了直接地址（或偏移量），类加载期进行字节码的符号引用替换，运行时直接使用；**
>
> **动态绑定在类加载期就把父子类的虚方法表（vtable）都填好了，并且字节码的符号引用发生了替换，在对象创建时才建立了对象与哪张表的联系，最终在执行指令时才去查表找到真正的代码地址。**
