**包**就是物理上实现低耦合、防止类名冲突的核心工具。没有包，大型项目的几千个类会变成一锅混乱的粥。

## 第1部分：建立认知（What & Why）

### 📦 1.1 核心语法 *💡 核心必学*

**目标**：理解包与文件系统的对应关系。

**基础定义**：

1. **物理上**：包就是操作系统的**文件夹**。
2. **逻辑上**：包是**命名空间 (Namespace)**，用于区分同名的类。

**语法铁律**：

* `package` 语句必须是文件的**第一行**非注释代码。
* 一个文件只能有一个 `package` 语句。

```java
// 声明包：说明当前类住在哪里
// 对应物理路径：src/com/myapp/order/OrderService.java
package com.myapp.order; 

// 引入包：说明我要借用别处的类
import java.util.List;
// import java.util.*; // ⚠️ 慎用通配符（稍后解释）

public class OrderService {
    // ...
}

```

**特殊概念：全限定名 (Fully Qualified Name)**
类的真实名字是 `包名 + 类名`。

* 你看到的：`String`
* JVM 看到的：`java.lang.String`

---

### 🚀 1.3 快速上手 *💡 核心必学*

**场景**：你需要在一个项目里同时处理 "用户端的订单" 和 "管理端的订单"。

如果没有包，你不能创建两个 `Order` 类。有了包，就可以共存。

**目录结构 (ASCII)**：

```text
src
 └─ com
     └─ shop
         ├─ client
         │   └─ Order.java  <-- 用户订单
         └─ admin
             └─ Order.java  <-- 管理员订单

```

**代码示例**：

```java
// 文件：src/com/shop/admin/Order.java
package com.shop.admin;

public class Order {
    public void audit() {
        System.out.println("管理员审核订单");
    }
}

```

```java
// 文件：src/com/shop/Main.java
package com.shop;

// 当需要同时使用两个同名类时，至少有一个需要用"全限定名"
import com.shop.client.Order; // 引入用户订单作为默认

public class Main {
    public static void main(String[] args) {
        // 1. 使用 import 的类
        Order clientOrder = new Order();
        
        // 2. 使用全限定名区分另一个同名类
        com.shop.admin.Order adminOrder = new com.shop.admin.Order();
    }
}

```

---

### 💡 1.4 它解决了什么问题 *💡 核心必学*

**核心痛点：命名冲突**

| 场景 | 没有包 (No Package) | 有包 (With Package) |
| --- | --- | --- |
| **同名类** | 无法创建两个 `User` 类 | `auth.User` vs `model.User` |
| **访问控制** | 只有 public 和 private | 多了 **包级私有 (Package-Private)**，允许同一包下的类互相访问，对包外隐藏 |
| **查找代码** | 几千个文件堆在一个目录下 | 按功能模块分类，类似图书馆索引 |

---

## 阶段2：工程实践（How to Do Right）

### 🔍 前置知识检查

**包级私有 (Package-Private)**：

* 如果在类、方法或变量前**不写任何修饰符**（即 default），它就只有**同一个包**内的类能访问。
* 这是实现"模块封装"的关键手段。

---

### ✅ 2.1 工程规范 *🔥 实战必备*

**🔴 RED（强制规范）：**

1. **反向域名命名法**：
* 必须使用公司/组织的域名倒写开头，防止全球冲突。
* ❌ `package myapp;`
* ✅ `package com.google.maps;` (域名 https://www.google.com/search?q=google.com)
* ✅ `package org.apache.commons;`


2. **全部小写**：
* 包名**严禁**使用大写字母、下划线。
* ❌ `package com.MyCompany.User_Module;`
* ✅ `package com.mycompany.usermodule;`


3. **禁止使用通配符导入**（IDEA 默认会折叠，但建议手动控制）：
* ❌ `import java.util.*;`
* ✅ `import java.util.List;`
* **理由**：如果 `java.util` 和 `java.awt` 都有 `List`，用了通配符后代码会报错，且看不清依赖关系。



**🟢 GREEN（推荐风格）：按功能分包 (Package by Feature)**

**传统做法：按层分包 (Package by Layer)**
*(这是 10 年前的老规矩，现在不推荐，因为违反低耦合)*

```text
com.myapp
  ├─ controller (放所有 Controller)
  ├─ service    (放所有 Service)
  └─ dao        (放所有 DAO)

```

* **缺点**：改一个"订单"功能，要在三个包之间跳来跳去。

**现代做法：按功能分包 (Package by Feature)**
*(符合高内聚、低耦合)*

```text
com.myapp
  ├─ order      (订单相关的一切：Service, Controller, DAO)
  ├─ user       (用户相关的一切)
  └─ payment    (支付相关的一切)

```

* **优点**：删除"订单"功能时，直接删 `order` 文件夹即可。利用 `package-private` 权限，可以把内部实现类隐藏在 `order` 包内，对外只暴露接口。

---

### 🌍 2.2 真实场景：利用包权限实现封装 *💡 核心必学*

**场景**：你写了一个工具库，里面有复杂的逻辑，但你只想让用户调用 `MainTool`，不想让用户看到底层的 `Helper` 类。

```java
package com.library.core;

// 1. 公开类：用户可以 import 和使用
public class StringUtil {
    public static void safePrint(String msg) {
        InternalHelper.log("Printing: " + msg); // 内部调用
        System.out.println(msg);
    }
}

// 2. 包级私有类 (无 public)：
// 用户在包外根本"看"不到这个类，无法 import，也无法 new
// 这就是工程化的"封装"——隐藏细节
class InternalHelper {
    static void log(String msg) {
        // 复杂的底层日志逻辑
    }
}

```

---

## 阶段3：避坑进阶（What to Avoid & Beyond）

### ⚠️ 3.1 常见陷阱合集 *🔥 实战必备*

#### 陷阱 1：默认包 (Default Package)

**错误代码**：

```java
// 第一行没有 package 语句
public class HelloWorld { ... }

```

**后果**：

* 这个类属于"默认包"。
* **致命问题**：其他包里的类**无法 import** 默认包里的类！
* 一旦项目变大，这个类就变成了孤岛，必须重构。

#### 陷阱 2：循环依赖 (Cyclic Dependency)

**现象**：

* 包 A 的类引入了 包 B
* 包 B 的类引入了 包 A

**ASCII 关系图**：

```text
[Package: order]  ----依赖---->  [Package: user]
       ^                            |
       |                            |
       +-----------依赖-------------+

```

**为什么是错的**：
这说明两个包紧密耦合在一起，无法单独拆分。如果我们要把 `order` 模块拆成微服务，会发现拆不掉，因为它死死抓着 `user`。

**修复方案**：
应用**依赖倒置**（上一节学的），引入第三个包放接口，或者合并这两个包。

---

### 🎓 3.3 实战挑战

**场景**：
你接手了一个遗留的电商系统，代码结构混乱。现在的结构是"按层分包"。

**要求**：

1. 重构代码结构，改为"按功能分包"。
2. 确保 `DiscountCalculator`（折扣计算器）只在 `order` 模块内部可见，不让外部乱调用（利用包级私有）。

**原始结构 (Refactoring Target)**：

```text
src/com/shop
  ├─ service
  │   ├─ OrderService.java
  │   └─ UserService.java
  └─ util
      └─ DiscountCalculator.java (public class)

```

**请你画出重构后的目录结构，并写出 `DiscountCalculator.java` 的关键定义（包名和类修饰符）。**

```java
/**
 * 请按以下格式回答：
 * * 1. 新的目录结构 (ASCII图)
 * 2. DiscountCalculator.java 的头几行代码
 */

```

📝 **提交你的方案，我来检查你是否掌握了"包"的精髓。**

```text
新结构：
src/com/shop 
  order
    OrderService.java(public class)
    DiscountCalculator.java (class)
  user
    UserService.java(public class)

DiscountCalculator.java的头几行代码：
package com.shop.order;
class DiscountCalculator
```
