既然都是继承，为什么 C++ 叫“多重继承”，而 Java 非要发明一个 `implements`？

因为 Java 把“继承”拆解成了两个完全不同的**物理过程**：

#### 🅰️ Extends = “实现”继承 (Implementation Inheritance)

* **继承了什么？** 继承了**“血肉”**（成员变量）和**“基因”**（具体代码逻辑）。
* **物理后果**：这是一种**“强耦合”**。
* **内存布局**：子类对象在内存里，是直接**包含**父类的字段的。父类加一个字段，子类对象就变胖。
* **代码复用**：直接拿来用。

#### 🅱️ Implements = “类型”继承 (Type Inheritance / Interface Inheritance)

* **继承了什么？** 仅仅继承了**“签名”**（方法名、参数、返回值）和**“身份”**。
* **物理后果**：这是一种**“契约”**。
* **内存布局**：接口里没有实例变量，所以实现接口**不影响**对象的内存结构（字段布局）。
* **代码复用**：默认没有（Java 8 前），纯粹是为了通过编译器的类型检查。

---

### 🔬 深度图解：内存里的区别

**1. Extends (类继承) 的对象内存：**

* `Dog extends Animal` (Animal 有 `age`, Dog 有 `name`)
* 当我们 `new Dog()` 时：

```text
[ Dog 对象头 ]
[ age  (来自 Animal) ] <--- 强行塞进来的，不想继承都不行 (这就是强耦合)
[ name (Dog 自己的) ]

```

**2. Implements (接口继承) 的对象内存：**

* `Dog implements Runnable`
* 当我们 `new Dog()` 时：

```text
[ Dog 对象头 ]
[ age  (来自 Animal) ]
[ name (Dog 自己的) ]
... (也就是没有任何 Runnable 的字段，因为接口没有实例变量)

```

* **仅仅是打了一个标签**：JVM 方法表里记录了“这个类实现了 Runnable”，允许你把它当 Runnable 用，但它没有给对象增加任何数据负担。

、