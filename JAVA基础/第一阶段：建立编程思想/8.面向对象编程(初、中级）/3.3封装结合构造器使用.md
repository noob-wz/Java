**如果构造器里直接赋值（`this.age = age`），而 Setter 里写了校验逻辑，那么构造器确实就是一条“走私通道”，完美绕过了安检！**

这就好比：大门（Setter）有保安检查，但你通过 VIP 电梯（构造器）直接带人上楼，保安就成了摆设。

---

### 💡 核心解决方案：构造器也要“过安检”

解决这个问题的方案非常简单，遵循一条**大厂铁律**：

> **SOP（标准作业程序）：构造器不应该直接接触核心数据，而应该复用 Setter 的逻辑。**

不要在构造器里写赋值代码，而是**在构造器里调用 Setter 方法**。

---

### 🔬 1. 错误示范 (漏洞现场)

这是你担心的场景，也是**反面教材**：

```java
public class Person {
    private int age;

    // 🛡️ Setter 有安检
    public void setAge(int age) {
        if (age < 0 || age > 120) {
            System.out.println("❌ 非法年龄");
            return;
        }
        this.age = age;
    }

    // 🚧 构造器：直接“走私”，绕过了安检！
    public Person(int age) {
        this.age = age; // 😱 完了！这里没有校验！
    }
}

// 💥 结果：
Person p = new Person(-1000); // 创建成功，封装失败

```

---

### ✅ 2. 正确示范 (闭环保护)

**让构造器也走正规流程**。

```java
public class Person {
    private int age;

    // 1. 定义统一的安检逻辑 (Setter)
    public void setAge(int age) {
        if (age < 0 || age > 120) {
            // 大厂通常抛出异常，阻止对象创建
            throw new IllegalArgumentException("❌ 年龄必须在 0-120 之间");
        }
        this.age = age;
    }

    // 2. 构造器：委托给 Setter
    public Person(int age) {
        // ✅ 不要直接赋值，而是调用 setAge
        // 这样，无论是 new 还是 set，都必须经过同一个关卡
        this.setAge(age); 
    }
}

// ✨ 结果：
Person p = new Person(-1000); // 💥 抛出异常，对象创建失败！安全！

```

**📊 ASCII 流程图解**

```text
       [ 外部数据: -100 ]
              |
              v
    +--- 构造器 Person() ---+
    |  (不再直接赋值)       |
    |  调用 setAge(-100)    |
    +---------+-------------+
              |
              v
    +--- setAge() 安检口 ---+
    |  if (-100 < 0) ...    | ---> 🚨 报警！拦截！
    +-----------------------+
              |
         (永远到不了这里)
              v
       [ 🔒 核心数据 age ]

```

---

### 🚀 3. 进阶：如果连 Setter 都没有怎么办？

在大厂的高并发编程中，我们经常设计 **不可变对象 (Immutable Object)**。
这种对象的属性是 `final` 的（一旦赋值，终生不变），所以**根本就没有 Setter 方法**。

这时候怎么校验？

**答案：把校验逻辑直接写在构造器里。**

```java
public class ImmutablePerson {
    // final 变量，必须在构造器初始化，且之后不能改
    private final int age; 

    public ImmutablePerson(int age) {
        // 🛡️ 在赋值前，先校验！
        if (age < 0 || age > 120) {
            throw new IllegalArgumentException("年龄非法");
        }
        // ✅ 校验通过才赋值
        this.age = age;
    }
}

```

---

### 📝 总结

1. **普通对象（有 Setter）**：构造器内 **调用 Setter**，不要直接赋值。
2. **不可变对象（无 Setter）**：构造器内 **先校验，再赋值**。

**结论**：**封装**不是仅仅把变量藏起来，而是要保证**任何时候、任何入口（无论是 set 还是 new）**，进入对象的数据都是合法的。

---

这个问题的本质其实触及到了 **“数据一致性”** 的核心。
