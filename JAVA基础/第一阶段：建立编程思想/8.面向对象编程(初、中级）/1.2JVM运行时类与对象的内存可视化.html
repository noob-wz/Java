<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JVM 对象创建全流程可视化 (Pro Ver.)</title>
    <style>
        :root {
            /* 配色方案：VS Code Dark 风格 */
            --bg: #1e1e1e;
            --panel: #252526;
            --border: #3e3e42;
            --text-main: #d4d4d4;
            --text-muted: #858585;

            /* 语义色 */
            --stack-color: #f14c4c; /* 栈：红 */
            --heap-color: #23d18b;  /* 堆：绿 */
            --meta-color: #cca700;  /* 方法区：黄 */
            --accent: #007acc;      /* UI交互：蓝 */
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Consolas', 'Monaco', monospace;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* === 顶部导航栏 === */
        .toolbar {
            height: 50px;
            background: #333;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 10;
        }

        h3 { margin: 0; font-size: 1.1rem; letter-spacing: 1px; }

        .btn {
            background: var(--accent);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            padding: 6px 16px;
            cursor: pointer;
            border-radius: 2px;
            font-family: inherit;
            transition: all 0.2s;
        }
        .btn:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-1px); }
        .btn:disabled { background: #444; cursor: not-allowed; opacity: 0.5; }

        .progress-container {
            flex: 1;
            height: 6px;
            background: #111;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* === 图例说明 === */
        .legend {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            margin-right: 20px;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; }

        /* === 主舞台 === */
        .stage {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 15px;
            overflow: hidden;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            position: relative;
            transition: box-shadow 0.3s;
        }

        /* 区域边框高亮 */
        .panel.stack-area { border-top: 3px solid var(--stack-color); width: 220px; }
        .panel.heap-area { border-top: 3px solid var(--heap-color); flex: 1; }
        .panel.method-area { border-top: 3px solid var(--meta-color); width: 280px; }
        .panel.code-area { border-top: 3px solid #ccc; width: 300px; }

        .panel-header {
            padding: 10px;
            background: rgba(0,0,0,0.2);
            font-size: 0.9rem;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
        }

        /* === 代码视图 === */
        .code-content { padding: 15px; font-size: 13px; line-height: 1.8; }
        .line { padding: 0 8px; border-left: 3px solid transparent; transition: background 0.2s; }
        .line.active { background: #264f78; border-left-color: white; }

        /* 语法高亮 */
        .kw { color: #569cd6; font-weight: bold; } /* public, class */
        .type { color: #4ec9b0; } /* int, Player */
        .num { color: #b5cea8; } /* 1001 */
        .comment { color: #6a9955; }

        /* === 内存格子 === */
        .memory-grid { padding: 20px; display: flex; flex-direction: column; gap: 4px; }

        .byte-row {
            display: flex;
            align-items: center;
            height: 32px;
            opacity: 0.3; /* 未分配时半透明 */
            transition: opacity 0.5s;
        }
        .byte-row.allocated { opacity: 1; }

        .addr-label {
            width: 70px;
            color: var(--text-muted);
            font-size: 0.8rem;
            text-align: right;
            padding-right: 12px;
            border-right: 1px solid #444;
        }

        .data-cells { display: flex; gap: 4px; padding-left: 12px; flex: 1; }

        .byte {
            width: 32px; height: 26px;
            line-height: 26px;
            text-align: center;
            background: #181818;
            border: 1px solid #333;
            font-size: 0.8rem;
            color: #777;
            border-radius: 2px;
            transition: all 0.3s;
        }

        /* 内存类型着色 */
        .byte.header { border-color: var(--meta-color); color: var(--meta-color); }
        .byte.data { border-color: var(--heap-color); color: var(--heap-color); }
        .byte.padding { border-color: #444; color: #444; background: repeating-linear-gradient(45deg, #222, #222 5px, #2a2a2a 5px, #2a2a2a 10px); }

        /* 动画状态 */
        .byte.flash { background: #fff !important; color: #000 !important; transform: scale(1.1); }
        .byte.zero-init { animation: fadeIn 0.5s forwards; }

        /* === 栈帧 === */
        .stack-frame {
            margin: 15px;
            background: rgba(241, 76, 76, 0.1);
            border: 1px solid var(--stack-color);
            padding: 10px;
            position: relative;
        }
        .stack-frame::before {
            content: "Main 栈帧";
            position: absolute;
            top: -10px; left: 10px;
            background: var(--stack-color);
            color: #fff;
            padding: 0 6px;
            font-size: 0.75rem;
        }
        .stack-var {
            display: flex; justify-content: space-between;
            border-bottom: 1px dashed #555;
            padding: 5px 0;
            font-size: 0.9rem;
        }

        /* === 飞行粒子 === */
        .flyer {
            position: fixed;
            background: gold;
            color: black;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px gold;
        }

        /* === 底部信息栏 === */
        .info-bar {
            padding: 10px 20px;
            background: #2d2d30;
            border-top: 1px solid var(--border);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
        }
        .step-badge {
            background: var(--accent);
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            margin-right: 10px;
            font-weight: bold;
            font-size: 0.8rem;
        }

    </style>
</head>

<body>

<div class="toolbar">
    <h3>JVM 内存可视化 <span style="font-size:0.8rem; color:#888; font-weight:normal;">对象创建全流程</span></h3>

    <div class="progress-container">
        <div class="progress-fill" id="progress"></div>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="dot" style="background:var(--stack-color)"></div>栈 (Stack)</div>
        <div class="legend-item"><div class="dot" style="background:var(--heap-color)"></div>堆 (Heap)</div>
        <div class="legend-item"><div class="dot" style="background:var(--meta-color)"></div>方法区 (Meta)</div>
    </div>

    <div style="display:flex; gap:10px;">
        <button class="btn" id="btnPrev" disabled>⏮ 上一步</button>
        <button class="btn" id="btnNext">下一步 ⏭</button>
    </div>
</div>

<div class="stage">
    <div class="panel code-area">
        <div class="panel-header">源代码 (Source)</div>
        <div class="code-content" id="codeBox">
        </div>
    </div>

    <div class="panel stack-area">
        <div class="panel-header">栈内存 (Stack)</div>
        <div id="stackContent" style="padding:10px;">
            <div style="text-align:center; color:#666; margin-top:50px;">空闲 (Empty)</div>
        </div>
    </div>

    <div class="panel heap-area">
        <div class="panel-header">
            堆内存 (Heap)
            <span id="heapAddrLabel" style="color:gold; font-family:monospace; opacity:0;">Start: 0x4000</span>
        </div>
        <div class="memory-grid" id="heapContent">
        </div>
    </div>

    <div class="panel method-area">
        <div class="panel-header">方法区 (Metaspace)</div>
        <div style="padding:15px; color:var(--text-muted); font-size:0.85rem;">
            <div id="classMeta" style="border:1px dashed var(--meta-color); padding:10px; opacity:0.3; transition:opacity 0.5s;">
                <div style="color:var(--meta-color); font-weight:bold; margin-bottom:5px;">Player.class</div>
                <div>字段表: id(int), level(byte)</div>
                <div>方法表: &lt;init&gt;, main</div>
            </div>
        </div>
    </div>
</div>

<div class="info-bar">
    <span class="step-badge" id="stepNum">READY</span>
    <span id="stepDesc">点击“下一步”开始 JVM 内存演示...</span>
</div>

<script>
    // === 核心配置 ===
    const HEAP_START = "0x4000";
    const STACK_VAR_ID = "p1_val";

    // 源代码配置
    const codeLines = [
        { text: "public class Player {", type: "def" },
        { text: "    int id;      // 4 bytes", type: "def" },
        { text: "    byte level;  // 1 byte", type: "def" },
        { text: "}", type: "def" },
        { text: "", type: "empty" },
        { text: "public static void main(String[] args) {", type: "method" },
        { text: "    Player p1;", type: "stmt" },
        { text: "    p1 = new Player();", type: "stmt" },
        { text: "    p1.id = 1001;", type: "stmt" },
        { text: "    p1.level = 5;", type: "stmt" },
        { text: "}", type: "method" }
    ];

    // 内存布局：JVM 64位, 开启指针压缩
    // MarkWord(8) + ClassPtr(4) + int(4) + byte(1) + padding(7) = 24 bytes
    const memoryLayout = [
        { off: 0, size: 8, type: 'header', val: '--', desc: 'Mark Word' },
        { off: 8, size: 4, type: 'header', val: '--', desc: 'Class Ptr' },
        { off: 12, size: 4, type: 'data', val: '--', desc: 'id (int)' },
        { off: 16, size: 1, type: 'data', val: '--', desc: 'level' },
        { off: 17, size: 7, type: 'padding', val: '--', desc: 'Padding' }
    ];

    // === 状态机定义 ===
    // 关键逻辑：Alloc -> Zero -> Header -> Assign
    const steps = [
        {
            name: "启动 Main",
            desc: "Main 线程启动，JVM 压入栈帧 (Stack Frame)。",
            line: 5,
            action: () => renderStack(true),
            undo: () => renderStack(false)
        },
        {
            name: "变量声明",
            desc: "在栈帧局部变量表中分配引用变量 p1 (默认 null)。",
            line: 6,
            action: () => renderStackVar("p1", "null"),
            undo: () => renderStack(true) // 重置回仅有栈帧
        },
        {
            name: "类加载检查",
            desc: "遇到 new 指令，检查 Player 类是否加载。JVM 读取方法区元数据。",
            line: 7,
            action: () => document.getElementById('classMeta').style.opacity = 1,
            undo: () => document.getElementById('classMeta').style.opacity = 0.3
        },
        {
            name: "内存分配 & 零值初始化",
            desc: "【关键】在堆中开辟 24 字节，并立即将所有内存重置为 00 (零值初始化)。",
            line: 7,
            action: () => {
                document.getElementById('heapAddrLabel').style.opacity = 1;
                toggleHeapAllocated(true);
                // 模拟 TLAB/堆 的清零操作，此时全是 00
                writeBytes(0, 24, "00", false);
                flashRange(0, 24); // 视觉闪烁
            },
            undo: () => {
                document.getElementById('heapAddrLabel').style.opacity = 0;
                toggleHeapAllocated(false);
                writeBytes(0, 24, "--", false); // 变回未分配
            }
        },
        {
            name: "设置对象头",
            desc: "JVM 写入对象头信息：Mark Word (哈希/锁状态) + 类指针 (指向方法区)。",
            line: 7,
            action: () => {
                // Mark Word (偏向锁位等，模拟值)
                writeBytes(0, 8, ["01","00","00","00","00","00","00","00"], true);
                // Class Ptr (压缩指针，指向 Player.class)
                writeBytes(8, 4, ["F8","00","C0","10"], true);
            },
            undo: () => {
                // 回退到零值
                writeBytes(0, 12, "00", false);
            }
        },
        {
            name: "引用赋值",
            desc: "对象初始化完成。将堆地址 (0x4000) 赋值给栈变量 p1。",
            line: 7,
            action: () => {
                const startEl = document.getElementById('heapAddrLabel');
                const endEl = document.getElementById(STACK_VAR_ID);
                if(endEl) {
                    endEl.innerText = HEAP_START;
                    endEl.style.color = "gold";
                    animateFly(startEl, endEl, HEAP_START);
                }
            },
            undo: () => {
                renderStackVar("p1", "null");
            }
        },
        {
            name: "赋值 id",
            desc: "执行 p1.id = 1001 (0x3E9)。通过对象基地址 + 偏移量(12) 写入数据。",
            line: 8,
            action: () => writeBytes(12, 4, ["00","00","03","E9"], true),
            undo: () => writeBytes(12, 4, "00", false)
        },
        {
            name: "赋值 level",
            desc: "执行 p1.level = 5。通过对象基地址 + 偏移量(16) 写入数据。",
            line: 9,
            action: () => writeBytes(16, 1, ["05"], true),
            undo: () => writeBytes(16, 1, "00", false)
        }
    ];

    // === 初始化逻辑 ===
    let currentStep = -1;

    function init() {
        // 渲染代码
        const codeBox = document.getElementById('codeBox');
        codeLines.forEach((l, i) => {
            const div = document.createElement('div');
            div.className = `line`;
            div.id = `line-${i}`;
            // 简单正则高亮
            let html = l.text
                .replace(/(public|class|static|void|new)/g, '<span class="kw">$1</span>')
                .replace(/\b(int|byte|Player|String)\b/g, '<span class="type">$1</span>')
                .replace(/\b(\d+)\b/g, '<span class="num">$1</span>')
                .replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
            div.innerHTML = html || '&nbsp;';
            codeBox.appendChild(div);
        });

        // 渲染堆内存网格
        const heapBox = document.getElementById('heapContent');
        memoryLayout.forEach(block => {
            const row = document.createElement('div');
            row.className = 'byte-row';

            // 地址列
            const addr = document.createElement('div');
            addr.className = 'addr-label';
            addr.innerText = `+${block.off}`;
            row.appendChild(addr);

            // 数据格子
            const cells = document.createElement('div');
            cells.className = 'data-cells';
            for(let i=0; i<block.size; i++) {
                const b = document.createElement('div');
                b.className = `byte ${block.type}`;
                b.id = `mem-${block.off + i}`;
                b.innerText = '--';
                cells.appendChild(b);
            }
            row.appendChild(cells);

            // 描述
            const desc = document.createElement('div');
            desc.style.fontSize = '0.8rem';
            desc.style.color = '#666';
            desc.innerText = block.desc;
            row.appendChild(desc);

            heapBox.appendChild(row);
        });
    }

    // === 动作引擎 ===

    function renderStack(showFrame) {
        const container = document.getElementById('stackContent');
        if(!showFrame) {
            container.innerHTML = '<div style="text-align:center; color:#666; margin-top:50px;">空闲 (Empty)</div>';
            return;
        }
        container.innerHTML = `
            <div class="stack-frame">
                <div id="stackVarsArea"></div>
            </div>
        `;
    }

    function renderStackVar(name, val) {
        const area = document.getElementById('stackVarsArea');
        if(!area) return; // 容错
        area.innerHTML = `
            <div class="stack-var">
                <span class="type">${name}</span>
                <span id="${STACK_VAR_ID}" style="color:#aaa">${val}</span>
            </div>
        `;
    }

    function toggleHeapAllocated(isAllocated) {
        const rows = document.querySelectorAll('.byte-row');
        rows.forEach(r => {
            if(isAllocated) r.classList.add('allocated');
            else r.classList.remove('allocated');
        });
    }

    // 写入内存辅助函数：支持单个值填充或数组填充
    function writeBytes(startOff, len, data, animate) {
        for(let i=0; i<len; i++) {
            const el = document.getElementById(`mem-${startOff + i}`);
            const val = Array.isArray(data) ? data[i] : data;
            el.innerText = val;

            if(animate) {
                el.classList.add('flash');
                setTimeout(() => el.classList.remove('flash'), 300);
            }
        }
    }

    function flashRange(startOff, len) {
        for(let i=0; i<len; i++) {
            const el = document.getElementById(`mem-${startOff + i}`);
            el.style.backgroundColor = 'var(--heap-color)';
            el.style.color = '#000';
            setTimeout(() => {
                el.style.backgroundColor = '';
                el.style.color = '';
            }, 400);
        }
    }

    function animateFly(startEl, endEl, text) {
        const rect1 = startEl.getBoundingClientRect();
        const rect2 = endEl.getBoundingClientRect();

        const fly = document.createElement('div');
        fly.className = 'flyer';
        fly.innerText = text;
        fly.style.left = (rect1.left + 20) + 'px';
        fly.style.top = rect1.top + 'px';

        document.body.appendChild(fly);

        // 强制重绘
        fly.getBoundingClientRect();

        fly.style.transition = 'all 0.8s cubic-bezier(0.22, 1, 0.36, 1)';
        fly.style.left = rect2.left + 'px';
        fly.style.top = rect2.top + 'px';

        setTimeout(() => fly.remove(), 800);
    }

    // === 流程控制 ===
    const btnNext = document.getElementById('btnNext');
    const btnPrev = document.getElementById('btnPrev');
    const uiStepNum = document.getElementById('stepNum');
    const uiStepDesc = document.getElementById('stepDesc');
    const uiProgress = document.getElementById('progress');

    function updateUI() {
        // 按钮状态
        btnPrev.disabled = currentStep < 0;
        btnNext.disabled = currentStep >= steps.length - 1;

        // 进度条
        const pct = ((currentStep + 1) / steps.length) * 100;
        uiProgress.style.width = `${pct}%`;

        // 文本信息
        if(currentStep >= 0) {
            const s = steps[currentStep];
            uiStepNum.innerText = `STEP ${currentStep + 1}`;
            uiStepDesc.innerText = s.desc;

            // 代码高亮
            document.querySelectorAll('.line').forEach(l => l.classList.remove('active'));
            if(s.line !== undefined) {
                document.getElementById(`line-${s.line}`).classList.add('active');
            }
        } else {
            uiStepNum.innerText = "READY";
            uiStepDesc.innerText = "点击“下一步”开始演示";
            document.querySelectorAll('.line').forEach(l => l.classList.remove('active'));
        }
    }

    btnNext.addEventListener('click', () => {
        if(currentStep < steps.length - 1) {
            currentStep++;
            steps[currentStep].action();
            updateUI();
        }
    });

    btnPrev.addEventListener('click', () => {
        if(currentStep >= 0) {
            steps[currentStep].undo();
            currentStep--;

            // 回退逻辑需要特殊处理：UI状态要显示"上一步"的状态
            // 简单做法：不做额外操作，updateUI 会根据新的 currentStep 刷新文字
            // 但如果上一步有高亮，需要重新触发吗？
            // 因为我们的 undo 只是撤销数据，不负责恢复上一步的高亮状态，updateUI 负责恢复高亮
            updateUI();
        }
    });

    // 启动
    init();

</script>
</body>
</html>