# 🎯 JVM方法调用完整流程（精简版）

## 示例代码

```java
class Father {
    public void method() { ... }
    public void method(int i) { ... }  // ← 重点关注这个
}

class Son extends Father {
    @Override
    public void method() { ... }  // 只重写了无参版本
    // ❌ 没有重写 method(int)
}

// 测试
Father f = new Son();
f.method(10);  // 输出什么？
```

---

## 完整流程三阶段

### 1️⃣ 编译期：确定方法签名

```
输入：f.method(10)

处理：
  - 确定f的静态类型是Father
  - 参数是int
  - 重载解析 → 选择 Father.method(int)
  - 确定vtable索引6
```

**根据静态类型生成字节码：** `invokevirtual #4 <Father.method:(I)V>`
（符号引用，稍后解析为vtable索引6）

### 2️⃣ 类加载期：构建vtable

```
Father类加载：
  vtable[6] = Father.method(int) @ 0x1234F002

Son类加载：
  复制父类vtable → 检查重写
  vtable[5] = Son.method() @ 0x5678S001     ← 重写了，替换
  vtable[6] = Father.method(int) @ 0x1234F002  ← 没重写，保留
```

在**类加载期**，**JVM 基于变量的静态类型，将字节码中的符号引用解析并缓存为固定的虚方法表索引**。

> **此时索引是确定的，根据变量的静态类型找到对应类的方法，确定索引**，所以此时找到的索引是父类还是子类就看此时这个变量本身属于什么


### 3️⃣ 运行期：动态分派（机械查表）

```
执行 f.method(10)

机械流程（无判断）：
  ① 取f的值 → 0x7A2B3C4D（堆地址）
  ② 找对象 → 读对象头
  ③ 类型指针 → Son类元数据
  ④ 找vtable → Son.vtable
  ⑤ 查索引6 → Son.vtable[6] = 0x1234F002
  ⑥ 跳转执行 → Father.method(int)

输出：Father.method(int): 10
```

在**运行期**，invokevirtual 指令**通过栈顶的接收者对象获取其实际类元数据，利用预先确定的索引查表，获取该位置上的实际机器码地址**，从而执行子类重写后的逻辑。

> 此时运行要执行字节码指令，**需要找到堆对应的实际虚方法表，然后通过索引直接找到地址即可**


---

## 💡 一句话总结

**多态不是JVM运行时的"判断替换"，而是vtable结构的自然结果：**
- **编译期确定调用哪个方法签名**，生成带符号引用的字节码
- **类加载时不管是否重写，根据变量的静态类型在vtable找到索引，并把索引替换掉符号引用**
- **运行时找到实际堆的对象头指向的元数据空间，机械地根据索引查表，索引对应什么地址就执行什么地址**
