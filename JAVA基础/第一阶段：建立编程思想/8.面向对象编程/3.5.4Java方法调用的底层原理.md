# 🎯 JVM方法调用完整流程（精简版）

## 示例代码

```java
class Father {
    public void method() { ... }
    public void method(int i) { ... }  // ← 重点关注这个
}

class Son extends Father {
    @Override
    public void method() { ... }  // 只重写了无参版本
    // ❌ 没有重写 method(int)
}

// 测试
Father f = new Son();
f.method(10);  // 输出什么？
```

---

## 完整流程三阶段

### 1️⃣ 编译期：确定方法签名

```
输入：f.method(10)

处理：
  - f的静态类型是Father
  - 参数是int
  - 重载解析 → 选择 Father.method(int)
  - 确定vtable索引6

输出：invokevirtual #4 <Father.method:(I)V>
     （符号引用，稍后解析为vtable索引6）
```

### 2️⃣ 类加载期：构建vtable

```
Father类加载：
  vtable[6] = Father.method(int) @ 0x1234F002

Son类加载：
  复制父类vtable → 检查重写
  vtable[5] = Son.method() @ 0x5678S001     ← 重写了，替换
  vtable[6] = Father.method(int) @ 0x1234F002  ← 没重写，保留
```

### 3️⃣ 运行期：动态分派（机械查表）

```
执行 f.method(10)

机械流程（无判断）：
  ① 取f的值 → 0x7A2B3C4D（堆地址）
  ② 找对象 → 读对象头
  ③ 类型指针 → Son类元数据
  ④ 找vtable → Son.vtable
  ⑤ 查索引6 → Son.vtable[6] = 0x1234F002
  ⑥ 跳转执行 → Father.method(int)

输出：Father.method(int): 10
```

---

## 🔑 解答你的核心疑惑

### 疑惑1：JVM怎么知道要"替换"成Son的方法？

**答案：JVM根本不知道，也不需要知道！**

```
JVM不会判断：
  ❌ "哦这是Son对象，我要换成Son的方法"
  ❌ "编译期是Father，运行时要改"

JVM只是机械执行：
  ✅ 查 对象实际类型.vtable[编译期确定的索引]
  ✅ 跳转到查到的地址
```

### 疑惑2：编译器需要的只是方法签名？

**完全正确！**

```
编译器的职责：
  ✓ 确定方法签名：Father.method(int)
  ✓ 确定vtable索引：6
  ✗ 不关心最终执行谁的实现

JVM的职责：
  ✓ 查表：对象类型.vtable[索引]
  ✓ 执行查到的地址
```

### 疑惑3：常量池的#4和vtable索引的关系？

```
编译期：
  生成 invokevirtual #4
  #4 → 常量池条目 → "Father.method:(I)V"（只是个名字）

类加载期：
  符号引用解析：
  "Father.method:(I)V" → 确定为 vtable索引6

运行期：
  直接使用索引6查表
```

---

## 📊 核心图解

```
编译期              类加载期                运行期
────────           ────────               ────────
方法签名            vtable结构              机械查表
Father.method(int) Son.vtable[6]          查索引6
    ↓                  ↓                      ↓
vtable索引6        = Father地址           跳转执行
                   (因为Son没重写)
```

---

## 💡 一句话总结

**多态不是JVM运行时的"判断替换"，而是vtable结构的自然结果：**
- 编译器确定索引
- 类加载时根据是否重写，在vtable对应索引填入地址
- 运行时机械查表，查到什么执行什么

**没有任何"if判断"逻辑！**