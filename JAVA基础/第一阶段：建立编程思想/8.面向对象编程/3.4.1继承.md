现在，假设你已经写好了一个完美的 `Wallet` 类。老板突然跑过来说："我们需要一个信用卡功能，和钱包差不多，但可以透支。"

你可能会想："我是不是要把 `Wallet` 的代码复制一份，改名为 `CreditWallet`，然后改改逻辑？"

✋ **打住！** 复制粘贴是万恶之源。面向对象的第二大支柱——**「继承 (Inheritance)」**，就是为了解决代码复用和扩展的问题。

──────────────────────────────────

## 第1部分：建立认知（What & Why）

### 📦 1.1 核心语法 *💡 核心必学*

**目标**：理解如何让一个类“继承”另一个类的属性和行为。

**基础语法结构**：
Java 使用 `extends` 关键字实现继承。

* **父类 (Parent/Super Class)**：被继承的类。
* **子类 (Child/Sub Class)**：继承者，拥有父类的非私有成员，并可扩展新功能。

```java
// 父类：通用定义
public class Animal {
    // 成员变量
    protected String name; // protected: 允许子类访问，拒绝外部访问

    // 方法
    public void eat() {
        System.out.println(name + " 正在进食...");
    }
}

// 子类：扩展定义
// 语法：class 子类 extends 父类
public class Dog extends Animal {
    // 子类自动拥有 name 和 eat()

    // 子类特有的方法
    public void bark() {
        System.out.println(name + " 汪汪叫！");
    }
}

```

**语法铁律**：

1. **单继承**：一个类只能有一个直接父类（`extends A, B` 是非法的）。
2. **构造器不继承**：子类不能继承父类的构造器，但必须调用它（详见1.2）。

---

### 🔗 1.2 关联概念 *💡 核心必学*

**目标**：理解继承背后的隐式规则和关键字。

#### 1. `super` 关键字

在子类中，`super` 代表“父类的引用”。

* `super.field` / `super.method()`：访问父类成员。
* `super()`：调用父类构造器。

#### 2. 编译器的隐式行为（构造器调用链）

这是初学者最容易晕的地方：**创建子类对象时，必须先初始化父类。**

* **规则**：子类构造器的第一行代码，默认必须是 `super()`。
* **如果不写**：编译器会自动帮你插入 `super()`（调用父类无参构造器）。
* **如果父类没有无参构造器**：你必须手动写出 `super(参数)`，否则编译报错。

```java
public class Parent {
    public Parent() {
        System.out.println("1. 父类初始化");
    }
}

public class Child extends Parent {
    public Child() {
        // 隐式代码：super();  <-- 编译器自动插入这行
        System.out.println("2. 子类初始化");
    }
}

```

#### 3. 方法重写 (`@Override`)

子类可以重新定义父类的行为。

* 必须使用 `@Override` 注解（编译器会帮你检查签名是否正确）。

---

### 🚀 1.3 快速上手 *💡 核心必学*

**目标**：跑通一个完整的继承示例。

```java
// 1. 定义父类：电子产品
class Electronic {
    protected String brand; // 品牌

    // 父类构造器
    public Electronic(String brand) {
        this.brand = brand;
    }

    public void powerOn() {
        System.out.println("⚡ " + brand + " 设备已启动");
    }
}

// 2. 定义子类：手机
class Phone extends Electronic {
    // 子类构造器
    public Phone(String brand) {
        // 必须第一行调用父类构造器（因为父类没有无参构造器）
        super(brand); 
    }

    // 重写父类方法
    @Override
    public void powerOn() {
        super.powerOn(); // 保留父类原有逻辑
        System.out.println("📱 屏幕亮起，正在搜索信号...");
    }
    
    // 子类独有方法
    public void call(String number) {
        System.out.println("📞 正在呼叫 " + number);
    }
}

// 3. 运行测试
public class Main {
    public static void main(String[] args) {
        // 创建子类对象
        Phone myPhone = new Phone("Apple");
        
        // 调用重写后的方法
        myPhone.powerOn(); 
        // 结果：
        // ⚡ Apple 设备已启动
        // 📱 屏幕亮起，正在搜索信号...

        // 调用子类独有方法
        myPhone.call("10086");
    }
}

```

---

### 💡 1.4 它解决了什么问题 *💡 核心必学*

**历史背景**：
在没有继承之前，如果我们有 `Cat`（猫）和 `Dog`（狗），它们都有 `name`、`age` 和 `eat()` 方法。程序员必须在两个类里写两遍完全相同的代码。

**对比差异**：

| 维度 | 没有继承 (Copy-Paste) | 使用继承 (Inheritance) |
| --- | --- | --- |
| **代码量** | 重复代码多，臃肿 | 提取公共代码到父类，简洁 |
| **可维护性** | 修改 `eat()` 逻辑需要改 N 个文件 | 只需修改父类 `Animal` 一处 |
| **逻辑关系** | 只有零散的类 | 建立了“Is-A”（是一个）的关系 |

**设计收益**：

* **DRY 原则 (Don't Repeat Yourself)**：拒绝重复代码。
* **多态的基础**：没有继承，就没有多态（后续会学）。

---

### ⚙️ 1.5 底层原理 *⭐ 进阶选学*

**目标**：理解 `new Child()` 时，内存里到底发生了什么。

很多人误以为 `Child` 对象里包含了一个独立的 `Parent` 对象。**这是错误的！**

**真相**：
堆内存中**只有一个对象**。这个对象内部划分了不同区域，分别存储父类定义的字段和子类定义的字段。

**内存布局 ASCII 图**：

```
Thread Stack (栈)            Heap Memory (堆) - new Child()
+----------------+          +-------------------------------------+
| myPhone (ref)  |--------->| 0x999 (Phone 对象实例)               |
+----------------+          |-------------------------------------|
                            | [Header] 对象头                      |
                            |-------------------------------------|
                            | [父类区域 - Electronic]              |
                            |  brand: "Apple"                     |
                            |-------------------------------------|
                            | [子类区域 - Phone]                   |
                            |  (如果Phone有自定义字段则存在这里)     |
                            |-------------------------------------|
                            +-------------------------------------+

```

**执行流程**：

1. **类加载**：JVM 先加载 `Electronic.class`，再加载 `Phone.class`。
2. **内存分配**：在堆中开辟一块空间，大小 = 父类字段 + 子类字段 + 对象头。
3. **父类初始化**：执行 `super(brand)`，初始化 `[父类区域]` 的数据。
4. **子类初始化**：执行子类构造器余下代码，初始化 `[子类区域]`。

**关键结论**：`super` 并不是指向另一个对象的引用，它只是在这个**同一个对象**中，去操作属于父类定义的那部分数据或方法的“视图”。

---

## 第2部分：工程实践（How to Do Right）

在第一部分我们掌握了“怎么写继承”，现在我们要学习“怎么**正确地**写继承”。

在业界，继承是一把双刃剑。用好了能极大地简化代码，用不好会制造出“脆落的基类”（Fragile Base Class）问题，导致修改父类一行代码，所有子类全部崩溃。

──────────────────────────────────
📚 前置知识检查
──────────────────────────────────
本阶段会用到以下概念（已在阶段1学过）：
· `extends` 关键字
· `super` 调用链
· `protected` 访问修饰符

我们将引入一个关键设计原则：**IS-A（是一个）原则**。
──────────────────────────────────

### 🌍 2.1 真实场景：电商支付系统 *💡 核心必学*

**场景描述**：
在一个电商系统中，我们需要对接多种支付渠道（支付宝、微信支付、银联）。
这些支付方式有共性（都要记录日志、都要校验金额），也有差异（调用不同的第三方API）。

**错误示范（为了复用而滥用继承）**：
有些初学者为了“省事”，发现 `Order`（订单类）里有金额信息，就让 `Payment` 继承 `Order`。

* ❌ **逻辑错误**：支付 **不是** 一个订单（Payment IS-NOT-A Order）。
* ❌ **后果**：支付对象里被迫携带了收货地址等无关数据，耦合度极高。

**正确做法（模板方法模式雏形）**：
建立一个抽象的父类处理通用逻辑，子类处理具体实现。

**业务流程 ASCII 图**：

```
       [父类: AbstractPayment]
       1. 校验金额 (通用逻辑)
       2. 记录 "开始支付" 日志 (通用逻辑)
               |
               v
       [子类: Alipay/WeChat]
       3. 调用第三方API (差异化逻辑)
               |
               v
       [父类: AbstractPayment]
       4. 更新数据库状态 (通用逻辑)

```

**代码实现**：

```java
// 1. 定义抽象父类（不仅是继承，更是制定标准）
// abstract 关键字：表示这个类不能直接 new，只能被继承
public abstract class AbstractPayment {
    
    // 通用逻辑：所有支付方式都一样
    public void processPayment(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("金额必须大于0");
        }
        System.out.println("📝 [通用] 记录支付日志: 金额 " + amount);
        
        // 关键点：调用子类具体的实现
        // doPay() 在这里还不知道具体怎么做，推迟到子类去写
        doPay(amount);
    }

    // 抽象方法：强制子类必须实现
    // protected：只允许子类访问，不对外公开
    protected abstract void doPay(double amount);
}

// 2. 具体子类：支付宝
public class Alipay extends AbstractPayment {
    @Override
    protected void doPay(double amount) {
        // 这里写支付宝独有的 SDK 调用逻辑
        System.out.println("🐜 [支付宝] 调用阿里接口扣款: " + amount);
    }
}

// 3. 具体子类：微信支付
public class WeChatPay extends AbstractPayment {
    @Override
    protected void doPay(double amount) {
        // 这里写微信独有的 SDK 调用逻辑
        System.out.println("💬 [微信] 调用腾讯接口扣款: " + amount);
    }
}

```

---

### ✅ 2.2 工程规范 *🔥 实战必备*

基于 **Java 17 LTS** 标准的红绿灯分级：

**🔴 RED（强制规范）**：

1. **禁止超过 3 层的继承树**
   * **后果**：代码逻辑像迷宫一样难以追踪。如果你的继承链是 `A -> B -> C -> D -> E`，请重构。
   * **方案**：使用“组合”（Composition）代替继承（阶段3会细讲）。

2. **必须始终使用 `@Override**`
   * **后果**：如果你拼写错了方法名（例如把 `doPay` 写成了 `doPlay`），编译器会认为你在定义新方法，而不是重写。运行时才发现逻辑没生效，排查极为痛苦。

   
**🟢 GREEN（推荐风格）**：

1. **要么设计用于继承，要么禁止继承 (`final`)**
   * 如果你写的类不打算让别人继承，请加上 `final` 关键字。
   * **好处**：明确告诉维护者“这个类逻辑是封闭的，不要试图修改它”。


```java
// ✅ 明确禁止继承的工具类
public final class StringUtils {
    // ...
}

```


2. **优先使用 `protected` 而不是 `public` 暴露父类成员**
   * **好处**：封装性。子类内部能用，但外部使用者无法直接访问，保护了父类内部状态。



---

### 🔄 2.3 版本演进：从“开放”到“封锁” *💡 核心必学*

这是 Java 继承机制的一个重要分水岭。

**传统写法（Java 8 及之前）**：
继承是“开放”的。任何类只要没有 `final`，就可以被任何人继承。

* **痛点**：你写了一个 `Payment` 类，只想让 `Alipay` 和 `WeChatPay` 继承。但是，同事小王可能会写一个 `HackPayment` 乱继承你的类，破坏了你的业务规则。

**现代写法（Java 17+）：密封类 (`sealed classes`)**
Java 17 引入了 `sealed`（密封）关键字，允许你**明确指定**谁可以继承你。

**代码对比**：

| 特性 | Java 8 (传统) | Java 17 (现代) |
| --- | --- | --- |
| **控制力** | 弱（要么全开，要么全关 `final`） | 强（白名单机制） |
| **安全性** | 无法防止恶意/意外继承 | 编译期强制检查 |

**Java 17 密封类示例**：

```java
// 现代写法：密封类
// 语义：CryptoPayment 只允许 Bitcoin 和 Ethereum 继承，其他人滚粗
public abstract sealed class CryptoPayment 
    permits Bitcoin, Ethereum { // <--- 明确的白名单
    
    public void checkNetwork() {
        System.out.println("正在检查区块链网络...");
    }
}

// ✅ 允许的子类 1
// 子类必须声明自己是 final, sealed 或 non-sealed
public final class Bitcoin extends CryptoPayment { 
    // ... 
}

// ✅ 允许的子类 2
public final class Ethereum extends CryptoPayment {
    // ...
}

/* // ❌ 编译报错！
// Dog 不是被允许的子类
public class Dog extends CryptoPayment { }
*/

```

**什么时候用 `sealed`？**
当你有一个**确定有限**的子类集合时（例如：支付方式、形状类型、用户角色），强烈建议使用 `sealed`。这不仅安全，还能让代码意图更清晰。

---

## 第3部分：避坑进阶（What to Avoid & Beyond）

在资深工程师的眼中，**继承往往是最后一种选择，而不是第一种选择**。因为继承的耦合度最强（父类变，子类必变），一旦设计失误，后期重构的代价是毁灭性的。

──────────────────────────────────     
📚 前置知识回顾       
──────────────────────────────────        
本阶段会用到以下概念：       
· `extends` 和 `super`（已在1.X节学过）        
· 方法重写 `@Override`（已在1.2节学过）        
· `processPayment` 业务逻辑（已在2.1节学过）         
──────────────────────────────────        

---

### ⚠️ 3.1 常见陷阱合集 *🔥 实战必备*

#### 陷阱 1：里氏替换原则 (LSP) 的崩塌

**核心铁律**：**子类必须能无缝替换父类，且不破坏程序逻辑。**
如果你继承了一个父类，却在重写方法时抛出异常或不做任何事，你就制造了一个“炸弹”。

**经典反例：鸵鸟是鸟吗？**
在生物学上是，但在代码里**不是**，因为鸵鸟不会飞。

**❌ 错误代码**：

```java
// 父类：鸟
class Bird {
    public void fly() {
        System.out.println("扑打翅膀飞翔...");
    }
}

// 子类：鸵鸟
class Ostrich extends Bird {
    @Override
    public void fly() {
        // 😱 违背了父类的承诺！
        // 调用者以为所有 Bird 都能飞，结果这里报错了
        throw new UnsupportedOperationException("我太重了，飞不起来");
    }
}

// 灾难现场
public void makeBirdFly(Bird bird) {
    bird.fly(); // 如果传入 Ostrich，程序崩溃！
}

```

**✅ 修复方案**：
不要强行继承。将“飞”的能力剥离出来，或者改变继承关系。

* **方案**：使用接口（Interface）定义 `Flyable`，让会飞的鸟实现它（接口将在后续章节详细讲）。

---

### 🚀 3.2 高级模式：组合优于继承 *⭐ 进阶选学*

**目标**：不使用 `extends` 也能复用代码，而且更灵活。

**概念**：

* **继承 (Inheritance)**：**Is-A** 关系（Cat **is a** Animal）。静态，编译期定死。
* **组合 (Composition)**：**Has-A** 关系（Car **has an** Engine）。动态，灵活，低耦合。

**场景**：
我们需要给一个 `Set` 集合增加“记录添加元素次数”的功能。

**❌ 方案A：继承（脆弱）**
继承 `HashSet` 并重写 `add` 方法。如果有天 `HashSet` 的底层逻辑变了（比如 `addAll` 内部不再调用 `add`），你的计数器就会失效或重复计数。

**✅ 方案B：组合（稳健）**
我们创建一个新类，**持有**一个 `Set` 对象，把任务**委托**给它。

**工程代码对比**：

```java
// ✅ 组合模式写法
public class InstrumentedSet<E> {
    // 1. Has-A: 持有一个 Set 对象（代理对象）
    private final Set<E> set;
    private int addCount = 0;

    // 通过构造器传入具体的 Set 实现（灵活！）
    public InstrumentedSet(Set<E> set) {
        this.set = set;
    }

    // 2. 增强逻辑
    public void add(E element) {
        addCount++;
        System.out.println("⚡ 监控到添加元素");
        set.add(element); // 3. 转发给底层的 Set
    }

    public int getAddCount() {
        return addCount;
    }
}

// 使用
// 你可以传入 HashSet, TreeSet, 甚至另一个 InstrumentedSet
InstrumentedSet<String> s = new InstrumentedSet<>(new HashSet<>());
s.add("Java");

```

**决策树：我该用继承还是组合？**

```
你需要复用代码吗？
  |
  ├─ YES ─> 是否满足 Is-A 关系（如猫是动物）？
  |           |
  |           ├─ YES ─> 是否需要向上转型（多态）？
  |           |           |
  |           |           ├─ YES ─> 【使用继承】(extends)
  |           |           └─ NO  ─> 【使用组合】(Composition)
  |           |
  |           └─ NO  ─> 【使用组合】(Composition) (如 汽车有一台引擎)
  |
  └─ NO ─> 不需要关联

```

---

### 🎓 3.3 实战挑战

**场景**：
你正在开发一个由 Java 17 驱动的 **"企业员工系统"**。
系统中有两种员工：

1. **全职员工 (FullTime)**：有月薪，需要打卡。
2. **实习生 (Intern)**：按天算工资，需要打卡。

**初级程序员小李的代码**：
他写了一个父类 `Employee`，并把算工资的逻辑写死了。

**要求**：

1. 指出小李代码中的**两个**致命设计问题（涉及继承滥用和逻辑封死）。
2. 使用 `abstract` 方法修复工资计算逻辑。
3. （可选）使用 Java 17 的 `sealed` 关键字保护 `Employee` 类，只允许这两类员工继承。

**📝 待修复的代码**：

```java
public class Employee {
    protected String name;
    
    // 问题1：这里写死了是月薪，那实习生怎么办？
    public double calculateSalary() {
        return 10000.0; // 默认全是 1万
    }
    
    public void clockIn() {
        System.out.println(name + " 打卡成功");
    }
}

class Intern extends Employee {
    // 实习生被迫继承了 calculateSalary 返回 10000
    // 如果忘记重写，公司就亏大了！
}

```

请提交你的**修复版代码**。

