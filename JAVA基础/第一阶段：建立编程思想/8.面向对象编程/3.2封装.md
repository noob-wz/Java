**直接使用点操作符（`u1.age = -1000`）去修改实例变量，虽然语法没问题，但会让业务逻辑崩盘。** 这就像**让用户直接去修改银行数据库里的余额字段，而不是通过柜台存取款。**

为了解决这个问题，Java 引入了 **“封装”** 。

封装的核心动作就两步：

1. **关门：** 把变量藏起来（使用 `private`）。
2. **开窗：** 提供受控的访问入口（使用 `public` 方法）。

我们一步步来实施这个“安保升级计划”。

---

### 第一步：关门 (引入 `private`)

我们需要一个修饰符来告诉 JVM：“这个变量是我的私有财产，外面的类（包括 `main` 方法）绝对不允许直接碰它。”

这个修饰符就是 **`private`**。

#### 💻 代码改造

我们将 `User` 类里的变量加上 `private`：

```java
class User {
    // 1. 加上 private：只有 User 类自己内部的代码能访问它
    private String name;
    private int age;
}

public class Main {
    public static void main(String[] args) {
        User u1 = new User();

        // 🛑 报错！
        // 编译器提示：age has private access in User
        // u1.age = -1000;
    }
}

```

**发生了什么？**

- **物理直觉：** 你给金库装上了钛合金大门。
- **效果：** 那个试图写 `-1000` 的“实习生”现在连代码都编译不过去了。编译器直接拦截了他的行为。这就是**从源头切断风险**。

---

### 第二步：开窗 (引入 Getter/Setter)

把门关死虽然安全了，但现在连正常的数据赋值（比如 `25` 岁）也做不到了。
所以，我们需要在钛合金大门上开两个**有保安看守的小窗口**。

这两个窗口在 Java 行业里有标准的名字：

1. **Setter（设置器）：** 用于**写入**数据（进）。
2. **Getter（访问器）：** 用于**读取**数据（出）。

#### 💻 代码实战：加上安检逻辑

这是封装最迷人的地方：**你可以在窗口里安排“保安”（逻辑判断）。**

```java
class User {
    // 1. 私有化数据 (关门)
    private int age;

    // 2. 公开的 Setter 方法 (写数据的窗口)
    // 格式：public void set + 属性名首字母大写
    public void setAge(int age) {
        // 🛡️ 保安进场：逻辑校验
        if (age < 0 || age > 150) {
            System.out.println("警告：非法年龄！拒绝修改。");
            return; // 直接结束方法，不执行下面的赋值
        }

        // 只有通过了安检，才允许修改真正的实例变量
        // this.age 表示“当前对象的 age 变量”
        // 等号右边的 age 是参数传进来的值
        this.age = age;
    }

    // 3. 公开的 Getter 方法 (读数据的窗口)
    // 格式：public + 返回类型 + get + 属性名首字母大写
    public int getAge() {
        // 也可以在这里加逻辑，比如“VIP 才能看年龄”
        return this.age;
    }
}

```

---

### 第三步：新世界的使用方式

现在，那个“实习生”再想干坏事，会发生什么？

```java
public class Main {
    public static void main(String[] args) {
        User u1 = new User();

        // 1. 试图搞破坏
        // u1.age = -1000; // ❌ 编译报错！直接红线警告，根本不让你运行。

        // 2. 只能走正规窗口
        u1.setAge(-1000); // ✅ 语法正确，但运行时被“保安”拦住了
        // 控制台输出：警告：非法年龄！拒绝修改。

        // 3. 正常存取
        u1.setAge(18);    // 合法数据，通过安检
        System.out.println(u1.getAge()); // 输出 18
    }
}

```

---

### 🚀 架构师总结：封装到底改变了什么？

请对比一下“封装前”和“封装后”：

| 维度         | 封装前 (Direct Access)                     | 封装后 (Encapsulation)                                   |
| ------------ | ------------------------------------------ | -------------------------------------------------------- |
| **可见性**   | **裸奔**（谁都能看，谁都能改）             | **隐秘**（只有内部知道真实数据）                         |
| **安全性**   | **极低**（可以被改成 `-1000`）             | **极高**（必须经过 `if` 校验）                           |
| **可维护性** | **差**（一旦逻辑变了，要改所有调用的地方） | **强**（逻辑变了，只改 `setAge` 方法内部，调用者无感知） |

这就是为什么大厂代码规范（如阿里巴巴 Java 手册）里强制规定：**所有的成员变量（实例变量）必须是 `private` 的。** 这不是为了耍酷，是为了活下去。

---

**💬 进度确认：**

这一段关于 **“private 关门”** 和 **“Setter/Getter 开窗”** 的逻辑，你理解了吗？
特别是代码里 `this.age = age` 这一句，虽然我们还没深讲 `this`，但你直觉上能分清哪个是“对象的变量”，哪个是“传进来的参数”吗？

如果没问题，我们就可以顺理成章地看看 **`this` 关键字** 到底在内存里扮演什么角色了。
