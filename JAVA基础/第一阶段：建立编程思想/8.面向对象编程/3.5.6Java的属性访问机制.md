前面理解了方法调用的“vtable 查表”机制，那么对比理解属性访问的**“Offset（偏移量）硬编码”**机制，就能彻底打通 Java 多态的任督二脉。

属性访问（Field Access）的核心在于：**它没有多态，只有内存布局的机械计算。**

---

# 🎯 JVM 属性访问完整流程（精简版）

## 示例代码

```java
class Father {
    public int money = 100;  // 父类属性
}

class Son extends Father {
    public int money = 200;  // ❌ 子类定义了同名属性（这叫"遮蔽" Hiding，不是重写）
}

// 测试
Father f = new Son();
System.out.println(f.money);  // 输出什么？

```

---

## 完整流程三阶段

### 1️⃣ 编译期：静态绑定（只看皮囊）

```
输入：f.money

处理：
  - f的静态类型是 Father
  - 编译器去 Father 类找名为 money 的属性
  - 找到了！(Father.money)
  - ❌ 编译器完全不看 f 将来指向谁，也不看 Son 类有没有 money

输出：getfield #2 <Father.money>
     （符号引用，锁定要访问 Father 那个坑位）

```

### 2️⃣ 类加载期：计算内存布局（定偏移量）

JVM 加载类时，会计算对象在堆内存中的**内存布局 (Object Layout)**，并确定每个属性的**偏移量 (Offset)**。

```
Father类布局计算：
  +0  [对象头 Mark Word]
  +8  [对象头 Klass Ptr]
  +12 [Father.money]    ← 确定偏移量：Offset 12

Son类布局计算（继承Father）：
  +0  [对象头 Mark Word]
  +8  [对象头 Klass Ptr]
  +12 [Father.money]    ← 继承下来的坑位 (Offset 12)
  +16 [Son.money]       ← 子类新定义的坑位 (Offset 16)

解析结果：
  符号引用 <Father.money> 被解析为 → Offset 12

```

### 3️⃣ 运行期：直接取值（盲人摸象）

```
执行 getfield #2 (即 fetch at Offset 12)

机械流程（无判断）：
  ① 取 f 的值 → 0x7A2B3C4D（Son对象的堆地址）
  ② 🚫 不查 vtable，不看对象类型
  ③ 直接计算：0x7A2B3C4D + 12 (Offset)
  ④ 读取该内存地址的值

输出：100
(读取的是 Father.money 的坑位)

```

---

## 🔑 解答你的核心疑惑

### 疑惑1：为什么不输出200？Son对象里不是有200吗？

**答案：JVM 是“按坐标”拿数据的，不是“按名字”搜数据的。**

```
Son 对象在堆里其实有两个 money：
  Offset 12: 100 (Father定义的)
  Offset 16: 200 (Son定义的)

指令告诉 JVM："去拿 Offset 12 的东西"。
JVM 就乖乖拿了 12 位置的 100。
它根本没眼看 16 位置的那个 200。

```

### 疑惑2：属性没有“重写”这一说吗？

**完全正确！属性只有“遮蔽 (Hiding)”。**

```
重写 (Override) [方法]：
  覆盖掉！vtable 里同一个位置的地址被替换了。
  (父类的逻辑消失了，只能调到子类的)

遮蔽 (Hiding) [属性]：
  并存！内存里父类的坑位和子类的坑位同时存在。
  (就像你和爸爸都叫"money"，但在家里你有你的房间，爸爸有爸爸的房间)

```

### 疑惑3：如果我想拿 200 怎么办？

**答案：改变编译期的“视线”（强制类型转换）。**

```java
((Son)f).money

```

```
编译期变化：
  - 此时引用类型变成了 Son
  - 编译器去 Son 类找 money
  - 生成指令：getfield <Son.money>

类加载解析：
  - <Son.money> 被解析为 Offset 16

运行期：
  - 拿 Offset 16 的值 → 输出 200

```

### 疑惑4：既然偏移量是类加载期算的，解析是运行时做的，凭什么说属性访问是‘静态绑定’（编译期决定）呢？

**答案：这里的“决定”指的是：决定了“要去读 Father 的属性”这件事。**
    * **静态绑定（编译期）：** 编译器在 .class 里写死了 Father.money。它锁死了**“我们要去 Father 的地盘找数据”**这个事实。
    * **动态绑定（多态）：** 如果是方法调用，编译器写的是 Father.method，但运行时 JVM 会换成 Son.method。

---

## 📊 核心图解：内存里的"双胞胎"

```
    栈 (Stack)                   堆 (Heap) - Son Instance
┌──────────────┐            ┌──────────────────────────┐
│ f (Father)   │───────────▶│ +0  [ 对象头 Header ]     │
└──────────────┘            │                          │
                            │ +12 [ Father.money = 100 ] ← getfield Father.money
指令是：                     │                          │   (瞄准这里)
"拿 Offset 12"               │ +16 [ Son.money    = 200 ]
                            └──────────────────────────┘

```

---

## 💡 一句话总结

**编译器在字节码中锁定了“要访问父类属性”的符号引用；JVM 在类加载时计算出父类属性的偏移量；运行时，JVM 严格按照这个父类偏移量去取值，直接无视了子类那个同名的属性。**