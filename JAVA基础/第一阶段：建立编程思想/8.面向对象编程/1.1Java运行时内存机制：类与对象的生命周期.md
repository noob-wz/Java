## 💾 《Java 运行时内存机制：类与对象的生命周期》

### 🎯 一、 核心概念区分

在 Java 中，类和对象的关系是 **模板与实例** 的关系。要理解它们的内存差异，必须明确区分 **结构定义** 和 **实例数据**。

| 特性         | 类（Class）              | 对象（Object）            |
| :----------- | :----------------------- | :------------------------ |
| **存在形式** | **抽象的、唯一的模板**   | **具体的、独立的实体**    |
| **程序阶段** | 编译期确定，运行时加载   | 运行时通过 `new` 操作创建 |
| **核心数据** | 结构、方法字节码、常量池 | 实例变量（属性的具体值）  |
| **内存区域** | **方法区/元空间**        | **堆（Heap）**            |
| **内存占用** | 占据方法区的静态结构信息 | 占据堆内存的动态实例数据  |

---

### 💻 二、 类（Class）：静态结构与方法区

类是所有对象的共享基础，它在内存中只存在一份，用于提供结构和方法逻辑。

#### 1. 编译期：`.class` 文件

- **本质：** 源代码经过 `javac` 编译后生成的结构化二进制文件(.class 文件)。
- **存储形式：** 类的所有定义（名称、方法签名、属性类型）和逻辑（字节码指令）以编码形式（文本信息通常为 UTF-16 编码）存储在磁盘上。
- **意义：** 此时，类是**磁盘上的数据**，尚未进入程序运行内存。

#### 2. 运行时：方法区（Method Area）

- **加载时机：** 当 JVM 首次用到某个类时，**类加载器（ClassLoader）** 会将其从磁盘加载到方法区。注意：这里的方法区不是.class 文件中的代码区，小心混淆
- **方法区内容（类的元数据）：**
  - **类的全限定名**（如 `com.bank.BankAccount`）。
  - **字段信息**（Field Info）：定义了类有哪些属性（但没有具体的属性值）。
  - **方法信息**（Method Info）：存放方法的字节码（即 `deposit()` 如何执行的指令）。
  - **运行时常量池**：存储字面量（如字符串常量）和符号引用。

> **结论：** 类定义以编码形式存在，运行时占据了 **方法区** 空间。但它所存储的是**结构和逻辑**，是 **所有对象共享的、不变的元数据**。

[JVM 内存可视化演示](1.2JVM运行时类与对象的内存可视化.html)

### 📦 三、 对象（Object）：动态数据与堆内存

对象是根据类模板创建出来的实体，负责存储自己的独有状态。

#### 1. 对象的创建与内存分配

- **触发操作：** 每次执行 `new BankAccount("...", 1000.00)` 都会触发一次对象创建。
- **堆内存分配：** JVM 会在 **堆（Heap）** 内存中为这个新对象开辟一块独立且连续的空间。
- **堆内存内容（实例数据）：**
  - **实例变量**：存放该对象特有的、实际的数据值（如张三账户的余额就是 $1000.00$）。
  - **对象头（Object Header）**：内部包含指向**方法区**中该类元数据的指针。这个指针告诉对象：“我的结构和方法逻辑在哪里”。

#### 2. 栈（Stack）内存中的引用

- **局部变量：** 声明的变量（如 `zhangsanAccount`）存储在栈内存中。
- **引用值：** 栈中的变量存储的是一个 **地址值（引用）**，它指向了堆内存中张三账户对象的具体位置。
- **关系：** 栈是**操作的通道**，通过引用去访问堆中的**数据实体**，并使用方法区中的**逻辑代码**。

---

### ⚖️ 四、 底层机制对比总结

| 特征         | 类定义（方法区）               | 对象实例（堆）                                     |
| :----------- | :----------------------------- | :------------------------------------------------- |
| **数据性质** | 静态、共享的结构               | 动态、独立的实体状态                               |
| **生命周期** | 较长，通常直到程序结束         | 短暂，对象不再被引用时会被 **垃圾回收（GC）** 销毁 |
| **操作方式** | 被动，程序无法运行时修改其结构 | 主动，可以调用方法改变自身的内部状态               |

通过这种方式，Java 实现了数据和逻辑的完美分离与协作：**类提供统一的规则，对象根据规则保持各自独立的状态。** 这是面向对象强大稳定性的底层基石。

> **一句话总结：**
>
> **只要是针对对象的成员变量数据就是存放在堆中的，而且类变量（所有类共享的静态变量）也是存在堆中的。但是所有成员方法（包括类和对象）的逻辑还是存放在方法区的。不过堆中的对象在分配内存时写入了类元数据指针，需要调用方法时，通过指针来操作方法**
>
> - **程序的指令是在方法区的，调用某个成员的方法，先找到堆，然后根据堆的类元数据指针又返回方法区寻找执行，然后又在栈中分配空间去具体运行**
>   - **同类成员方法调用：** 即使你没有写 `this.`，Java 编译器也会在幕后自动为你添加 `this.` 前缀，这是编译器的隐式行为
>   - **跨类成员方法调用：** 要创建一个类，然后通过`类.`进行引用
