### 💡 1. 核心结论：覆盖 vs 隐藏

请牢记这个**铁律**：

1. **属性 (Fields)**：如果子类定义了和父类同名的属性，发生的是 **隐藏 (Hiding)**。
   * *结果*：父类的属性还在，子类的属性也在，两者**共存**。


2. **方法 (Methods)**：如果子类定义了和父类**一模一样**（名字、参数都一样）的方法，发生的是 **覆盖/重写 (Overriding)**。
   * *结果*：在子类的**虚方法表 (vtable)** 里，父类方法的地址被**替换**成了子类方法的地址。父类的逻辑被“压”下去了。



---

### 🧱 2. `this` vs `super`：谁调用了谁？

针对新手常见疑问：“***如果在子类创建的对象下访问重写的方法，是通过 `this` 还是 `super`？***”

答案是：**取决于你在哪里喊话，以及你怎么喊话。**

我们分两种情况来看：

#### ✅ 情况 A：在子类的方法内部 (Inside)

在子类的代码块里，你有完全的控制权。你可以选择调用“现在的我”，也可以回溯“原来的爹”。

* **`this.method()`** (或直接写 `method()`):
* 👉 **调用子类重写后的逻辑**。
* *原理*：查当前对象的虚方法表 (vtable)，找到的是被覆盖后的地址。


* **`super.method()`**:
* 👉 **调用父类原本的逻辑**。
* *原理*：`super` 指令会**跳过**当前对象的虚方法表，直接去方法区找父类的类定义，强制调用那个老版本的方法。



#### ✅ 情况 B：在外部调用 (Outside, e.g., Main)

```java
Son s = new Son();
s.method(); // 外部只能这样调

```

* 在外部，你只有对象引用 `s`。
* 当你调用 `s.method()` 时，**永远**只能调用到 **子类重写后 (Override)** 的版本。
* **外部无法越过子类直接去调父类被覆盖的方法**（除非你在子类里写一个方法暴露 `super` 调用，否则父类逻辑就被“封印”了）。

---

### 🔬 3. 内存可视化：虚方法表的操作

为了让你看得更清楚，我们用“虚方法表 (vtable)”来看看发生了什么。

**假设：**

* 父类 `Father` 有方法 `say()` (地址 0x111)。
* 子类 `Son` 重写了 `say()` (地址 0x222)。
* 子类 `Son` **没有**重写 `run()` (继承父类，地址 0x333)。

**[ Son 对象的虚方法表 ]**

| 方法名 | 指向地址 | 状态 | 备注 |
| --- | --- | --- | --- |
| **say()** | **0x222** (Son.say) | 🔴 **已覆盖** | 父类的 0x111 被抹掉了 |
| **run()** | **0x333** (Father.run) | 🟢 **继承** | 照搬父类的 |

**操作流程：**

1. **`this.say()`**:
* JVM 查表 👉 看到 **0x222** 👉 执行子类逻辑。


2. **`super.say()`**:
* JVM **不查表** 👉 直接去 `Father` 类文件里找代码 👉 执行父类逻辑 (0x111)。



---

### 💻 4. 实战代码验证

```java
class Father {
    public void say() {
        System.out.println("👴 爸爸：我是旧逻辑");
    }
}

class Son extends Father {
    // 覆盖 (Override) 了父类方法
    @Override 
    public void say() {
        System.out.println("👶 儿子：我是新逻辑");
    }

    public void test() {
        // 1. 调用自己的 (覆盖后的)
        System.out.print("this.say() -> ");
        this.say(); 
        
        // 2. 调用爸爸的 (原本的)
        System.out.print("super.say() -> ");
        super.say();
    }
}

public class Main {
    public static void main(String[] args) {
        Son s = new Son();
        
        System.out.println("--- 外部调用 ---");
        s.say(); // 只能调到子类的！
        
        System.out.println("\n--- 内部测试 ---");
        s.test();
    }
}

```

**运行结果：**

```text
--- 外部调用 ---
👶 儿子：我是新逻辑

--- 内部测试 ---
this.say() -> 👶 儿子：我是新逻辑
super.say() -> 👴 爸爸：我是旧逻辑

```

---

### ⚠️ 5. 关键避坑：怎样才算“覆盖”？

你提到“覆盖”时，必须满足极其严格的条件（也叫 **方法签名 Signature** 必须一致）：

1. **方法名**必须相同。
2. **参数列表**必须完全相同。
3. **返回类型**必须相同（或是其子类）。
4. **

**⚡️ 陷阱：如果你改了一点点参数...**

```java
class Father {
    public void eat(String food) { ... }
}

class Son extends Father {
    // 😱 注意！参数变了！
    public void eat(Object food) { ... } 
}

```

这**不是覆盖 (Override)**！这是 **重载 (Overload)**！
此时，`Son` 对象里其实有两个 `eat` 方法：

1. 继承来的 `eat(String)`
2. 自己写的 `eat(Object)`

它们互不干扰，并没有发生“覆盖”。

---

### 📝 总结你的问题

> *如果在子类创建的对象下访问方法，是通过this.方法名访问还是通过super.方法名访问，还是都可以访问呢或者说没有发生覆盖*

**答案是：**

1. 确实发生了**覆盖**。
2. 在子类内部，**都可以访问**。
   * 想用新逻辑，用 `this.方法()`（默认）。
   * 想复用旧逻辑，用 `super.方法()`。


3. 在外部（main方法），只能访问到**覆盖后（子类）**的版本。

---

### 拓展：外部调用 & 内部调用
**外部调用：** 任何通过 对象引用变量 (Object Reference) 发起的调用，都算外部调用。即 `对象名.方法名()`。
**内部调用：** 在对象实例的方法内部，调用自己的其他方法.