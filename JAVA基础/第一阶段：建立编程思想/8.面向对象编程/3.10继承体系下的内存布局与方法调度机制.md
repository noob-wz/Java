# ☕ Java 核心解密：继承体系下的内存布局与方法调度机制

**摘要**：
本文旨在深入剖析 Java 虚拟机（JVM）在处理继承关系时，如何通过**对象内存布局**、**虚方法表 (vtable)** 以及**字节码偏移量**，来决定方法调用时的数据访问行为。特别是解析为何在子类对象上运行父类方法时，能够精准访问父类私有数据，以及重写（Override）发生时底层机制的变化。

---

## 1. 实验环境与前置模型

为了便于演示，我们定义如下类结构。注意这里发生了**属性隐藏 (Variable Hiding)**，即父子类存在同名属性 `i`。

```java
// 父类
class A {
    int i = 10;
    public void printI() { System.out.println(i); }
}

// 子类
class B extends A {
    int i = 20;
    // 场景1：未重写 printI()
    // 场景2：重写 printI() { System.out.println(i); }
}

```

当我们执行 `B b = new B();` 时，无论方法是否重写，**堆内存中的对象物理结构是固定不变的**。

### 1.1 对象的物理内存布局 (Heap Layout)

在 JVM 堆内存中，子类对象会完整保留父类的数据结构。`b` 对象的内部布局如下（假设对象头占用 12 字节）：

```text
       【 堆内存：对象 b (地址 0x99) 】
+---------------------------------------------+
| 1. [ 对象头 (Header) ]                      |
|    - Klass Pointer (指向 B.class 元数据)     |
+---------------------------------------------+
| 2. [ 父类 A 数据区 ]                         |
|    - int i = 10;   <-- 📍 偏移量 Offset: 12  |
|      (这是 A.i，即父类的私房钱)               |
+---------------------------------------------+
| 3. [ 子类 B 数据区 ]                         |
|    - int i = 20;   <-- 📍 偏移量 Offset: 16  |
|      (这是 B.i，即子类的私房钱)               |
+---------------------------------------------+

```

**关键点**：

* 内存里同时存在两个 `i`。
* **方法执行的核心奥秘，就在于指令是去读 Offset 12 还是读 Offset 16。**

---

## 2. 场景一：方法未重写 (Method Not Overridden)

当 `B` 类没有重写 `printI()` 时，调用 `b.printI()` 的过程如下。

### 2.1 虚方法表 (vtable) 的状态

在类加载阶段，JVM 为 `B` 类构建虚方法表。因为 `B` 没有提供 `printI` 的新实现，所以表中的指针**直接指向父类代码地址**。

* **vtable [printI]** -> 指向 `0x111` (**A.printI 的代码地址**)

### 2.2 字节码指令 (The Instruction)

此时执行的代码是 `A.java` 编译出来的。编译器在编译 `A` 类时，只看得到 `A` 里的 `i`。
编译器计算出 `A.i` 位于对象起始位置 + 12 字节处。

**`A.class` 中的机器指令逻辑：**

```assembly
LOAD_THIS           // 加载当前对象地址 (0x99)
GET_FIELD_OFFSET 12 // ⚠️ 硬编码：强制读取 [this + 12] 的数据
PRINT               // 打印结果

```

### 2.3 执行过程还原

1. **调用**：JVM 查 `B` 类的 vtable，发现指向 `A` 的代码段，于是跳转执行。
2. **传参**：传入 `b` 对象地址 (`0x99`) 作为 `this`。
3. **运行**：
* 代码指令要求读取 `0x99 + 12` 的数据。
* 查看内存图，该位置存放的是 **10** (A.i)。


4. **结果**：输出 `10`。

**结论**：虽然操作的是子类对象，但因为运行的是父类的“旧代码”，它手里拿的是“旧地图”，只能定位到父类的数据区。

---

## 3. 场景二：方法已重写 (Method Overridden)

当 `B` 类重写了 `printI()` 时，调用 `b.printI()` 的过程发生根本性变化。

### 3.1 虚方法表 (vtable) 的状态

JVM 发现 `B` 类定义了新的 `printI`，于是更新 `B` 类的虚方法表，将指针指向子类的新代码。

* **vtable [printI]** -> 指向 `0x222` (**B.printI 的代码地址**)

### 3.2 字节码指令 (The Instruction)

此时执行的代码是 `B.java` 编译出来的。编译器在编译 `B` 类时，在当前作用域找到了 `B` 自己定义的 `i`。
编译器计算出 `B.i` 位于对象起始位置 + 16 字节处（排在父类数据后面）。

**`B.class` 中的机器指令逻辑：**

```assembly
LOAD_THIS           // 加载当前对象地址 (0x99)
GET_FIELD_OFFSET 16 // ⚠️ 新指令：强制读取 [this + 16] 的数据
PRINT               // 打印结果

```

### 3.3 执行过程还原

1. **调用 (多态生效)**：JVM 查 `B` 类的 vtable，发现指向 `B` 的新代码段，于是跳转执行。
2. **传参**：依然传入 `b` 对象地址 (`0x99`) 作为 `this`。
3. **运行**：
* 代码指令要求读取 `0x99 + 16` 的数据。
* 查看内存图，该位置存放的是 **20** (B.i)。


4. **结果**：输出 `20`。

**结论**：重写不仅改变了代码的执行入口，更改变了数据访问的“地图（偏移量）”。

---

## 4. 特殊情况：重写中调用 `super`

如果在重写的 `B.printI` 中调用了 `super.printI()`：

```java
// B.java
public void printI() {
    super.printI(); // 调用父类逻辑
}

```

1. **指令变化**：编译器会生成 `invokespecial` 指令。
2. **跳过查表**：JVM **忽略** `B` 类的 vtable，直接定位到 `A` 类的代码地址 (`0x111`)。
3. **上下文切换**：
* 程序暂时跳回 **场景一** 的逻辑。
* 执行 `A` 的代码 -> 使用 Offset 12 -> 读取到 `10`。


4. **回归**：`super` 调用结束后，回到 `B` 的代码继续执行。

---

## 5. 总结对比表

| 维度 | 场景一：未重写 (Inheritance) | 场景二：已重写 (Polymorphism) |
| --- | --- | --- |
| **虚方法表指针** | 指向 **父类** 代码段 (`0x111`) | 指向 **子类** 代码段 (`0x222`) |
| **执行的字节码来源** | `A.class` | `B.class` |
| **数据寻址方式** | 使用 **父类字段** 的偏移量 (Offset 12) | 使用 **子类字段** 的偏移量 (Offset 16) |
| **`this` 引用指向** | 子类对象 (`0x99`) | 子类对象 (`0x99`) |
| **能否看见子类属性** | **不能** (父类代码不知道子类的存在) | **能** (子类代码优先访问自己的属性) |
| **最终输出结果** | 父类数据 (`10`) | 子类数据 (`20`) |

---

**核心心法**：

> 对象的**物理布局**包含所有父子类的数据（像千层饼）。
> 方法的**字节码指令**决定了去这块饼的哪一层拿数据（通过固定的偏移量）。
> **重写**的本质，就是让 vtable 指向了一段“持有新偏移量”的新代码。