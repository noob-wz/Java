### ⚔️ 两条核心法则

1. **"类"优先于"对象"**：
* **静态 (Static)** 的东西属于类，优先执行（在类加载时），且**只执行一次**。
* **非静态 (Instance)** 的东西属于对象，每次 `new` 都会执行。


2. **"父"优先于"子"**：
* 要想有儿子，必须先有老爸。所以无论是静态加载，还是对象创建，永远是 **父类先于子类**。



---

### 🔄 一个完整流程 (绝对顺序)

当你在代码中执行 `new Child()` 时，JVM 内部的执行顺序如下：

**第一阶段：类加载（只发生一次）**

1. **父类** 的静态变量 / 静态代码块 (按代码书写顺序)
2. **子类** 的静态变量 / 静态代码块 (按代码书写顺序)

**第二阶段：对象创建（每次 new 都发生）**
3.  **父类** 的普通成员变量 / 普通代码块 (按代码书写顺序)
4.  **父类** 的构造器
5.  **子类** 的普通成员变量 / 普通代码块 (按代码书写顺序)
6.  **子类** 的构造器

---

### 🧪 代码实战验证

我们要眼见为实。下面这段代码涵盖了所有情况，请仔细看打印的顺序：

```java
class Parent {
    // 1. 父类静态变量
    static String staticField = print("1. 父类-静态变量");

    // 2. 父类静态代码块
    static {
        System.out.println("2. 父类-静态代码块");
    }

    // 5. 父类普通变量
    String field = print("5. 父类-普通变量");

    // 6. 父类普通代码块
    {
        System.out.println("6. 父类-普通代码块");
    }

    // 7. 父类构造器
    public Parent() {
        System.out.println("7. 父类-构造器");
    }

    // 辅助打印方法
    public static String print(String str) {
        System.out.println(str);
        return "";
    }
}

class Child extends Parent {
    // 3. 子类静态变量
    static String staticField = print("3. 子类-静态变量");

    // 4. 子类静态代码块
    static {
        System.out.println("4. 子类-静态代码块");
    }

    // 8. 子类普通变量
    String field = print("8. 子类-普通变量");

    // 9. 子类普通代码块
    {
        System.out.println("9. 子类-普通代码块");
    }

    // 10. 子类构造器
    public Child() {
        System.out.println("10. 子类-构造器");
    }
}

public class InitOrderDemo {
    public static void main(String[] args) {
        System.out.println("====== 第一次 new Child() ======");
        new Child();
        
        System.out.println("\n====== 第二次 new Child() ======");
        new Child();
    }
}

```

#### 📊 运行结果（请对照上面的序号）：

```text
====== 第一次 new Child() ======
1. 父类-静态变量
2. 父类-静态代码块
3. 子类-静态变量
4. 子类-静态代码块
----------------------- (静态部分结束，类加载完毕)
5. 父类-普通变量
6. 父类-普通代码块
7. 父类-构造器
----------------------- (父类对象初始化完毕)
8. 子类-普通变量
9. 子类-普通代码块
10. 子类-构造器

====== 第二次 new Child() ======
5. 父类-普通变量
6. 父类-普通代码块
7. 父类-构造器
8. 子类-普通变量
9. 子类-普通代码块
10. 子类-构造器

```

---

### 💡 深度解析：为什么是这个顺序？

#### 1. 为什么静态先执行？

因为 JVM 在创建对象之前，必须先**加载类**。`static` 代码块和变量是在类加载阶段（Class Loading）初始化的。此时堆里连对象引子的影子都没有。

#### 2. 为什么第二次 new 时，静态不再输出了？

**类只加载一次**。JVM 发现 `Child.class` 和 `Parent.class` 已经在内存的方法区里了，就不会再执行静态初始化逻辑了。

#### 3. 为什么父类构造器先于子类构造器？

子类的构造器第一行默认都有一个隐式的 `super()`。
JVM 必须保证**父类的部分先初始化完成**，子类才能安全地继承和使用父类的成员。如果不先初始化父类，子类如果调用父类的方法，可能会因为父类还没准备好而报错。

#### 4. 为什么普通变量/代码块 先于 构造器？

这是很多人的误区。实际上，**构造器是最后执行的**。
当你写 `new Child()` 时，JVM 的指令顺序是：

1. 分配内存，所有字段清零。
2. 执行普通变量赋值和代码块（它俩本质上被编译器合并到了构造方法的**最前面**）。
3. 最后执行构造方法里你自己写的代码。

---

### 🧠 记忆口诀

> **父静 子静** (先类加载，只一次)
> **父普 父构** (父类对象初始化)
> **子普 子构** (子类对象初始化)

记住这个六字真言，遇到任何初始化顺序题都能秒杀！