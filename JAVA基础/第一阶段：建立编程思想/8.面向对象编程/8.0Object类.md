如果说 Java 是一个家族，那么 **Object 类** 就是所有类的**老祖宗 (The Ultimate Ancestor)**。

──────────────────────────────────

## 第1部分：建立认知（What & Why）

### 📦 1.1 核心概念 *💡 核心必学*

**核心定义**：`java.lang.Object` 是 Java 中唯一没有父类的类。       
**任何一个类**（包括你写的类、JDK 自带的类、数组），只要没有显式继承其他类，编译器都会默认让它继承 `Object`。

**类层级图 (ASCII)**：

```text
       [Object] <--- 老祖宗
          ^
          |
    +-----+------+
    |            |
 [String]    [Employee] <--- 你写的类
                 ^
                 |
             [Manager]

```

**这意味着**：
你可以用 `Object` 类型的变量，指向**任何**东西。

```java
Object o1 = new String("Hello");
Object o2 = new Employee("Jack");
Object o3 = new int[5];

```

---

### 🚀 1.3 快速上手 *💡 核心必学*

因为所有类都继承了 `Object`，所以你刚写出来的空类，就已经拥有了 11 个方法（常用的有 5 个）。

```java
// 你写的：
class Cat {}

// 编译器眼中的：
class Cat extends Object {
    // 继承了 toString()
    // 继承了 equals()
    // 继承了 hashCode()
    // 继承了 getClass()
    // ...
}

public class Main {
    public static void main(String[] args) {
        Cat c = new Cat();
        // 虽然你没写 toString，但可以直接调用
        System.out.println(c.toString()); 
        // 输出示例：Cat@1b6d3586 (类名@哈希码的16进制)
    }
}

```

---

## 阶段2：工程实践（How to Do Right）

### 🌍 2.1 必须重写的"三剑客" *🔥 实战必备*

在真实的工程开发中，我们几乎从不使用 `Object` 默认提供的方法实现，因为它们**太简陋了**。

你需要根据业务需求重写 (Override) 以下三个方法：

#### 1. `toString()` —— 给这种人看的

* **默认实现**：`类名@地址哈希`（如 `User@4554617c`）。
* *问题*：日志里打印这个，根本不知道用户是谁。


* **工程规范**：返回清晰的、人类可读的字符串（通常包含关键属性）。

```java
// ✅ 推荐写法
@Override
public String toString() {
    return "User{id=" + id + ", name='" + name + "'}";
}

```

#### 2. `equals(Object obj)` —— 逻辑判等

* **默认实现**：就是 `==` 的判断地址是否相同的作用（不包含比较基本类型），即是不是同一个对象。
  * 子类中往往重写该方法，用于判断内容是否相等。比如**String中重写为比较的是地址+内容，包装类中重写为比较的是内容**
* *问题*：两个 `new User("Tom")`，虽然名字一样，但内存地址不同，默认 `equals` 会返回 `false`。


* **工程规范**：比较**内容**（只要 ID 和名字一样，就认为是同一个人）。

#### 3. `hashCode()` —— 集合的索引

* **默认实现**：基于内存地址计算的一个随机整数。
* **工程规范**：**如果两个对象 `equals` 为 true，它们的 `hashCode` 必须相等**。这是 HashMap、HashSet 正常工作的前提。

---

### ✅ 2.2 现代写法 (Java 17+ & IDE)

**不要手动去写这些样板代码！** 容易写错且浪费时间。

**方法 A：IDE 自动生成 (Alt + Insert / Command + N)**      
在 IDEA 中，选择 `Generate` -> `equals() and hashCode()`，一路回车即可。

**方法 B：使用 Lombok (注解流)**

```java
@Data // 一个注解搞定 toString, equals, hashCode, getters, setters
public class User {
    private String name;
}

```

**方法 C：使用 Java 17 Record (最推荐)**        
如果你只是为了存数据：

```java
// 自动帮你写好了 toString, equals, hashCode
public record User(String name, int age) {}

```

---

## 阶段3：避坑进阶（What to Avoid & Beyond）

### ⚠️ 3.1 致命陷阱：`==` vs `equals` *🔥 面试/实战必问*

这是 Java 初学者最容易混淆的概念。

**ASCII 图解区别**：

假设 `String s1 = new String("Hi");` 和 `String s2 = new String("Hi");`

```text
Stack (栈)               Heap (堆)
+------+                +-----------------+
|  s1  |--------------> | String对象 ("Hi") |  <-- 地址 0x111
+------+                +-----------------+
                          ^
+------+                  |
|  s2  |--------------> +-----------------+
+------+                | String对象 ("Hi") |  <-- 地址 0x222
                        +-----------------+

```

| 比较方式 | 比较的内容 | 结果 | 解释 |
| --- | --- | --- | --- |
| **`s1 == s2`** | **左右两边的"值"** | **false** | 0x111 不等于 0x222 (比较的是钥匙) |
| **`s1.equals(s2)`** | **指向的对象内容** | **true** | "Hi" 等于 "Hi" (比较的是房间里的东西) |

**🔴 RED（强制规范）：**

* **比较对象内容**（尤其是字符串 `String`），永远使用 `equals()`。
* **比较基本类型**（`int`, `double`），永远使用 `==`。

---
