**多态（Polymorphism）的核心——“核心逻辑依赖于通用的标准”**，那么接下来的**抽象类（Abstract Class）**和**接口（Interface）**就是顺理成章的事情。

它们不是新东西，它们只是为了**修补多态留下的两个“大 Bug”**。

---

### 第一部分：抽象类 (Abstract Class) —— 禁止“空壳”

#### 1. 多态留下的 Bug

回顾之前的代码，我们定义了一个父类 `Payment`：

```java
// 普通的父类
class Payment {
    // 问题在这里：这个方法里写什么？
    // 因为它是父类，没法具体写。写"扫码"不对，写"转账"也不对。
    public void pay() {
        System.out.println("我不知道怎么付钱..."); // 👈 尴尬的默认代码
    }
}

```

这里有两个巨大的逻辑漏洞：

1. **漏洞一：** 有人可能会手贱去 `new Payment()`。
   - _现实谬误：_ 现实中不存在一个“纯粹的支付”，它必须是“支付宝”或“微信”。创建一个抽象的“支付对象”是没有意义的。

2. **漏洞二：** 子类可能**忘了重写** `pay()` 方法。
   - _后果：_ 如果 `Alipay` 忘了写 `pay` 方法，程序不会报错，但运行时会打印出“我不知道怎么付钱...”，这是严重 Bug。

#### 2. 解决方案：加上 `abstract`

为了堵住这两个漏洞，Java 允许你把父类变成“抽象类”。

**修改后的代码：**

```java
// 1. 加上 abstract：变成了抽象类
abstract class Payment {

    // 2. 方法也加上 abstract：变成了抽象方法
    // 意思：我没有代码体，也没有花括号 {}，我只定标准！
    // 就像只有标题的空文件。
    public abstract void pay();
}

```

#### 3. 现在的效果

1. **禁止实例化：**

   - `new Payment();` ❌ **编译器直接报错**。
   - _逻辑：_ 防止你造出一个没用的“空壳”。

2. **强制重写：**

   - 如果 `Alipay` 继承了 `Payment`，但没有重写 `pay()`。
   - ❌ **编译器直接报错：** “你必须实现 pay 方法，否则别想编译通过！”
   - _逻辑：_ 它是 **“必须要填的空”**，就像填表时的必填项 `*`。

---

### 第二部分：接口 (Interface) —— 打破“血缘”

#### 1. 抽象类剩下的 Bug

抽象类解决了“强制标准”的问题，但它引入了一个新问题：**单继承局限**。

在 Java 里，**一个孩子只能有一个亲爹**（`extends` 只能跟一个类）。

**场景危机：**
假设你的游戏里有：

- `Bird` (鸟类) —— 会飞 `fly()`
- `Airplane` (飞机类) —— 会飞 `fly()`
- `Superman` (超人) —— 会飞 `fly()`

你想写一个“防空雷达”系统，检测所有 **“会飞的东西”**。

- 如果你定义一个父类 `Flyer`（飞行物）。
- 鸟继承 `Flyer`？合理。
- 飞机继承 `Flyer`？合理。
- 超人继承 `Flyer`？**不合理！** 超人应该是 `Person` 的子类。但他已经继承了 `Person`，就不能再继承 `Flyer` 了。

**这就是痛点：** 抽象类代表的是 **“是不是” (Is-A)** 的血缘关系。但“飞行”只是一种 **“能力” (Can-Do)**，跟血缘无关。

#### 2. 解决方案：接口 (Interface)

接口彻底抛弃了“血缘”的概念。它只是一张 **“能力证书”**或者是**“协议”**。

**代码定义：**

```java
// 定义一个接口：代表“会飞”的能力
interface Flyable {
    // 只有标准，没有实现
    void fly();
}

```

**代码实现（Implements）：**

```java
// 鸟：既是动物，又有飞行执照
class Bird extends Animal implements Flyable {
    public void fly() { System.out.println("鸟扇翅膀飞"); }
}

// 飞机：既是机器，又有飞行执照
class Airplane extends Machine implements Flyable {
    public void fly() { System.out.println("飞机喷气飞"); }
}

// 超人：既是人，又有飞行执照
class Superman extends Person implements Flyable {
    public void fly() { System.out.println("超人举手飞"); }
}

```

#### 3. 核心逻辑（雷达系统）

现在，多态依然有效，而且更强大了：

```java
class Radar {
    // 🌟 我不管你爹是谁（是人是鸟是机器），我只看你有没有“飞行执照”
    public void detect(Flyable f) {
        System.out.println("发现不明飞行物！");
        f.fly(); // 多态调用
    }
}

```

---

### 🚀 终极对比图解

为了帮你建立知识逻辑基础，请看这张对比表。这是面试和实战中最关键的区别。

| 特性         | 抽象类 (Abstract Class) | 接口 (Interface)      |
| ------------ | ----------------------- | --------------------- |
| **核心逻辑** | **亲爹 (模板)**         | **合同 / 执照 (标准)** |
| **关系描述** | **Is-A (是不是)**<br>   |<br>例：宝马 **是** 汽车 | **Has-A / Can-Do (能不能)**<br><br>例：宝马 **能** 导航 (GPS) |
| **继承数量** | **只能继承 1 个**<br><br>(你只能有一个亲爹) | **可以实现 N 个**<br><br>(你可以考驾照、潜水证、厨师证...) |
| **设计目的** | **代码复用** + 强制标准<br><br>(父类可以写一些公共代码给子类用) | **彻底解耦** + 行为规范<br><br>(只定标准，完全不管你怎么干) |
| **生活比喻** | **“未完成的图纸”** | **“USB 接口标准”** |

---

### 🧩 你的知识体系闭环了

结合你之前对多态的理解，现在的完整架构图是这样的：

1. **多态 (Polymorphism)：** 核心机制。让核心逻辑（调用者）可以面向“标准”编程，而不是面向“具体”编程。
2. **抽象类 (Abstract Class)：** 用来定义 **“家族式的标准”**。防止创建空壳父类，强制子类干活。
3. **接口 (Interface)：** 用来定义 **“跨家族的通用标准”**。它是最极致的解耦，像 USB 插口一样，连接两个完全不相关的世界。
