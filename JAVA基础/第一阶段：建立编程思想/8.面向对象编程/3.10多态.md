# 📘 架构师讲义：多态与动态绑定 (Polymorphism & Dynamic Binding)

### 1. 🎭 核心定义：灵魂的自由 (The Essence)

- **一句话定义：** 同一个指令，作用于不同的对象上，产生不同的结果。

### 2. 🧱 多态的三大基石 (The Three Pillars)

多态不是凭空产生的，它必须满足以下三个条件，缺一不可：

1. **继承 (Inheritance)：** 必须存在父子关系（Is-A）。
2. **重写 (Override)：** 子类必须覆盖父类的方法（行为改变）。(父类和子类方法名和参数列表相同)
3. **向上转型 (Upcasting)：** 声明的是父类，实际创建的是子类。不过向上转型会造成**无法调用子类特有的方法**[见3.11向上转型的限制](3.11向上转型的限制&向下转型.md)

```java
// 👈 左边是父类引用   =   👉 右边是子类对象
Hero h = new Warrior();
```

---

### 3. ⚔️ 核心机制：编译看左，运行看右 

这是多态最底层的真相，也是 90% 的初学者混淆的地方。请死记硬背以下规则。

#### A. 变量 (Fields)：静态绑定的僵化

- **编译期看左边（静态检查）。**
- **底层原理：** 编译器只认识引用的类型，依据**引用类型（父类）**，在字节码中锁死符号引用
  - **针对属性：** JVM 随后在类加载期将其解析为固定偏移量 (Offset)。这一决策全过程发生在对象创建之前，因此完全屏蔽了运行时堆内存中实际对象的类型差异。
  - **针对方法：** JVM 检查引用类型所属的类中有没有调用的方法，如果没有报错；如果有，编译通过，生成字节码
- **现象：** 即使子类有同名变量，引用的也是父类的那个。

#### B. 方法 (Methods)：动态绑定的灵活

- **运行期看右边（动态绑定）。**
- **底层原理：**
  1. 在类加载阶段，父类和子类都被加载好了，此时方法区中父类和子类的虚方法表都被创建好了。如果发生方法重写，父类方法内存地址被覆盖（此时子类虚方法表中的方法名称依然用的是父类的名称，索引也和父类一致，因为是直接复制过来的）
  2. 创建对象，JVM 拿到对象的引用，顺藤摸瓜找到堆内存中的**对象头 (Object Header)**。
  3. 读取**类型指针 (Klass Pointer)**，确认真实身份（是 Warrior）。
  4. 使用该类的 **虚方法表 (vtable)**，找到重写后的代码入口地址。
- **说明：** **`Java` 默认的所有实例方法调用都是 动态绑定 的（除非你显式加了 private/final/static）**

```text
Father 的 vtable:
+---+----------------------+
| 5 | 0xF100 (Father.mA)   |
+---+----------------------+
| 6 | 0xF200 (Father.mB)   |
+---+----------------------+

Son 的 vtable (复制 -> 覆盖 -> 追加):
+---+----------------------+
| 5 | 0xS100 (Son.mA)      |  <-- 索引5被覆盖 (Override)！但仍对应 methodA
+---+----------------------+
| 6 | 0xF200 (Father.mB)   |  <-- 索引6未变 (Inherit)，指向父类地址
+---+----------------------+
| 7 | 0xS300 (Son.mC)      |  <-- 新增方法排在后面 (Append)
+---+----------------------+
```

- **现象：** 永远执行子类重写后的版本。

#### 一句话总结

**成员变量是静态绑定的，编译器在编译期就将其解析为固定的【内存偏移量】，此时并不依赖堆内存的创建；而方法调用是动态绑定的，必须在运行期通过堆中【对象头的类型指针】来动态定位具体的方法入口。”**

---

### 4. 📝 代码实战：验证“分裂” (Code Proof)

```java
// 父类
class A {
    int val = 10;                // 变量
    void show() { print("A"); }  // 方法
}

// 子类 B
class B extends A {
    int val = 20;                // 变量遮蔽 (Shadowing)
    // @Override 是给编译器看的：帮我检查一下，我是不是真的在覆盖父类方法？
    // 万一我手抖把 show 写成了 showw，编译器会报错提醒我。
    @Override
    void show() { print("B"); }  // 方法重写 (Override)
}

// 子类
public class Test {
    public static void main(String[] args) {
        // ⚡ 向上转型：引用是 A，对象是 B
        A x = new B();

        // 1. 变量看左边 -> A.val (编译器定死的偏移量)
        System.out.println(x.val); // 输出: 10

        // 2. 方法看右边 -> B.show() (运行时查表)
        x.show();                  // 输出: "B"
    }
}

```

---

### 5. 🚀 架构价值：为什么要搞这么复杂？

你可能会问：_“为什么不直接写 `Warrior w = new Warrior()`？非要用 `Hero h` 去指代它，这不是没事找事吗？”_

**架构师的答案：为了“可扩展性” (Extensibility)。**

想象你要写一个“全军出击”的功能。

**没有多态（笨办法）：**
你需要为每种职业写一个方法。

```java
public void attackAll(Warrior w, Bird b, Mage m...) {
    w.move();
    b.move();
    m.move();
    // 如果明天出了个新职业“刺客”，你得回来改代码，加个参数
}

```

**有了多态（架构师办法）：**
我可以把所有子类都看作 `Hero`。

```java
// 我不管你具体是什么，反正你们都是 Hero
public void attackAll(Hero[] army) {
    for (Hero h : army) {
        // 多态发生！
        // 如果 h 是战士，就跑；如果 h 是鸟，就飞。
        // 代码完全不用改，自动适应。
        h.move();
    }
}

```

**结果：** 明天游戏更新，增加了一个 `Assassin`（刺客）继承 `Hero`。
**这一段 `attackAll` 的代码一行都不用动！** 它会自动调用刺客重写后的 `move()`。这就是**“解耦”**。

---

### 6. 🛡️ 重写 (Override) 的铁律

要想成功实现“偷梁换柱”，子类必须遵守 **“两同两小一大”** 规则：

1. **方法名、参数列表必须完全一致：** (两同) 否则就是重载 (Overload)，多态失效。
2. **访问权限必须大于等于父类：** (一大) 父类公开 (public)，子类不能私藏 (private)。
3. **抛出异常必须小于等于父类：** (一小) 子类不能抛出比父类更严重的检查型异常。

**⚠️ 架构师警告：** 永远加上 `@Override` 注解！
这是一个安全扣。如果你手抖写错了方法名，编译器会直接报错拦住你，而不是让你在运行时一脸懵逼地发现多态没生效。

---

### 7. 🛑 避坑指南：多态的盲区 (Pitfalls)

以下三种情况，**不发生**多态（即：不看右边对象，只看左边引用）：

1. **static 方法：** 静态方法属于类，不属于对象。它们是编译期绑定的。

- _现象：_ 父类引用调用 static 方法，永远执行父类的代码。

2. **private 方法：** 私有方法不能被继承，更不可能被重写。
3. **final 方法：** 这里的 `final` 意思是“最终版本，禁止修改”。

---

### 8. 一句话总结

多态的 **必要性** 在于：
* **不是减少子类的代码，而是减少调用侧的代码**
* **可扩展性：新增类型时，老代码不用改**
* **统一接口：用一套代码处理多种类型**
* **解耦：调用者不需要知道具体类型**

简单说：多态让你写出"对扩展开放，对修改关闭"的代码。如果你的项目只有固定的几种情况，永远不会扩展，那确实用不用多态都行。但实际项目往往会不断增加新需求，这时多态的价值就体现出来了。

---
