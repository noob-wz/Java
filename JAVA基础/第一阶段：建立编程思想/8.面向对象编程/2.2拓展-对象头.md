可以将对象头看作一个特殊的、由 JVM 管理的 **结构体（struct）**

---

## 🔍 对象头 (Object Header) 的结构与作用

在 HotSpot JVM（最常用的 Java 虚拟机）中，对象头通常由两部分组成，共占 $64$ 位（$8$ 字节）或 $128$ 位（$16$ 字节），具体取决于 JVM 架构和是否开启指针压缩。

### 1. Mark Word (标记字段)

- **大小：** 通常 $64$ 位（$8$ 字节）。
- **作用：** 存储对象自身的运行时数据。它不是指针，但它包含与对象状态相关的所有信息，并且这些信息会随着对象在运行中的状态变化而变化。
- **存储内容：** 哈希码（HashCode）、GC 年龄（Age）、锁状态标志（Lock Status Flags）、线程持有的锁指针等。
  - **哈希码：** 对象的唯一编号
  - **GC 年龄：** 这个对象在内存里活了多久了（够老了就送去“老年代”）
  - **锁状态：** 现在有没有人正在占用这个对象。

### 2. Klass Pointer (类型指针/元数据指针)

- **大小：** $32$ 位（$4$ 字节）或 $64$ 位（$8$ 字节）。如果开启了 **指针压缩（Compressed Oops）**，它通常是 $32$ 位。
- **作用：** **引用变量。** 它指向方法区（或 Metaspace）中存储的 **类元数据（Class Metadata）**。
- **存储内容：** 存储该对象所属类在方法区中的 **起始地址**。通过这个地址，JVM 就能知道这个对象是哪个类的实例，从而可以查找其方法表（V-Table）和执行对应的实例方法。

## 💡 总结

你的理解是：对象头 $\rightarrow$ 变量 $\rightarrow$ 方法区地址。

这个流程是非常正确的，特指对象头中的 **Klass Pointer** 字段。正是这个指针建立了 **对象实例（在堆上）** 与 **对象模板（在方法区）** 之间的关键联系。

| 对象头部分        | 你的理解             | 实际作用                                  |
| :---------------- | :------------------- | :---------------------------------------- |
| **Klass Pointer** | **变量（存储地址）** | 存储了指向方法区中该类元数据的 **指针**。 |
| **Mark Word**     | (其他信息)           | 存储对象的运行时状态和锁信息。            |

因此，当 JVM 设置对象头时，它就是在对象的内存地址 $0\text{xA}1\text{B}2$ 处写入这个 $4$ 或 $8$ 字节的指针值，这个值就是方法区中 `BankAccount` 元数据的地址。
