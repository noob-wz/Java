如果我们要写 `Cat` 类和 `Dog` 类，你会发现它们有大量重复的代码（都有眼睛、鼻子、腿）。 作为架构师，我无法容忍代码重复。

下一步： 我们将进入 OOP 的第二大支柱 —— 继承 (Inheritance)。我们将学习如何通过“父子关系”来复用代码。

---

# 📘 架构师讲义：继承的本质与内存融合 (Inheritance & Memory Fusion)

### 1. 🐣 诞生背景：消灭重复 (The Why)

- **史前危机（Copy-Paste Hell）：**
  在没有继承的时代，如果游戏里有“战士”、“法师”、“弓箭手”，我们需要在三个类里重复写 `name`、`level`、`move()`。一旦要修改移动逻辑，必须修改 N 个文件，极易遗漏。
- **解决方案：** 将共性（属性和行为）上抽为 **父类 (SuperClass)**，让子类 **扩展 (extends)** 它。在架构师的字典里，**继承的初衷只有一个：消灭重复**

### 2. 🧬 核心定义：Is-A 关系

- **语法：** `class Child extends Parent { ... }`
- **语义：** **是一种 (Is-A)**。战士 **是** 英雄，猫 **是** 动物。
- **效果：** 子类自动拥有父类所有的属性和方法（除了构造器）。

### 3. ⚙️ 底层解剖：内存融合 (Memory Fusion) —— **本章重点**

这是继承最容易被误解的地方。请记住：**继承不是拼图，而是基因融合。**

#### ❌ 错误的认知（外部挂载）：

认为 `new Warrior()` 会生成两个对象：一个 `Hero` 对象在外面，一个 `Warrior` 指向它。
_(这是组合 Composition，不是继承)_

#### ✅ 正确的真相（内部融合）：

当 JVM 创建子类对象时，它会拿着父类和子类两张图纸，计算总大小，然后在堆内存中开辟**一块连续的、完整的空间**。

**🎨 ASCII 内存透视：**

```text
   代码：Warrior w = new Warrior(); (假设 Warrior 继承 Hero)

    【 堆内存 (Heap Address: 0x9999) 】 <--- 只有一个地址！
    +-----------------------------------------------+
    | [ 对象头 (Header) ]                            |
    +-----------------------------------------------+
    | :: 父类数据区 (Hero's Data) ::                |
    | - name: "亚瑟"                                |
    | - private money: 100  (真实存在，但在逻辑上被锁住)|
    +-----------------------------------------------+
    | :: 子类数据区 (Warrior's Data) ::             |
    | - rage: 99                                    |
    +-----------------------------------------------+
```

**结论：**

1. **物理连续：** 父类属性和子类属性是邻居，住在同一个对象体内。图中有隔断，实际上父类和子类属性是 **无缝衔接** 的。
2. **生命周期绑定：** 作为一个整体对象，生则同生，死则同死。

### 4. 🔗 初始化链路：先父后子 (Initialization Chain)

由于父类数据位于对象的“内核”，必须先初始化内核，外壳才能依附。这也是为什么构造器章节中提到`super()`必须存在的原因：**子类构造器第一行必须调用 `super()`**

- **规则：** 子类构造器的**第一行**必须调用父类构造器 `super()`。
- **编译器行为：** 如果你不写，编译器自动塞一个 `super()`；如果父类没有无参构造，你必须手动写 `super(参数)`。

#### 【陷阱】

这里有一个面试常考的 **“命名冲突”** 场景。 如果子类和父类都有一个叫 `name` 的变量，`this.name` 到底听谁的？

这叫做 **变量遮蔽** ：

```java
class Hero {
    public String name = "老英雄";
}

class Warrior extends Hero {
    // ⚠️ 子类非要搞个同名的
    public String name = "小战士";

    public void test() {
        // 1. 就近原则：this 优先找子类自己
        System.out.println(this.name);  // 输出："小战士"

        // 2. 只有用 super 才能强行回溯到父类那一层
        System.out.println(super.name); // 输出："老英雄"
    }
}
```

> **说明：** 只有当你自己也定义了一个同名变量时，为了区分，才需要特意把 this 换成 super，而且需要注意的是 super 不是指针，而只是一个指令：跳过子类数据区。

### 5. 🛡️ 权限悖论：有的东西在你肚子里，但你不能碰

这就是 **Encapsulation (封装)** 与 **Inheritance (继承)** 的博弈。

- **场景：** 父类有 `private int money`。
- **现状：**

  - **内存上：** 子类对象里绝对有这 4 个字节存钱。
  - **代码上：** 子类方法里写 `this.money` 会报错。

- **原理：** `private` 是编译器的**“逻辑锁”**。虽然数据在内存里融合了，但访问权限没有融合。
- **解决：** 必须通过父类提供的 `public/protected` 方法（血管）来间接操作这部分数据。

### 6. ⚔️ Java 的独特性：单继承 (Single Inheritance)

- **规定：** 一个孩子只能有一个亲生父亲 (`extends` 后面只能跟一个类)。
- **原因：** 为了避免 **“钻石问题” (Diamond Problem)**。如果两个爸爸都有 `move()` 方法，且逻辑不同，孩子该听谁的？Java 为了架构的简单稳定，砍掉了多继承功能（但用接口 Interface 弥补了这点，后续会讲）。

---

**下一步动作：**
我们已经造出了包含父类基因的子类对象。
现在，如果父类 `Hero` 定义了 `move()` 是“走”，但子类 `Warrior` 想要“跑”，子类 `Bird` 想要“飞”。
同一个方法名，在不同子类身上表现出不同行为 —— 这就是 **多态 (Polymorphism)**。
