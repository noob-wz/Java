### 💡 1. 第一性原理：为什么需要继承？

想象你在开发一个 **“绝地求生” (PUBG)** 游戏。

你需要写三种角色：

1. **玩家 (Player)**：有血条、会跑、会跳、**会开车**。
2. **机器人 (Bot)**：有血条、会跑、会跳、**会自动瞄准**。
3. **怪物 (Monster)**：有血条、会跑、会跳、**会咬人**。

**❌ 菜鸟写法 (Copy-Paste)**：
你写了三个类，每个类里都写了一遍 `int hp;`，`void run() {...}`。

* **后果**：如果在某天，你想把“跑”的逻辑改成“加速跑”，你得去三个文件里改三次。一旦漏了一个，Bug 就来了。

**✅ 大厂架构师写法 (Inheritance)**：
提取公因式。找到它们共同的“基因”。

* 定义一个父类 `Character`（角色）：负责写 `hp`、`run()`、`jump()`。
* 让 `Player`、`Bot`、`Monster` **继承** `Character`。
* **好处**：代码只写一次，所有子类自动获得这些能力。**复用 (Reuse)** 是继承的核心价值。

---

### 🧱 2. 语法微创：`extends` 关键字

Java 使用 `extends`（扩展）关键字来实现继承。注意，它不叫 `inherits`，意味着子类是对父类的**延伸和扩展**。

```java
// 1. 父类 (Parent / Super Class)
// 👴 存放共性
public class Character {
    private int hp = 100;
    public void run() { 
        System.out.println("奔跑中..."); 
    }
}

// 2. 子类 (Child / Sub Class)
// 👶 自动拥有父类的 public/protected 成员
public class Player extends Character {
    // 这里的 hp 和 run() 虽然没写，但其实已经有了！
    
    // 🔧 扩展自己独有的功能
    public void drive() {
        System.out.println("老司机开车了");
    }
}

```

---

### 📊 3. 内存机制：子类对象长什么样？(核心！)

这是很多工作 3 年的程序员都容易搞错的地方。

**❓ 面试题**：当你执行 `new Player()` 时，内存里到底创建了几个对象？

* A. 两个对象（一个 `Character` 对象，一个 `Player` 对象，Player 引用着 Character）。
* B. 只有一个对象（`Player` 对象），但它肚子里包着 `Character` 的属性。

**✅ 正确答案是 B！**

**ASCII 内存透视图**：

当你 `new Player()` 时，堆内存里**只有一个对象**，但是这个对象内部被划分成了不同的“层”。

```text
    堆内存 (Heap)
   +---------------------------------------+
   |  new Player()  (地址: 0x99)           |
   |                                       |
   |  +---[ super: Character 部分 ]-----+  |
   |  |  hp = 100                       |  |  <-- 父类的属性
   |  |  (如果是 private，子类只能看不能摸)|  |
   |  +---------------------------------+  |
   |                                       |
   |  +---[ this: Player 部分 ]---------+  |
   |  |  nickname = "Gem"               |  |  <-- 子类自己的属性
   |  |  rank = "Gold"                  |  |
   |  +---------------------------------+  |
   +---------------------------------------+

```

**关键结论**：

1. **一体性**：父子属性融合在同一个对象里。
2. **super 引用**：并没有一个真正的对象叫 `super`。`super` 只是一个指向当前对象中“父类特征区域”的虚拟指针。

---

### 💼 4. 大厂 SOP：单继承原则与 Diamond Problem

Java 的继承有一条**铁律**：
**一个类只能有一个直接父类 (Single Inheritance)**。
`class Son extends Father, Mother` ❌ **是绝对禁止的！**

**Why? (设计哲学)**：
为了避免 **“钻石问题” (Diamond Problem)**。

假如 Java 允许双重继承：

1. `Father` 有个方法 `work()`（修车）。
2. `Mother` 有个方法 `work()`（画画）。
3. `Son` 继承了两者。
4. 当你调用 `Son.work()` 时，**JVM 疯了**：我到底该去修车还是画画？

> **💡 替代方案**：如果你真的需要继承多个来源的能力（比如既像父亲又像母亲），Java 提供了 **接口 (Interface)** 机制（后续会讲）。

---

### ⚔️ 5. 实战避坑：父类的 Private 属性能继承吗？

这是一个经典的文字游戏。

**场景**：

```java
class Father {
    private int money = 1000000; // 私房钱
}

class Son extends Father {
    public void showMoney() {
        // System.out.println(money); // 👈 这里会报错吗？
    }
}

```

**解析**：

1. **能继承吗？**
* **能！** 从内存图上看，`money` 确实在 `Son` 对象里（在 super 那个区域占了空间）。


2. **能访问吗？**
* **不能！** 虽然钱在你身上，但那是你爸装在“保险箱”（Private）里的。你确实拥有它（占用了内存），但你没有钥匙（访问权限）。



**💡 怎么解决？**
让父类提供 `public int getMoney()` 方法。既然继承了父类，你也自然继承了这个 `getMoney()` 方法，通过方法就能拿到了。

---

### 📝 6. 课后思考

如果父类和子类有**同名的属性**，会发生什么？

```java
class Father {
    int age = 50;
}

class Son extends Father {
    int age = 20; // ⚠️ 属性遮蔽 (Hiding)

    public void say() {
        System.out.println("我是儿子，今年 " + age);
        // ❓ 问题：如果我非要在这里打印出爸爸的 50 岁，该怎么写？
    }
}

```

**请回复你的代码（如何访问被遮蔽的父类属性），或者回复 “super” 来详细了解这个关键字的魔法！**