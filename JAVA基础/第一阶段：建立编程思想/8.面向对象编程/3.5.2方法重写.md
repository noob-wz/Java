# ☕ Java 核心解密：方法重写 (Override) —— 多态的灵魂

**核心定义**：
在子类中，定义了一个与父类**方法签名（名称 + 参数列表）完全一致**的方法。
**目的**：
**“挂羊头，卖狗肉”**。调用者看着引用类型是父类（羊头），但实际执行的是子类的新逻辑（狗肉）。

---

## 🎬 1. 全新剧本：支付系统的进化

为了让你更有体感，我们用一个**支付系统**的案例。

* **父类（旧标准）**：`CreditCard`（普通信用卡），刷卡扣全款。
* **子类（新标准）**：`GoldCard`（金卡），刷卡打 8 折。

```java
// 1. 父类：普通卡
class CreditCard {
    // 祖传手艺：扣款
    public void pay(double amount) {
        System.out.println("普通卡扣款：" + amount);
    }
}

// 2. 子类：金卡
class GoldCard extends CreditCard {
    // ⚠️ 重写 (Override)：手艺改良，打8折
    @Override
    public void pay(double amount) {
        System.out.println("金卡扣款：" + (amount * 0.8));
    }
}

// 3. 运行测试
public class World {
    public static void main(String[] args) {
        // 向上转型：在编译器眼里，它是一张 CreditCard
        CreditCard myCard = new GoldCard();
        
        // 关键时刻：执行的是谁的 pay？
        myCard.pay(100); 
    }
}

```

**输出结果**：

```text
金卡扣款：80.0

```

---

## 🔪 2. 核心解剖：底层发生了什么？

为什么编译器明明看到 `myCard` 是 `CreditCard` 类型，最后却跑了 `GoldCard` 的代码？
这涉及到了 Java 的**动态绑定 (Dynamic Binding)** 机制。

我们把 JVM 想象成一个精密的钟表匠，看看他在**类加载阶段**对这两个类做了什么。

### 2.1 虚方法表 (vtable) 的偷梁换柱

每个类在方法区都有一个**虚方法表 (vtable)**，它像一个“函数指针数组”，记录了该类所有方法的实际入口地址。

#### 📜 第一阶段：父类 (CreditCard) 的 vtable 生成

JVM 加载 `CreditCard` 类，发现它有一个 `pay` 方法，地址在 `0x111`。

| 索引 | 方法名 | 指向地址 | 说明 |
| --- | --- | --- | --- |
| ... | ... | ... | ... |
| [5] | **pay()** | **➡️ 0x111** | 指向 `CreditCard.pay` 的代码 |

#### 📜 第二阶段：子类 (GoldCard) 的 vtable 生成

JVM 加载 `GoldCard` 类。

1. **复制**：先把父类的 vtable 抄过来（此时 `pay` 指向 `0x111`）。
2. **检查**：发现 `GoldCard` 自己也定义了一个 `pay` 方法（地址 `0x222`），且签名和父类一模一样。
3. **覆盖 (Override)**：**JVM 毫不留情地擦掉了 `0x111`，填入了 `0x222`。**

| 索引 | 方法名 | 指向地址 | 说明 |
| --- | --- | --- | --- |
| ... | ... | ... | ... |
| [5] | **pay()** | **➡️ 0x222** | **⚠️ 地址变了！指向 `GoldCard.pay**` |

### 2.2 运行时的“查表游戏”

当代码执行 `myCard.pay(100)` 时：

1. **指令**：`invokevirtual`（JVM 说：去查表吧）。
2. **找人**：JVM 找到堆内存中的 `myCard` 对象，发现它的实际身份是 **GoldCard**。
3. **查表**：JVM 拿出 `GoldCard` 的 vtable。
4. **定位**：找到 `pay()` 方法的槽位（索引 5）。
5. **执行**：里面的地址是 **0x222**。于是，CPU 跳转执行金卡的打折逻辑。

> **形象比喻**：
> 编译器只负责给你一个**按钮**（父类的方法定义），但在生产线上，工人偷偷把这个按钮背后的**电线**（方法地址），接到了一个新的灯泡（子类方法）上。你一按按钮，亮的是新灯泡。

---

## ⚖️ 3. 重写的四大法则（契约精神）

重写不是乱写，子类必须遵守严格的**契约**。编译器会严格审查 `@Override`。

可以概括为：**“两同、两小、一大”**。

### ✅ 法则一：两同 (签名必须一致)

* **方法名**必须相同。
* **参数列表**必须相同。
* *如果不相同，那叫“重载 (Overload)”，不是重写。*

### ⬇️ 法则二：两小 (返回类型与异常)

为了保证“里氏替换原则”（子类必须能完美替换父类），子类不能搞出父类处理不了的意外。

1. **返回类型更小（或相同）**：
* 父类返 `Number`，子类可以返 `Integer`（Integer 是 Number 的儿子）。
* *你想要数字，我给你个整数，没问题。*


2. **抛出异常更小（或相同）**：
* 父类抛 `Exception`，子类可以抛 `IOException`，或者**不抛异常**。
* *父类说“可能会爆炸”，子类说“只会冒烟”或者“很安全”，调用者都能接受。*



### ⬆️ 法则三：一大 (访问权限)

* **访问权限必须更大（或相同）**。
* 父类是 `protected`，子类可以是 `public`，但绝不能是 `private`。
* *父亲对外承诺“大家都能用”，儿子不能把门关起来说“只有我自己能用”。这违背了契约。*

### 🚫 法则四：隐形禁区 (不能重写的情况)

有些方法是**“被锁死”**的，vtable 里不会发生覆盖：

1. **`final` 方法**：明确禁止篡改。
2. **`static` 方法**：属于类，不属于对象，不进 vtable。
3. **`private` 方法**：子类根本看不见，想重写也找不到门（这叫定义了新方法，不叫重写）。

---

## 🚀 4. 总结

关于**重写 (Override)**，请记住这张全新的“档案卡”：

| 维度 | 核心描述 |
| --- | --- |
| **本质** | **行为的进化**。子类继承了父类的“壳”，但替换了“核”。 |
| **底层实现** | **vtable 的地址覆盖**。子类虚方法表中，父类方法的旧地址被新地址抹去。 |
| **发生阶段** | **运行期 (Runtime)**。只有运行的时候，才知道对象到底是谁，该查哪张表。 |
| **关键指令** | `invokevirtual` (它是实现多态的基石)。 |
| **核心口诀** | **外壳看父类（编译通过），内核看子类（运行执行）。** |
