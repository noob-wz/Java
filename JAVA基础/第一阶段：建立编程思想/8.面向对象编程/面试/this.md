## 问题 1: 代码模拟：java User u1 = new User("张三"); User u2 = u1; u2.name = "李四"; 既然“对象的方法存在方法区，全局共享”，那么当 u1.getName() 执行时，JVM 怎么知道它应该返回“张三”而不是“李四”？它凭什么区分不同的对象数据？

因为特定对象的堆内存中有个对象头，对象头中存在类型指针指向方法区中的对应元数据，让对象“找到了方法在哪”，接着 JVM 在执行 u1.getName() 时，偷偷做了一个动作：它**把 u1 指向的地址，作为第一个参数传给了方法** 。这份唯一的方法，就可以反过来再找到特定对象的“数据”

**代码背后的真相：**

- 你看到的：`public String getName() { return name; }`
- JVM 看到的：`public String getName(User this) { return this.name; }`

这个 `this` 就是那根“回力镖”。代码执行时，通过这个隐藏的 `this` 重新杀回堆内存，精准地抓取属于 u1 的那份 name。

🎨 ASCII 动态寻址图：

```text
【 栈帧：getName() 】            【 堆：User 对象 】
+---------------------+        +-----------------------+
| 局部变量表           |        |    User Instance      |
| [0]: this ----------+-------->|  - name: "李四"        |
+---------------------+        |  - age: 25            |
                               +-----------------------+
       ^
       | (JVM 自动把 u1 的地址塞进了这个 [0] 号槽位)

```
