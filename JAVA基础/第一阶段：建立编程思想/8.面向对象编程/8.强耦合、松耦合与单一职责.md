# 📝 强耦合 vs 松耦合与单一职责

这份笔记旨在解释面向对象设计中的三个核心概念：**强耦合 (Tight Coupling)**、**松耦合 (Loose Coupling)** 以及 **单一职责原则 (SRP)**。

---

## 🛑 第一部分：反面教材 (强耦合 & 违反 SRP)

**场景描述：**
我们需要打印圆形的面积。
在**强耦合**的设计中，打印机（PassObject）不只负责打印，还负责“制造”圆形。这导致打印机和特定的圆**焊死**在了一起。

### 1. 概念定义

- **强耦合 (Tight Coupling)：** 类 A 在内部直接 `new` 类 B 的对象。类 A 极度依赖类 B 的具体实现。如果 B 改了构造方法，A 必须跟着改。
- **违反单一职责 (Violating SRP)：** `PassObject` 既要负责**业务逻辑**（打印），又要负责**数据创建**（new Circle）。一个类承担了多余的角色。

### 2. 完整代码示例 (BadDesign.java)

```java
// 文件名：BadDesign.java

// 1. 定义数据模型
class BadCircle {
    double radius;

    public BadCircle(double radius) {
        this.radius = radius;
    }

    public double findArea() {
        return Math.PI * radius * radius;
    }
}

// 2. 定义业务类 (这是反面教材的核心)
class BadPassObject {

    // 方法职责不纯粹：既负责创建，又负责打印
    public void printArea() {
        // ❌ 强耦合核心罪证：
        // 在方法内部“写死”了创建具体的对象。
        // 后果：这个方法只能打印半径为 2.5 的圆，无法复用，无法改变。
        BadCircle c = new BadCircle(2.5);

        System.out.println("圆的面积是：" + c.findArea());
    }
}

// 3. 程序的入口
public class BadDesign {
    public static void main(String[] args) {
        BadPassObject obj = new BadPassObject();

        // 调用者无权决定打印哪个圆，只能听任 obj 内部的安排
        obj.printArea();
    }
}

```

---

## ✅ 第二部分：正面教材 (松耦合 & 遵守 SRP)

**场景描述：**
我们将“制造圆”的权利移交给外部（Main），`PassObject` 只作为一个纯粹的工具，给它什么圆，它就打印什么圆。

### 1. 概念定义

- **松耦合 (Loose Coupling)：** 类 A 不自己创建类 B，而是通过**参数**接收类 B（依赖注入）。A 和 B 像 USB 接口一样即插即用。
- **单一职责 (SRP)：** \* `Circle` 只负责数据和计算。
- `PassObject` 只负责打印。
- `Main` 负责组装。
- 各司其职，互不干扰。

### 2. 完整代码示例 (GoodDesign.java)

```java
// 文件名：GoodDesign.java

// 1. 定义数据模型 (保持专注，只管算面积)
class Circle {
    double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double findArea() {
        return Math.PI * radius * radius;
    }
}

// 2. 定义业务类 (工具人，只管打印)
class PassObject {

    // ✅ 松耦合核心体现：
    // 通过参数 'Circle c' 传入对象。
    // 含义：我不管圆是哪里来的，只要你传给我，我就能打。
    public void printArea(Circle c) {
        // 这里的 c 是外部传进来的引用（钥匙）
        System.out.println("半径为 " + c.radius + " 的面积是：" + c.findArea());
    }
}

// 3. 程序的入口 (控制中心/组装车间)
public class GoodDesign {
    public static void main(String[] args) {
        // 步骤 1：创建业务工具
        PassObject tool = new PassObject();

        // 步骤 2：创建数据 (在这里我们可以随意决定圆的大小)
        Circle c1 = new Circle(2.5);
        Circle c2 = new Circle(10.0);

        // 步骤 3：注入依赖 (把圆交给工具)
        // 即使 c1 和 c2 数据不同，tool 都可以处理，这就是松耦合带来的复用性
        tool.printArea(c1);
        tool.printArea(c2);
    }
}

```

---

## 📊 第三部分：核心对比总结表

| 维度         | 强耦合 (Bad Code)                                    | 松耦合 (Good Code)                               |
| ------------ | ---------------------------------------------------- | ------------------------------------------------ |
| **代码特征** | 在方法内部 `new Circle(...)`                         | 在方法参数中声明 `(Circle c)`                    |
| **灵活性**   | **极低**。只能处理写死的数据。                       | **极高**。可以处理任何传入的数据。               |
| **修改成本** | 改圆的半径需要修改业务类代码。                       | 改圆的半径只需修改入口(`main`)，业务类无需改动。 |
| **测试难度** | 难。无法单独测试打印功能（必须连带着测试圆的创建）。 | 易。可以传入一个模拟的圆进行测试。               |
| **SRP 原则** | **违反**。业务类管得太宽（负责创建+使用）。          | **遵守**。业务类只负责使用，创建权上交。         |

> **笔记结语：**
> 只要在工具类的方法内部看到 `new 具体类()`，就要警惕是否引入了**强耦合**。优秀的面向对象设计，总是倾向于**“从外部传入对象”**，而不是**“在内部生产对象”**。
