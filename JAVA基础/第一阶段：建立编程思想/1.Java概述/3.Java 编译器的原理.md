# 一、编译器的内部工作原理

## 工作流程：先解码（Input），后生成（Output）

这是一个多阶段的**转换**过程，而不是一次**拆分**。

### 阶段一：解码与解析（统一为内部逻辑结构）

1.  **动作：** `javac` 启动。
2.  **解码 (Decoding)：** 编译器读取磁盘上的 `Hello.java` 文件（比如 UTF-8 二进制序列）。它**逐字逐句**地解码这些字节，将其转换成 Java 内部的统一 Unicode 字符（如 UTF-16）。

    - **解码过程：** javac 读取 .java 文件的过程，是一个 **“二进制翻译”** 的过程。
      - 它读取磁盘上的 UTF-8 二进制序列（例如：E4 B8 AD，代表“中”）。
      - 它将其“解码”并“重新编码”为 Java 内部在内存中使用的 UTF-16 二进制序列（例如：4E 2D）。
    - **结论：** 这一步并不是从“二进制”变成了“字符”，而是从**一种二进制编码（UTF-8）** 转换成了**另一种二进制编码（UTF-16）**，直接保存在 JVM 内存中。

3.  **解析 (Parsing)：** 编译器**消费**这些字符，将它们组合成有意义的“词汇”（如 `public`, `class`, `System`, `+`）。
4.  **构建 (Building)：** 编译器会进行语法检查，同时构建出一个 **“抽象语法树”**
    **阶段一的最终产物：** `javac` 在内存中得到了一个**与编码无关的、纯粹的逻辑树（AST）**。

> **关键点：** 此时，原始的 UTF-8 二进制文件**已经被丢弃**。`javac` 不再关心它了。它现在只关心这个代表了您程序逻辑的“树”。

---

#### 阶段二：生成（将逻辑树转化为 .class 文件）

现在，编译器开始 **“遍历”** 它在阶段一中构建好的逻辑树（AST），并**生成**一个全新的文件（`.class` 文件）。

这个生成过程是**双轨并行**的，但都源自同一个 AST：

1.  **遍历到“数据节点” (Data)：**

    - 当编译器在树上遇到 **“数据”（代码中所有用到名字和常量如字符串字面量，如 `"Hello"`，或者类名 `Hello`，方法名 `main`）**，它会 **“生成”** 这些数据对应的 **二进制序列** ，并将它们写入 `.class` 文件的 **常量池（Constant Pool）** 部分。

2.  **遍历到“逻辑节点” (Instructions)：**
    - 当编译器在树上遇到 **“逻辑”** （如 `System.out.println()`），它会 **“生成”** 这个逻辑对应的 **Java 字节码指令**（`getstatic`, `ldc` 等），并将这些 **二进制指令** 写入 `.class` 文件的**代码区（Code Attribute）**。

### 总结

原始的 UTF-8 文件**没有**被“拆分”成两半，而是**转换**：

1.  原始的 UTF-8 (文件) $\rightarrow$ **首先** 被**解码并解析**为 $\rightarrow$ 内存中的**逻辑树 (AST)**。
2.  内存中的逻辑树 (AST) $\rightarrow$ **然后** 被 **“编译生成”** $\rightarrow$ 一个全新的 `.class` 文件（其中包含**数据二进制**和**指令二进制**）。

这是一个严格的 **“先输入，后输出”** 的顺序过程。

# 二、Java 编译器的两种“二进制”产物

**编译转化**是一个**数据与指令相分离**的过程，本质上也就是是**数据（Data）** 与**指令（Code）** 的区别这两种二进制**在 `.class` 文件中被严格分离** ，以确保程序的数据和逻辑结构清晰。

## 核心区别：数据 vs. 指令

### 1. Unicode 文本（码点值）的二进制

这部分二进制代表了程序运行所需的**静态数据和名称**。

- **存储内容：** 字符、字符串字面量 (`"Hello"`)、类名、方法名、字段名等。
- **二进制形式：** 存储的是这些字符在 Unicode 标准中的**码点值**的二进制表示（Java 使用 **Modified UTF-8** 格式存储）。
  - **作用：** 它是**程序数据**的身份标识。当 JVM 需要加载类名或打印字符串时，它会从这里读取。
- **存储空间（在 `.class` 文件中）：**
  - 它们被放在 `.class` 文件的 **常量池（Constant Pool）** 部分。

### 2. Java 字节码指令的二进制

这部分二进制代表了程序执行所需的**操作逻辑**。

- **存储内容：** 一系列 JVM 能够理解和执行的指令码（Opcode）。例如，`getstatic`, `ldc`, `invokevirtual` 等。
- **二进制形式：** 每个指令都对应一个 1 字节或多字节的**二进制操作码**。这个操作码的二进制序列被解释为“执行某个操作”，而不是“代表某个字符”。
  - **作用：** 它是**程序逻辑/代码**的载体。
- **存储空间（在 `.class` 文件中）：**
  - 它们被放在 `.class` 文件中每个方法结构下的 **指令** 部分。

---

## 总结：存储空间的彻底分离

在 `.class` 文件内部，这种结构是清晰而严格分离的：

| 特性         | **Unicode 码点二进制（数据）** | **字节码指令二进制（指令）**                   |
| :----------- | :----------------------------- | :--------------------------------------------- |
| **存储位置** | **常量池 (Constant Pool)**     | **方法代码区 (Code Attribute)**                |
| **表示对象** | 字符的身份（unicode 数字）     | 动作或操作（Opcode）                           |
| **存储目的** | 存储程序所需的**名称、字符串** | 存储程序所需的**逻辑和步骤**，包含基本类型数据 |

在 JVM 加载 `.class` 文件并保存到方法区后，这两部分数据虽然可能在物理上是连续的，但在逻辑上仍然是**严格隔离**的。指令只会流向执行引擎，而数据则在需要时被指令引用和操作。
