### 一、了解一种 Java 在中文版 Windows 系统下编译时很常见的编码问题

> **问题：** 假如我在 windows 系统上，有这样一个 Hello.java。在该代码文件目录下的命令行进行编译，会提示我编码 GBK 的不可映射字符

```java
// 这是java的快速入门，演示java的开发步骤

// 以下对代码进行详细说明：
// 1. public class Hello 表示Hello是一个public(公有)类型的类
// 2. Hello {} 大括号代表类的开始和结束
// 3. public static void main(String[] args) 代表的是主方法，它是程序执行的入口
// 4. main(String[] args) {} 大括号代表方法的开始和结束
// 5. System.out.printlin("hello, world!"); 表示输出"hello, world!"到屏幕
// 6. ;分号表示语句的结束

public class Hello {
    public static void main(String[] args) {
        System.out.println("hello, world!");
    }
}
```

#### 错误原因分析

这个错误的根本原因在于**编码不一致**：

1. 源文件编码 `Hello.java`： 在编辑器（如 VS Code, Notepad++, Sublime Text 等）中编写代码时，通常会以更通用的 `UTF-8` 格式保存文件。
2. **Windows 命令行默认编码**： 在中文版的 Windows 系统中，命令行（CMD 或 PowerShell）运行的 javac 编译器，默认使用的字符编码是 **GBK (或 GB2312)**。
3. 冲突： 当 javac 编译器尝试用 GBK 编码去读取您文件中包含的 **中文注释** 或 **中文字符串** 时，发现这些 UTF-8 编码的字符无法在 GBK 编码表中找到对应的映射，因此就会报错：`编码 GBK 的不可映射字符`。

#### 正确理解

| 过程           | 如何理解？                                                                                                                        |
| :------------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| **编辑器保存** | 编辑器用 **UTF-8 编码**记录，然后转化成 **二进制**。                                                                              |
| **命令行执行** | 在命令行执行，** 编译器 `javac` 读取的是文件中的原始 $0$ 和 $1$ 序列。**。                                                        |
| **失败原因**   | **问题不在于编译器“读”不到二进制，而在于它在“读”到二进制后，使用了错误的“翻译规则”（GBK）来将它们还原成字符，从而导致翻译失败。** |

#### 解决方案

##### 第一种：指定编码方式

解决这个问题的方法很简单，在程序编译的时候，**明确告知`javac`编译器源文件使用的是`UTF-8`** 。只要 **使用 javac 命令的 -encoding 选项** 就可以：`javac -encoding utf-8 Hello.java` 。

加上这个参数后，`javac` 就会使用 `UTF-8` 来读取和编译你的源文件，从而避免了编码错误

##### 第二种：编辑器设置文件编码

在编辑器中设置文件编码和命令行编码一致，比如 GBK。

### 二、文本存储的二进制 VS 程序设计的二进制

| 区别             | 文本存储的二进制 (Encoding Binary)                                                     | 程序执行的二进制 (Execution Binary)                                                    |
| :--------------- | :------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------- |
| **作用**         | **记录文件内容**。将字符（如字母、汉字）转化为计算机可以存储和传输的 $0$ 和 $1$ 序列。 | **记录指令和逻辑**。将程序代码的逻辑（如加法、循环）转化为 CPU 或 JVM 可以执行的指令。 |
| **发生在何时**   | **编辑器保存文件时**。只要是文本文件，无论内容是什么（代码、文章、日志），都会发生。   | **编译器（或解释器）工作时**。对源文件进行语法分析和指令转换。                         |
| **示例**         | `public` 转化成 UTF-8 编码的 $0$ 和 $1$ 序列。                                         | Java 源代码中的 `a = b + 1;` 被转化为 **Bytecode**                                     |
| **与编码的关系** | **直接相关。** 如果编码（字典）错了，内容就会乱码。                                    | **间接相关。** 编译前需要正确解码源代码，编译后生成指令码。                            |

#### 总结核心差异

编辑器做的只是将**文本字符**转化为**存储字符的二进制**；而编译器做的是将**程序指令**转化为**执行指令的二进制**。这是两个完全不同目的的转化过程。

### 三、详细解释：Java 的开发流程（JAVA 开发原理）

我们用 Java 的流程来清晰说明这两步：

#### **阶段一：文本存储（编码问题发生在这里）**

1.  **动作：** 您在编辑器中输入 `public class Hello { ... }` 和中文注释。
2.  **编码转化：** 当您点击 **“保存”** 时，编辑器根据您选择的编码（如 **UTF-8**）规则，将您输入的**每一个字符**（包括代码和注释）都转化为一串 $0$ 和 $1$ 序列，并写入磁盘上的 `Hello.java` 文件。
3.  **结果：** `Hello.java` 文件现在是**文本文件**，它的内容是以 UTF-8 规则存储的二进制数据。

- _前面讨论的 **GBK/UTF-8 编码问题**，就发生在下一步，即编译器试图读取这个文件时。_

#### **阶段二：编译（转化为 JAM 指令）**

1.  **动作：** 您在命令行运行 `javac Hello.java`。
2.  **解码：** 编译器首先用操作系统的文本编码（例如 `-encoding utf-8`）**读取并解码** `Hello.java` 文件。此时，编译器不再关心原始文件是用 UTF-8 还是 GBK 编码的，**会将原来的二进制编码（UTF-8/GBK 等） 转换成了 Java 支持的二进制编码（UTF-16）。**
3.  **编译转化：** 接着，编译器**检查代码的语法是否正确，并理解程序逻辑**。如果正确，将其解析成逻辑树（二进制），然后遍历逻辑树进行数据和指令分离。
    - 将 **指令** 转化为 **Java 字节码 (Bytecode)（本质就是二进制）**，写入.class 文件的代码区
    - 将 **数据** 写入.class 文件的常量区
4.  **结果：** 两者组合成最终的 `.class` 文件
    - 以上过程中，在“保存”之后，所有过程基本上都是计算机在操作二进制数据，人看到的一些图形化字符都是通过工具进行转化的

#### **阶段三：运行（Bytecode 的执行）**

在命令行运行 java Hello 时，JVM 启动，JVM 将字节码**实时翻译成当前操作系统能够理解的机器码**

##### 一句话总结基本原理

**当在命令行输入`javac Hello.java`，编译器会先解码该文件并转化成 `java` 支持的 `utf-16` 二进制文件；编译器会检查语法错误，理解程序逻辑；然后会根据这个文件生成一个逻辑树，遍历逻辑树进行数据和指令分离，数据存储在.class 文件的常量区，指令会转化成 java 字节码存储在.class 文件的代码区，两者就构成了最终的.class 文件。运行时，JVM 再实时把.class 字节码文件转化成对应操作系统能理解的机器码**
