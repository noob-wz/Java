想象一下，你写好的 Java 代码（`.java`）经过编译，变成了一张**精密的工程图纸**（`.class`文件）。

---

### 📝 Java 运行时笔记：从图纸到实物的全过程

#### 第一阶段：图纸上的“清单” (静态常量池)

当你编译代码时，编译器并不知道程序运行时的电脑内存长什么样。它不知道内存地址 `0x1234` 是空的还是满的。

所以，在生成的 `.class` 文件（图纸）里，编译器做了一个聪明的决定：**凡是涉及到外部的东西（引用的其他类、方法、变量名），一律只写名字，不写地址。**

这张图纸上有一个专门的区域，叫 **静态常量池 (Static Constant Pool)**。
它就像图纸边缘的**“材料清单”**，上面写着：

- #1: “我要用一个叫 `java.lang.String` 的类”
- #2: “我要调用一个叫 `println` 的方法”
- #3: “我要用数字 `10`”

此时，这些 #1、#2 就是 **符号引用**。它们只是**描述性的符号**（比如写着“一把锤子”的便利贴），而不是真正的内存地址。

---

#### 第二阶段：进驻工地 (运行时常量池 & 方法区)

现在，JVM（Java 虚拟机）启动了，它就像一个**施工队**。

1.  **加载图纸：** JVM 读取 `.class` 文件，把它加载到内存中一个叫 **方法区 (Method Area)** 的地方。这里是存放所有“公共设施”和“图纸信息”的区域。
2.  **建立工作台：** JVM 把图纸上的“静态常量池”复制一份到内存里，变成了 **运行时常量池 (Runtime Constant Pool)**。

**注意：** 此时，运行时常量池里的 #1 仍然写着“java.lang.String”（符号引用）。虽然图纸进内存了，但我们还不知道 `String` 这个类真正放在内存仓库的哪个架子上。

---

#### 第三阶段：工人开工 (栈 vs 堆)

现在，施工开始了。JVM 创建了一个**线程**（工人），工人有一个私人的、贴身的工作腰包，这就叫 **栈 (Stack)**。

工人开始逐行执行指令，这时会出现两种截然不同的情况：

**情况 A：处理简单工具（基本数据类型）—— 不需要查表**

- **指令：** `int i = 10;`
- **动作：** 工人直接从图纸里看到 `10`，或者直接从口袋里掏出 `10`。
- **内存：** 这个 `10` 直接放在工人的**栈（局部变量表）**里。
- **关键点：** 因为 `int` 太简单、太常用了，工人随身携带，**不需要**去查“材料清单”，也不需要去仓库找。**所以，基本数据类型跟符号引用没关系，它在栈里自给自足。**

**情况 B：寻找大型设备（引用类型）—— 必须查表**

- **指令：** `String s = ...;` 或者调用 `s.length()`。
- **动作：** 工人发现指令里写着：“去用 #1 号材料”。
- **查表：** 工人拿出“运行时常量池”这张清单，看到 #1 写着 “java.lang.String”。
- **解析 (Resolution)：**
  - 这是一张便利贴（符号引用），工人不知道 `String` 在哪里。
  - 于是，JVM 停下来，去巨大的 **堆 (Heap)** 或 **方法区** 里寻找 `String` 类到底加载在哪个内存地址（比如 `0x9999`）。
  - **替换：** 找到后，JVM 划掉清单上“java.lang.String”这几个字，把真实的内存地址 `0x9999` 写上去。
- **结果：** 此时，符号引用变成了 **直接引用**（真实的内存指针）。
- **后续：** 下次工人再遇到 #1，直接看清单，上面已经是地址 `0x9999` 了，直接去那里拿数据，不用再找了。

---

### 🚀 总结：一条线串起所有问题

1.  **静态常量池**是编译时图纸上的清单，**运行时常量池**是加载到内存后的清单。
2.  **符号引用**是清单上写的“名字”（便利贴），**直接引用**是查找到的“实际地址”（GPS 坐标）。
3.  **栈**是工人的腰包，处理简单的 `int` 等基本类型，不需要查清单（不需要符号引用）；
4.  **堆/方法区**是公共仓库，处理复杂的对象和类，工人必须通过清单上的**符号引用**找到它们的地址，将其解析为**直接引用**，才能访问。

这就是 Java 如何在不知道内存地址的情况下，通过“名字”找到“实物”的全过程。
