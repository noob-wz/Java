选择结构允许程序根据某个条件是否成立来决定执行哪一部分代码。它使程序能够做出“决策”。

## ➡️ 基本类型：`if...else` 语句

这是最常见的选择结构，根据一个**布尔表达式**（判断结果为 **真** 或 **假** 的表达式）来选择执行路径。（在 C 语言 中，条件表达式不必非得是布尔表达式，注意区分）

| 结构类型                            | 条件互斥性                | 穷尽性（全集）             |
| :---------------------------------- | :------------------------ | :------------------------- |
| **`if` 结构** (独立 `if` 语句)      | 否 (多个 `if` 可同时执行) | 否                         |
| **`if...else if` 结构** (无 `else`) | ✅ 是 (最多执行一个)      | ❌ 否 (可能都不执行)       |
| **`if...else if...else` 结构**      | ✅ 是 (最多执行一个)      | ✅ 是 (总有一个分支会执行) |

| 关键词    | 描述                                           | 逻辑流程                     |
| :-------- | :--------------------------------------------- | :--------------------------- |
| `if`      | 如果（条件成立），则执行这段代码。             | **T**                        |
| `else if` | 否则，如果（第二个条件成立），则执行这段代码。 | **F** $\to$ **T**            |
| `else`    | 否则（以上所有条件都不成立），则执行这段代码。 | **F** $\to$ **F** $\to$ 执行 |

> **⚠️ 注意**
>
> - (1) `if` 后的代码块最好用花括号 `{}` 包围，否则**不写大括号的情况下， if 只控制紧随其后的第一条语句** ，后期维护不清晰。
> - (2) 条件控制结构的条件判断是**从第一个条件开始直到某一个条件成立，而不是直接跳转到成立的条件**。换句话说，在执行某个条件成立后的代码前，也许已经执行过了几次条件判断，这就需要 **注意条件判断中的相同方法重复调用，比如`sc.next()`**
> - (3) **编程规范：** else 关键字必须且只能紧接在它所配对的 `if` 语句所控制的单条语句或语句块 `{}` 之后，任何插入到两者之间的独立语句都会破坏这种配对关系，导致编译错误。所以，**为了清晰和避免错误，即使 `if` 或 `else` 块中只有一条语句，也应该使用花括号 `{}` 明确限定其作用域。**

---

## ➡️ 进阶类型：`switch` / `case` 语句 (多重选择)

当需要根据一个变量的**不同具体值**（而**不是复杂的条件范围**）来执行不同的操作时，`switch` 语句更简洁高效。

- **逻辑流程：** 检查一个变量的值，并将其与一系列的 `case` 值进行匹配。如果匹配成功，则执行对应 `case` 下的代码。

**关键组成部分详解**

### ① `expression` (控制表达式)

- **返回值类型要求：** 必须是**整型、字符串、枚举类型**，包括 `int`, `char`,`byte`, `short`, `enum` , `String`这六种类型。（没有`long`）
- **作用：** 它的值决定了程序将跳转到哪个 `case` 标签。

### ② `case` 标签

- **标签要求：** 必须是**常量表达式**，即在编译时就能确定值的常量，**不能是变量**。**注意：** `123`是常量表达式，**`123 + 1`也是常量表达式**
- **统一或兼容：** `case`值必须和控制表达式的返回值 **统一** 或者 **兼容**（比如 byte、char、int 等之间）。
  - 如果`expression` 的值与某个 `case` 后面的常量值是同一数据类型，不会发生数据类型转换，直接比较
  - 如果`expression` 的值与某个 `case` 后面的常量值**不是同一数据类型，会先进行数据类型提升**，再进行比较
- **唯一性：** 同一个 `switch` 语句内不能有重复的 `case` 值。
  - **当表达式返回值是基础数据类型时：判断 控制表达式的值和 case 的值是否相等 等价于 `if(a == b)`**。当 case 的值是兼容的整型时，**本质比较的是它们在内存中的整数值**，此时'A', 65 其实都是一样的
  - **当表达式返回值是`String`类型：判断 控制表达式的值和 case 的值是否相等 等价于 使用.equals()方法，而不是`==`**
- **执行起点：** `expression` 的值会从第一个`case`开始比较，当与某个 `case` 后面的常量值匹配，程序将**从此 `case` 标签后的第一条语句开始执行**。

### ③ `break` 语句（关键）

- **作用：** `break` 语句用于**立即跳出**当前的 `switch` 语句块，将控制权转移到 `switch` 块之后的语句。
- **重要性：** 如果缺少 `break`，程序将继续向下执行下一个 `case` 标签中的代码，直到遇到 `break` 或 `switch` 语句结束。这被称为 **"穿透"**。
- **编程规范：** 即使是**最后一个 `case` 后都要加一个`break`**，防止在以后添加新的 case 或者 default 时导致穿透

### ④ `default` 标签

- **作用：** 当 `expression` 的值**不匹配任何** `case` 标签时，控制权会转移到 `default` 标签后的语句。
- **位置：** 它可以放在 `switch` 块内的任何位置，但习惯上放在最后。
- **编程规范：** 虽然`default`是可选的，但**建议 `switch` 的结尾都用`default` 结束**，来处理所有未预料到的输入

---

## `switch` 核心机制：穿透 ⚠️

**这是 `switch` 语句与 `if-else if` 最大的区别，也是新手最容易出错的地方。**

- 如果一个 `case` 分支**没有 `break`** 语句，程序执行完该分支的代码后，会**继续执行的所有分支代码**，而**不再检查**之后 `case` 的条件是否匹配。

**🌰 穿透示例：**

```java
int score = 2;

switch (score) {
    case 1:
        printf("得分 1\n");
    case 2:
        printf("得分 2\n"); // 从这里开始执行
    case 3:
        printf("得分 3\n"); // 穿透，也会执行
        break;             // 遇到 break，跳出 switch
    default:
        printf("未得分\n");
}
// 输出:
// 得分 2
// 得分 3
```

- **正面应用：** 穿透有时被用来简化代码，例如当多个 `case` 标签执行相同的操作时，可以将它们堆叠起来，只在最后一个 `case` 处放置 `break`。

  ```java
  char grade = 'B';
  switch (grade) {
    case 'A':
        printf("优秀!\n");
        break;
    case 'B':
    case 'C': // 穿透：B 或 C 都执行下面的代码
        printf("良好或合格\n");
        break;
    case 'D':
        printf("需努力\n");
        break;
    default:
        printf("成绩无效\n");
  }
  // 结果: 输出 "良好或合格"
  ```

---

## `switch` 和 `if` 的选择

1\. 如果判断的**具体数值不多**，而且**符合 `byte` `short` `char` `int` `enum` `String`这六种类型** 时，虽然两个语句都可以使用，建议使用 switch
2\. 其他情况：**对区间判断** 、\*\*对结果为布尔类型的值进行判断\*\* 都使用 if，if 的范围更广
