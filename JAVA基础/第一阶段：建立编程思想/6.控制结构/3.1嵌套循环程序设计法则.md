# 📜 复杂嵌套循环开发 SOP (标准作业程序)

**核心心法**：**先数学建模，再代码骨架，最后逻辑填充。**
**禁止行为**：禁止在没画图/没填表的情况下直接写 `for`。

---

## 🟢 阶段一：数学建模 (The Modeling Phase)

**目标**：解决“边界是多少”和“变量关系是什么”的问题。
**工具**：纸、笔、列表法。

### 步骤 1：定义变量与维度

确定你需要几层循环？每一层代表什么物理意义？

* 外层变量名：建议用语义化命名（如 `row`, `round`, `i`）。
* 内层变量名：建议用语义化命名（如 `col`, `compareIndex`, `j`）。

### 步骤 2：绘制「追踪表」找规律 (关键！)

不要凭空想，把前 3-4 轮的数据列出来，寻找  与  的数学关系。

**判定公式模板**：

* **固定型**（矩形）：内层次数固定  `j < N`
* **递增型**（正三角）：内层随外层变大  `j <= i`
* **递减型**（倒三角）：内层随外层变小  `j < Total - i`
* **起点漂移型**（组合去重）：起点随外层变  `j = i + 1`

> **📝 纸上演算示例（冒泡排序）：**
> *  (第1轮)，需要比较 4 次
> *  (第2轮)，需要比较 3 次
> * **规律**：次数 =
> * **结论**：内层边界条件是 `j < Len - 1 - i`
>
>

---

## 🟡 阶段二：骨架搭建 (The Skeleton Phase)

**目标**：防止括号错位，理清层级结构。
**动作**：只写循环头和注释，**不写业务逻辑**。

### 步骤 3：编写“空壳代码”

将阶段一得出的变量名和边界公式填入，中间留空。

```java
// 示例：冒泡排序骨架
// 1. 外层：控制轮数
for (int i = 0; i < arr.length - 1; i++) {
    // TODO: 思考这里是否需要定义"本轮的状态变量"？

    // 2. 内层：控制比较次数
    // ✅ 将阶段一算出的公式填入这里：arr.length - 1 - i
    for (int j = 0; j < arr.length - 1 - i; j++) {
        // TODO: 核心比较逻辑
    }
    
    // TODO: 本轮结束后的收尾工作
}

```

---

## 🟠 阶段三：变量归位 (The Scope Phase)

**目标**：解决“变量没重置”或“作用域污染”的 Bug。
**法则**：最小作用域原则。

### 步骤 4：放置状态变量

问自己两个问题：

1. **这个变量是统计全局的吗？**  放最外面（如 `totalSum`）。
2. **这个变量每一轮都要清零吗？**  放外层循环内部（如 `rowSum`, `isSwapped`）。

```java
for (int i = 0; i < arr.length - 1; i++) {
    // ✅ 关键点：每轮开始前，重置"是否发生交换"的标记
    boolean isSwapped = false; 

    for (int j = 0; j < ...; j++) {
       // ...
    }
}

```

---

## 🔴 阶段四：逻辑填充 (The Logic Phase)

**目标**：实现具体的业务功能。

### 步骤 5：填充内核与短路优化

在最内层写业务代码（交换、打印、累加）。
同时检查是否需要优化：

* **提前退出**：如果任务完成了，需要 `break` 吗？
* **跳过本次**：遇到无效数据，需要 `continue` 吗？

---

## 🔵 阶段五：工程自检 (The Checklist)

**目标**：确保代码符合行业规范。

### 步骤 6：执行 4 点检查

1. [ ] **边界检查 (Off-by-one)**：是用 `<` 还是 `<=`？数组下标会越界吗？
2. [ ] **重置检查**：进入下一轮循环时，累加器清零了吗？
3. [ ] **命名检查**：变量名是否清晰（拒绝 `a`, `b`, `c`）？
4. [ ] **大O预警**：数据量如果过万， 的算法会超时，确认是否必须用嵌套循环？

---

## 🚀 实战演示：用 SOP 写一个“九九乘法表”

**1. 数学建模**：

* 行 (): 1 到 9。
* 列 (): 乘法表是三角形，第 1 行有 1 个式子，第 9 行有 9 个。
* **规律**： 的上限等于 。即 `j <= i`。

**2. 骨架搭建**：

```java
for (int i = 1; i <= 9; i++) {
    // TODO: 行级初始化
    for (int j = 1; j <= i; j++) { // ✅ 填入规律
        // TODO: 打印式子
    }
    // TODO: 换行
}

```

**3. 变量与逻辑填充**：

* 本例不需要复杂的重置变量，只需关注打印格式。

**4. 最终代码**：

```java
for (int i = 1; i <= 9; i++) {
    for (int j = 1; j <= i; j++) {
        System.out.print(j + "*" + i + "=" + (i*j) + "\t");
    }
    System.out.println(); // 内层跑完后，必须换行
}

```
