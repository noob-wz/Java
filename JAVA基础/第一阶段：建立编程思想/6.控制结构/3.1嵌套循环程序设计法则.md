这是一份基于我们深入讨论和修正后的完整行动指南。我将其整理为 Markdown 表格，旨在涵盖“定维度、冻结态、找关系、理状态”四步法的每一个关键细节和修正后的逻辑。

建议您将其保存为 **`Nested_Loop_Design_Guide.md`**，作为今后编写任何嵌套循环（图形打印、矩阵处理、多维数据分析）的标准操作程序 (SOP)。

---

# 🚀 嵌套循环通用设计法则：四步解耦模型行动指南

**核心目标**：通过“解耦”思维，将复杂的二维/多维逻辑，拆解为可控的单维逻辑。遵循“先共同，后特殊”与“防御性编程”原则。

| 步骤              | 核心思维 (Mindset)     | 执行动作 (Actionable Steps)                                                                                                                                                                                                                                                                         | 关键细节与逻辑检查 (Checkpoints)                                                                                                                                                                                                                                                                                                                                                                           |
| :---------------- | :--------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. 定维度**<br> | **角色分离**<br>       | 1. **明确外层 ($i$)**：确定外层循环代表什么（行、批次、组），范围是从几到几。<br>2. **明确内层 ($j$)**：确定内层循环代表什么（列、具体动作、元素）。                                                                                                                                                | ✅ **检查点**：<br>• 确认外层是**驱动者**（控制进度），内层是**执行者**（完成具体工作）。<br>• 此时不要思考两个循环如何互动，仅定义各自的角色。                                                                                                                                                                                                                                                            |
| **2. 冻结态**<br> | **静态切片**<br>       | 1. **强制固定外层**：假定当前 $i$ 是一个具体的常数（如 $i=3$）。<br>2. **设计单次任务**：在 $i$ 不变的前提下，设计内层 $j$ 应该执行多少次？具体打印什么或计算什么？                                                                                                                                 | ✅ **关键技巧**：<br>• **停止动态思考**：严禁一边写内层代码，一边脑补 $i$ 变化后的后果。<br>• **关注当下**：只解决这一行/这一轮的问题。                                                                                                                                                                                                                                                                    |
| **3. 找关系**<br> | **公式抽象与分治**<br> | 1. **对比归纳**：对比 $i=1, 2, 3$ 时的内层行为，确定规律。<br>2. **确定边界**：尝试建立 **内层循环边界和外层循环`i`的数学关系** 。<br>3. **边界验证**：<br>• **若公式通用于所有边界** ($i=1$ & $i=End$) $\rightarrow$ **进入下一步**。<br>• **若公式在边界失效** $\rightarrow$ **启用结构化拆解**。 | ✅ **结构化拆解逻辑**：<br>• 如果通用公式不成立（如空心金字塔），立即将逻辑拆分为 **`if (首行)`**, **`else if (尾行)`**, **`else (中间)`** 三个互斥模块。<br>• 遵循 **“先共同（通用结构），后特殊（差异逻辑）”** 原则<br> <br>• **注意**：结构化拆解既可能发生在第二步，也可能发生在第三步。换句话说，拆解**既可能是针对外层循环的场景，也可能是针对内层循环的变量场景**，本质都是**拆解循环执行的“条件”** |
| **4. 理状态**<br> | **防御性编程**<br>     | 1. **最小化作用域 (Rule A)**：凡是只服务于“这一轮”的变量（如单行累加器），**必须**在外层循环体**内部**声明。<br>2. **即时初始化 (Rule B)**：如果变量必须在外部声明（如全局统计），**必须**在内层循环开始前的**第一行**进行重置。                                                                    | ✅ **生命周期规范**：<br>• **内部声明**：`for(i){ int score=0; ... }` (推荐，天然无污染)。<br>• **顶部重置**：`for(i){ score=0; for(j){...} }` (防御性写法，防止 `continue` 跳过重置)。<br>• **严禁**：将重置语句放在循环体的底部。                                                                                                                                                                        |

---

### 📋 附录：标准代码骨架 (Cheat Sheet)

```java
// 【Step 1: 定维度 - 确定外层范围】
for (int i = 1; i <= totalLevel; i++) {

    // 【Step 4: 理状态 - 准备工作区】
    // 规范：只服务于本轮的变量，在此处声明或重置 (Rule A & B)
    int currentLineSum = 0;
    // score = 0; // 如果 score 定义在循环外，必须在这里重置

    // 【Step 3: 找关系 - 确定内层边界】
    // 逻辑：根据 i 计算 j 的上限或控制逻辑
    // 如果逻辑复杂，在此处使用 if-else if-else 结构拆分特殊行

    // 【Step 2: 冻结态 -> 内层执行】
    // 此时 i 被视为常量，j 负责具体干活
    for (int j = 1; j <= (calc_relation_with_i); j++) {
        // doWork...
    }

    // 【Step 4: 理状态 - 收尾工作】
    // 换行、输出本轮结果
    System.out.println();
}
```
