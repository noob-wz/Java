Java 提供了三种标准的循环“引擎”，外加一种现代化的增强版。

1. **`for` 循环**：**计数型**。最常用，适合“已知要跑多少圈”的场景。
2. **`while` 循环**：**条件型**。适合“不知道要跑多少圈，只知道什么时候停”的场景。
3. **`do-while` 循环**：**保底型**。不管条件符不符合，**先干一次再说**。
4. **增强 `for` (foreach)**：**遍历型**。专门用来刷数组和集合的（Java 5 引入）。

---

### 1. The `for` Loop (标准计数循环)

这是代码中出现频率最高的循环。

#### 🔬 语法解剖

```java
//    1.初始化        2.条件判断      4.步进迭代
for (int i = 0;   i < 100;    i++) {
    // 3. 循环体 (业务逻辑)
    System.out.println("跑第 " + i + " 圈");
}

```

**⚙️ 执行顺序 (闭环逻辑)**：

1. **初始化 (`int i=0`)**：只执行一次，定义计数器。
2. **判断条件 (`i<100`)**：每次跑之前先问“还能跑吗？”。
    * True -> 进入循环体。
    * False -> 结束循环，跳出。
3. **执行循环体**：干活。
4. **步进迭代 (`i++`)**：计数器更新。
5. **回到第 2 步**：继续判断。

> 说明：
>
> 1. 当**变量初始化在外部** 或者 是**实例变量** 或 **静态变量**的赋值，`for` 循环和 `while` 循环是**可以互换**的。但**当在 `for` 循环内部初始化时，更新变量它的作用域仅针对 `for` 循环，此时和 `while` 结构的转换不等价**。
> 2. **`for` 循环的外部有一个隐藏的 `{}` 来限制了整个 `for` 循环的作用域**。

```java
    { // 隐藏括号，限定了for循环的作用域
        for (int i = 0; i < 10; i++) {
            // i 变量在这里是可见的
            System.out.println(i);
        }
    }

// 由于隐藏括号的原因，局部变量 i 只在循环内部分配内存空间，循环一结束，变量 i 就销毁了
// System.out.println(i); // ❌ 编译错误：找不到符号 i。
```

```java
// 死循环（无限循环）
for(;;)
```

---

### 2. The `while` Loop (前置判断循环)

适合“不知道具体次数”的场景。比如：读取文件直到结束、等待用户输入直到正确。

#### 🔬 语法解剖

```java
// 1. 初始化 (在外面)
int ticket = 10;

// 2. 条件判断
while (ticket > 0) {
    // 3. 循环体
    System.out.println("卖票，剩余: " + ticket);
    
    // 4. 迭代 (必须在内部写，否则死循环！)
    ticket--; 
}

```

---

### 3. The `do-while` Loop (后置判断循环)

它是 `while` 的变体。区别在于：**它是先斩后奏**。
无论条件是否成立，代码块**至少会执行一次**。

#### 🔬 语法解剖

```java
int password;
do {
    System.out.println("请输入密码:");
    password = scanner.nextInt();
} while (password != 123456); // ⚠️ 注意：这里必须有分号

```

* **场景**：交互式程序。还没让用户输密码呢，怎么能判断密码对不对？所以必须先让用户输一次。

---

### 4. 增强 For 循环 (Foreach) —— 现代 Java 的宠儿

在处理数组或集合时，传统 `for` 循环写下标 (`i`) 很麻烦且容易越界。Java 5 引入了 `foreach`。

**语法：** `for (元素类型 变量名 : 集合/数组)`

```java
int[] numbers = {10, 20, 30, 40};

// ✅ 推荐写法：优雅、防越界
for (int num : numbers) {
    System.out.println(num);
}

// 🆚 传统写法
for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}

```

**限制**：Foreach 只能读取，**不能修改**数组里的元素，也拿不到下标 `i`。

---

### 📊 决策树：我该用哪个？

| 场景特征 | 推荐循环 | 理由 |
| --- | --- | --- |
| **已知循环次数** (如：跑 10 圈) | **`for`** | 结构紧凑，变量作用域局限在循环内 |
| **遍历数组/集合** | **增强 `for`** | 代码最简洁，可读性最高 |
| **未知次数，先判断** (如：文件未结束) | **`while`** | 逻辑符合“当...时”的语义 |
| **未知次数，至少做一次** (如：用户输入校验) | **`do-while`** | 保证逻辑至少运行一遍 |

---

### ⚠️ 常见死穴 (新手必看)

#### 1. 死循环 (Infinite Loop)

如果忘记写迭代条件，或者条件永远为 `true`，程序会卡死，CPU 飙升到 100%。

```java
// ❌ 错误示范
int i = 0;
while (i < 10) {
    System.out.println(i);
    // 忘了写 i++，导致 i 永远是 0，永远小于 10
}

```

#### 2. 分号陷阱

```java
// ❌ 错误示范
for (int i = 0; i < 5; i++); { // 注意这里多了一个分号！
    System.out.println("Hello");
}

```

* **后果**：分号代表空语句。循环空跑了 5 次，然后代码块只执行了 1 次。
* **修正**：删掉分号。

---

### 💼 大厂编码规范

1. **防止死循环**：
   在编写 `while(true)` 这种业务逻辑时，内部必须有明确的 `break` 出口，或者设置超时保护机制。
2. **优先使用 Foreach**：
   只要是遍历操作，且不需要下标信息，**一律优先使用增强 for 循环**。它更能表达“遍历”的语义，且不仅限于数组，所有实现了 `Iterable` 接口的集合都能用。
3. **循环体不要过长**：
   如果循环体超过 50 行，建议拆分成独立的方法。循环逻辑太复杂容易把人绕晕。

---
