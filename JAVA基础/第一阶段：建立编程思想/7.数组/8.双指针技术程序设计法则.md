**“双指针/流式思维 (Stream/Two-Pointer Thinking)”** 的一套标准化的 **SOP (标准作业程序)**。

下次遇到 **合并、插入、去重、移动零** 等问题时，直接套用此文档。

---

# 📜 流式思维/双指针通用算法 SOP (v1.0)

**核心隐喻**：
不要把数组看作静态的格子，把它看作 **“传送带”**。

* **输入流 (Source)**：源源不断地送来数据（旧数组/链表）。
* **输出流 (Dest)**：等待填装的空容器（新数组/结果集）。
* **阀门 (Valve)**：中间的决策逻辑，决定“放行”还是“拦截”还是“插队”。

---

## 🟢 第一阶段：角色定义 (Role Definition)

在写 `for` 循环之前，先明确两个指针的职责。

**动作**：定义两个变量，建议根据职责命名，不要只用 `i, j`。

1. **消费者指针 (Writer / Dest Ptr)**：
* **职责**：指向**新数组/结果集**的当前空位。
* **特点**：**非常勤奋**，每填入一个有效数据，必须 +1。
* **变量名建议**：`writeIdx`, `dest`, `i`


2. **生产者指针 (Reader / Src Ptr)**：
* **职责**：指向**旧数组/资源池**的当前待处理元素。
* **特点**：**很懒/被动**，只有当他的货被取走时，才 +1；否则原地待命。
* **变量名建议**：`readIdx`, `src`, `j`



---

## 🟡 第二阶段：循环构建 (The Loop Structure)

**核心原则**：循环的驱动力通常是 **消费者 (Writer)** 或者 **生产者 (Reader)** 的边界。

**SOP 模板**：

```java
// 初始化指针
int readIdx = 0; // 指向旧数组
int writeIdx = 0; // 指向新数组

// 循环条件：通常只要新数组没填满，或者旧数组没读完
while (writeIdx < newArr.length) {
    // 进入决策阶段...
}

```

---

## 🔴 第三阶段：决策阀门 (The Decision Valve) *🔥 核心*

这是算法的灵魂。在循环体内部，你需要判断**“此刻该谁填坑？”**

你需要回答以下问题来构建 `if-else`：

1. **触发点 (Trigger)**：导致流速改变的条件是什么？（例如：`writeIdx == 插入位置` 或 `readValue == 0`）
2. **动作 A (特殊处理)**：触发时，Writer 填入什么？Reader 动不动？
3. **动作 B (常规流动)**：没触发时，Writer 填入什么？Reader 动不动？

**通用代码模版**：

```java
// 场景：插入逻辑
if (是特殊时刻/插队时刻) {
    // 动作 A：特殊处理
    newArr[writeIdx] = 特殊值; 
    
    // ⚠️ 关键：Reader (旧指针) 此时不动！
    // 因为旧数据还没被取走，要留给下一轮
} else {
    // 动作 B：常规流动
    newArr[writeIdx] = oldArr[readIdx];
    
    // ✅ 关键：Reader (旧指针) 完成供货，往前走一步
    readIdx++; 
}
// 无论分支如何，Writer (新指针) 都要走向下一个空位
writeIdx++; 

```

---

## 🔵 第四阶段：状态检视 (State Check)

这是验证逻辑是否正确的**“听诊器”**。想象在某一次循环中：

1. **同步状态**：逻辑没触发（如插入前）。
* 检查：`writeIdx` 和 `readIdx` 应该一起增加。
* 现象：数据直接搬运。


2. **错位状态**：逻辑触发后（如插入后）。
* 检查：`readIdx` 应该比 `writeIdx` **滞后**（小）。
* 现象：`readIdx` 暂停了一次，导致后续永远慢一拍。


---

## 🧠 总结：心法口诀

> **双指针，两头跑。**
> **Writer 勤快不能少，Reader 供货看信号。**
> **特殊情况 Reader 停，常规情况一起跑。**
> **错位一旦发生后，数据自然排得好。**

当你以后学到 **链表合并**、**归并排序**、**快速排序的分区操作** 时，你会发现它们全是这个 SOP 的变体！