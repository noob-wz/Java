# 👑 双指针技术程序设计框架 (Two Pointers Pattern)

**核心概念**：**双指针** 的同步与分离
**适用范围**：所有涉及 **数组/链表遍历、元素比较、原地修改、查找匹配或逆序** 的问题。

---

## I. 基础识别与哲学

### 1. 识别：何时启用双指针？

当需求涉及以下任一场景时，**双指针** 是首选策略：

| 场景类型           | 关键词                                            | 适用的指针模式      |
| :----------------- | :------------------------------------------------ | :------------------ |
| **原地修改/过滤**  | 原地修改 ($O(1)$ 空间), 移除元素, 去重, 移动元素  | **快慢指针** (单向) |
| **匹配/交换/反转** | 数组反转, 寻找和 (Two Sum), 找到回文 (Palindrome) | **双向指针** (对撞) |

### 2. 哲学：**双指针** 同步与分离的本质

- **同步 (Synchronization)**：当 `fast` 发现**有效数据**时，`slow` 立即跟进，**`fast` 和 `slow` 保持固定偏移量** 执行。 **目的：保留数据。**
- **分离 (Separation)**：当 `fast` 发现**无效数据**时，`slow` 停在原地。 **目的：过滤数据。**
- **物理意义**：`fast` 和 `slow` 之间的距离，永远代表着已被过滤或需要被忽略的元素。

---

## II. 模式一：快慢指针 (单向过滤与原地修改)

这是用于实现 **原地过滤、去重、移动元素** 的标准 SOP。

### 1. 角色与初始化

| 指针           | 角色定位        | 初始化          | 运动规则                           |
| :------------- | :-------------- | :-------------- | :--------------------------------- |
| **`fast` (F)** | 探索者 / 时间流 | `int fast = 0;` | 每次循环 **无条件** `fast++`。     |
| **`slow` (S)** | 收集者 / 有效区 | `int slow = 0;` | **有条件** `slow++` (只在同步时)。 |

### 2. 执行流程 (SOP 核心)

| 步骤       | 动作           | 代码关注点                                               | 状态变化                                                                       |
| :--------- | :------------- | :------------------------------------------------------- | :----------------------------------------------------------------------------- |
| **Step 1** | **开启时间流** | 编写 `for (int fast = 0; ...)` 循环。                    | F 开始移动。                                                                   |
| **Step 2** | **精确控制**   | 编写 `if (arr[fast] 是我们要保留的有效数据)`。           | 此判断决定是同步还是分离。                                                     |
| **Step 3** | **维持同步**   | **[赋值]** `arr[slow] = arr[fast];` **[推进]** `slow++;` | 成功保留数据，S 追上 F。                                                       |
| **Step 4** | **触发分离**   | `else` 语句 (隐式)。                                     | F 移动，S 保持不动，两者间产生间隙。                                           |
| **Step 5** | **收尾处理**   | 循环结束后，根据题目要求处理。                           | 返回 `slow` (新长度)，或对 `arr[slow]` 到 `arr[N-1]` 区域进行补零/默认值填充。 |

### 3. 关键应用示例 (筛选逻辑)

| 场景             | `if` 中的筛选逻辑（保留条件） |
| :--------------- | :---------------------------- |
| **移除元素 $k$** | `arr[fast] != k`              |
| **有序去重**     | `arr[fast] != arr[slow - 1]`  |
| **移动零**       | `arr[fast] != 0`              |

---

## III. 模式二：双向指针 (对撞与匹配)

这是用于实现 **数组反转、收敛搜索、快速交换** 的标准 SOP。

### 1. 角色与初始化

| 指针            | 角色定位 | 初始化                        | 运动规则                                       |
| :-------------- | :------- | :---------------------------- | :--------------------------------------------- |
| **`left` (L)**  | 左侧探索 | `int left = 0;`               | **寻找右侧的匹配项或目标** $\rightarrow$ `L++` |
| **`right` (R)** | 右侧探索 | `int right = arr.length - 1;` | **寻找左侧的匹配项或目标** $\rightarrow$ `R--` |

### 2. 执行流程

| 步骤       | 动作         | 循环控制                                                   | 典型应用                                                    |
| :--------- | :----------- | :--------------------------------------------------------- | :---------------------------------------------------------- |
| **Step 1** | **设定边界** | `while (left < right)` 或 `while (left <= right)`          | `L` 和 `R` 分别指向数组两端。                               |
| **Step 2** | **内侧循环** | 循环内部通常使用 `if-else if-else` 结构。                  | 确保 `L` 和 `R` 准确停在需要操作的位置。                    |
| **Step 3** | **执行操作** | **[交换]** 使用临时变量 `temp` 交换 `arr[L]` 和 `arr[R]`。 | **数组反转**：直接交换并 $L++, R--$。                       |
| **Step 4** | **执行操作** | **[收敛/匹配]** 找到目标后，根据目标移动 $L$ 或 $R$。      | **Two Sum II** (有序)：如果和太小 $L++$，如果和太大 $R--$。 |

---

## IV. 最终自检清单 (Mnemonic Checklist)

在任何双指针代码提交前，请快速检查以下三项：

1.  **角色分工明确性 (Clarity)**：

    - `fast` 是否只负责看？ `slow` 是否只负责写？
    - 在双向指针中，`L` 和 `R` 的目标是否明确？

2.  **运动规则严谨性 (Movement)**：

    - 在快慢指针中，`fast` 是否总是移动？`slow` 是否只在 `if` 内部移动？
    - 在双向指针中，是否在每次操作后都执行了 $L++/R--$，以确保循环最终终止？

3.  **结果返回正确性 (Result)**：
    - `slow` 总是代表**有效数据的长度**。
    - `L` 和 `R` 最终的相遇/越过位置，是否能正确推导出最终结果？ (例如，反转后，整个数组即是结果；收敛后，$L$ 和 $R$ 之间的区域可能就是匹配结果)。

---
