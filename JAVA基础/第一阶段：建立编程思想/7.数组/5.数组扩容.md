“数组一旦创建，长度不可变”。那么，当数据不断涌入，原来的数组装不下了怎么办？

这就涉及到了 **“动态扩容”** 技术。这是所有动态集合（如 `ArrayList`, `Vector`）背后的“核动力”。

──────────────────────────────────

## 第1阶段：建立认知（The Illusion）

### 📦 1.1 “扩容”是一种假象

**核心概念**：Java 数组在物理内存上**绝不可能**“变长”。
所谓的扩容，本质上是一次 **“搬家 (Migration)”**。

**生活类比**：
你租了一个只能住 3 个人的小房子（长度为3）。现在来了第 4 个朋友。

* **不可能的做法**：把墙推倒，强行把房子变大（物理内存是被锁死的）。
* **真实的做法**：去租一个能住 6 个人的大房子，先把这 3 个人连同行李搬过去，再让第 4 个人住进来。旧房子退租（被 GC 回收）。

### 🔧 1.2 内存图解 (ASCII)

假设 `arr` 当前指向一个长度为 2 的数组，现在要扩容到 4。

**步骤 1：初始状态**

```text
Stack (栈)         Heap (堆)
+-------+         +-------------------+
|  arr  |-------->| 0x11 [A, B]       |
+-------+         +-------------------+

```

**步骤 2：创建新数组 + 数据搬运**

```text
Stack (栈)         Heap (堆)
+-------+         +-------------------+
|  arr  |---|     | 0x11 [A, B]       | (旧数组，即将被遗弃)
+-------+   |     +-------------------+
            |
            |     +-------------------+
            |---->| 0x22 [A, B, 0, 0] | (新数组，引用已指向这里)
                  +-------------------+

```

**步骤 3：旧数组成为垃圾**
`0x11` 没有任何引用指向它，Java 垃圾回收器 (GC) 会在合适的时候回收它。

---

## 第2阶段：工程实践（How to Do Right）

### 🚀 2.1 手写扩容逻辑 *💡 核心必学*

让我们用代码实现这个“搬家”的过程。这是理解 `ArrayList` 源码的基础。

```java
import java.util.Arrays;

public class ArrayGrowthDemo {
    public static void main(String[] args) {
        // 1. 初始数组（容量为 3）
        int[] data = {10, 20, 30};
        
        System.out.println("扩容前: " + Arrays.toString(data) + " 长度: " + data.length);
        
        // 2. 模拟：来了新数据 40，但装不下了
        // 检查是否需要扩容？ (size >= capacity)
        
        // 3. 执行扩容：通常策略是扩大为原来的 1.5倍 或 2倍
        // 这里我们简单粗暴地 * 2
        int newCapacity = data.length * 2;
        
        // 4. 核心三步走：开新房 -> 搬行李 -> 换钥匙
        // Arrays.copyOf 帮我们完成了"开新房"和"搬行李"
        data = Arrays.copyOf(data, newCapacity);
        
        // 5. 放入新数据
        data[3] = 40;
        
        System.out.println("扩容后: " + Arrays.toString(data) + " 长度: " + data.length);
    }
}

```

**运行结果**：

```text
扩容前: [10, 20, 30] 长度: 3
扩容后: [10, 20, 30, 40, 0, 0] 长度: 6

```

*(注意：最后两个 0 是新空间的空位)*

---

### 🌍 2.2 真实的工程选择：ArrayList

在实际工作中，我们**绝不会**手动写上面的代码。我们会直接使用封装好的 `java.util.ArrayList`。

`ArrayList` 就是一个**会自动扩容的数组包装器**。

```java
// ✅ 现代工程写法
List<Integer> list = new ArrayList<>(); 
list.add(10);
list.add(20);
// ... 添加第 1000 个元素，你完全不需要关心扩容，它自己会处理

```

---

## 第3阶段：避坑进阶（Performance Optimization）

这是面试和高性能系统设计的重灾区。

### ⚠️ 3.1 扩容的代价 *🔥 实战必备*

**代价分析**：
每次扩容都要把所有旧数据复制一遍。如果数据量很大（比如 1000万），或者扩容很频繁，这会**极度消耗 CPU 和 内存**。

**场景模拟**：
你需要存 100 万个数据。

1. **默认构造**：`new ArrayList()` 初始容量是 10。
2. **存满后**：变成 15 -> 22 -> 33 ... -> 100万。
3. **结果**：为了存这批数据，系统可能在背后进行了几十次“搬家”，每次都要复制海量数据。

### ✅ 3.2 优化方案：预设容量

如果你预先知道（或能估算）数据量，**一定要在构造时指定容量**！

```java
// ❌ 性能差：让它自己慢慢扩容几十次
List<User> users = new ArrayList<>();

// ✅ 性能优：直接开辟足够大的空间，一次扩容都不发生
// 就像一开始就租一个能容纳所有人的大别墅
List<User> users = new ArrayList<>(1000000); 

```

### ⚙️ 3.3 JDK 的扩容算法（面试考点）

Java 的 `ArrayList` 到底每次扩大多少？

* **JDK 1.6 及之前**：`old * 3 / 2 + 1` (约 1.5 倍)
* **JDK 1.7 及之后**：`old + (old >> 1)` (也就是 1.5 倍)

**源码一瞥 (JDK 17)**：

```java
// ArrayList 内部代码片段
private int newCapacity(int minCapacity) {
    int oldCapacity = elementData.length;
    // >> 1 相当于除以 2
    int newCapacity = oldCapacity + (oldCapacity >> 1); 
    // ...
    return newCapacity;
}

```

**设计哲学**：为什么是 1.5 倍而不是 2 倍？
这是一个数学权衡。1.5 倍扩容能更好地复用之前的内存碎片（这是一个复杂的内存分配策略话题），且增长曲线比 2 倍更平滑，避免浪费太多空间。

──────────────────────────────────      
💡 总结        
──────────────────────────────────      

1. **本质**：数组不能变长，扩容等于 **"新建 + 复制 + 替换"**。
2. **工具**：工程中直接用 `ArrayList`，它封装了扩容逻辑。
3. **优化**：如果知道数据大小，使用 `new ArrayList<>(size)` 避免频繁扩容带来的性能杀手。

