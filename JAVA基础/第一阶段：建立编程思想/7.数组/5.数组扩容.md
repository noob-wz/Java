由于 Java 数组在堆内存中必须是连续存储的，**一旦创建，其占用的内存块大小就固定了** 。因此，“扩容”的唯一方法是：**创建一个更大的新房子，然后搬家。**

下面我将从**底层原理、手动实现、系统优化、以及 ArrayList 源码分析**四个层面，细致讲解 Java 中的数组扩容。

---

### 1\. 核心原理

**扩容的三部曲：**

1.  **新建 ：** 在堆内存中开辟一块更大的新数组空间。
2.  **迁移：** 将旧数组中的数据，逐个复制到新数组中。
3.  **替换：** 将数组引用指向新数组，旧数组没有任何引用变量指向它，则变成“垃圾”，等待垃圾回收器 (GC) 回收。

> **内存视角：** 栈帧中的变量 `arr` 原本存储的是地址 `0x11`（旧数组），扩容后，`arr` 存储的地址变成了 `0x99`（新数组）。

---

### 2\. 手动实现扩容（基础版）

这是最原始的扩容方式，通过 `for` 循环进行数据迁移。

```java
public class ArrayResizeDemo {
    public static void main(String[] args) {
        // 1. 原始数组，长度为 3
        int[] arr = {10, 20, 30};
        // 内存：Stack[arr -> 0x11] -> Heap[10, 20, 30]

        // 2. 定义新长度 (例如扩容到 5)
        int newCapacity = 5;

        // 3. 【关键】创建新数组
        int[] newArr = new int[newCapacity];
        // 内存：Stack[newArr -> 0x99] -> Heap[0, 0, 0, 0, 0]

        // 4. 【关键】数据迁移 (Copy)
        for (int i = 0; i < arr.length; i++) {
            newArr[i] = arr[i];
        }
        // Heap(0x99) 变为：[10, 20, 30, 0, 0]

        // 5. 【关键】改变引用指向
        arr = newArr;
        // 此时，arr 指向了 0x99。旧的 0x11 失去引用，将被 GC 回收。

        System.out.println("扩容后长度: " + arr.length);
    }
}
```

---

### 3\. 系统级优化：System.arraycopy

Java 标准库提供了一个非常高效的本地方法（Native Method）来处理数组复制，通常由 C++ 直接操作内存，比 `for` 循环快得多。

**语法：**
`System.arraycopy(src, srcPos, dest, destPos, length)`

**优化后的扩容代码：**

```java
int[] arr = {10, 20, 30};
int[] newArr = new int[10];

// 直接块拷贝：从 arr 的第 0 位开始，拷到 newArr 的第 0 位，拷 arr.length 个
System.arraycopy(arr, 0, newArr, 0, arr.length);

arr = newArr;
```

---

### 4\. 工业级标准：ArrayList 的扩容机制

我们在实际开发中很少手动管理数组，而是使用 `ArrayList`。`ArrayList` 内部封装了一个数组，并实现了**自动扩容**。

理解 `ArrayList` 的扩容策略是 Java 面试和进阶的必修课。

#### A. 触发时机

当添加元素 (`add()`) 时，如果当前内部数组已满（`size == capacity`），就会触发扩容。

#### B. 扩容算法（JDK 1.8+）

`ArrayList` 的新容量计算公式如下：

$$NewCapacity = OldCapacity + (OldCapacity \gg 1)$$

还记得我们之前聊的**位运算**吗？

- `>> 1` 等价于 **除以 2**。
- 所以：`新容量 = 旧容量 + 0.5 * 旧容量`。
- **结论：`ArrayList` 每次扩容约为原来的 1.5 倍。**

#### C. 源码逻辑模拟

```java
// 假设当前 capacity = 10
int oldCapacity = 10;

// 计算新容量：10 + (10 >> 1) = 10 + 5 = 15
int newCapacity = oldCapacity + (oldCapacity >> 1);

// 检查是否溢出等逻辑 (略...)

// 创建新数组并拷贝
elementData = Arrays.copyOf(elementData, newCapacity);
// Arrays.copyOf 内部调用的就是 System.arraycopy
```

---

### 5\. 扩容的代价与性能分析

虽然扩容很方便，但它是一个\*\*“重型操作”\*\*，主要体现在：

1.  **时间复杂度 $O(N)$：**
    每次扩容都需要把旧数组的所有 $N$ 个元素复制一遍。如果数组很大（例如 100 万数据），这非常耗时。
2.  **内存抖动 (Memory Churn)：**
    扩容会产生“旧数组”作为垃圾对象。频繁扩容会产生大量垃圾，增加垃圾回收器 (GC) 的负担，导致程序卡顿（Stop The World）。

#### 最佳实践建议

如果你预先知道大概需要存多少数据，**一定要在创建集合时指定初始容量！**

```java
// 🔴 糟糕的写法 (默认容量 10)
// 如果你要存 10000 个数，这会触发 10 -> 15 -> 22 ... -> 10000 多次扩容和拷贝
List<Integer> list = new ArrayList<>();

// 🟢 高效的写法
// 直接一步到位，避免中间的所有扩容和拷贝过程
List<Integer> list = new ArrayList<>(10000);
```

### 总结

1.  **数组本身不可变：** 扩容本质是**创建新数组 + 数据复制**。
2.  **引用指向改变：** 栈中的变量指向了堆中新的内存块。
3.  **ArrayList 策略：** 默认按 **1.5 倍** (`old + old >> 1`) 进行扩容。
4.  **性能关键：** 为了避免 $O(N)$ 的拷贝代价，尽量在初始化时指定合适的容量。
