如果说一维数组是“一条线”（或者一列火车），那么二维数组就是“一个面”（或者一个 Excel 表格、一个电影院的座位阵列）。

但请记住 Java 独特的设计哲学：**Java 中并没有真正的多维数组，只有“数组的数组” (Array of Arrays)。**

下面我将从**核心概念**、**内存模型**、**声明初始化**到**实战操作**进行详细拆解。

---

### 一、 核心概念：数组的数组

在 Java 中，二维数组 `int[][]` 本质上是一个**一维数组**，只不过这个一维数组里的**每一个元素**，都是**另一个一维数组的引用（地址）**。

- **形象理解：**
  - 你有一个**钥匙扣**（外层数组）。
  - 钥匙扣上挂着**几把钥匙**（元素）。
  - 每一把钥匙都能打开**一个房间**（内层数组）。
  - 房间里存放着具体的**物品**（实际数据，如 `int`）。

---

### 二、 内存模型（最核心的底层原理）

这是理解 Java 二维数组的关键。假设我们执行：`int[][] arr = new int[3][2];`

#### 1\. 内存布局图解

- **栈 (Stack)**：

  - 有一个引用变量 `arr`，存储着堆中**主干数组**的地址（比如 `0xAA`）。

- **堆 (Heap) - 第一层（主干/行数组）**：

  - 地址 `0xAA` 处是一个长度为 3 的数组。
  - 它的元素不是整数，而是**地址**。
  - `arr[0]` = `0x11` (指向第一行)
  - `arr[1]` = `0x22` (指向第二行)
  - `arr[2]` = `0x33` (指向第三行)

- **堆 (Heap) - 第二层（数据/列数组）**：

  - 地址 `0x11` 处：`{0, 0}` (实际存数据的 `int` 数组)
  - 地址 `0x22` 处：`{0, 0}`
  - 地址 `0x33` 处：`{0, 0}`

```
+----------------+      +-------------------------------------------+
|     栈 (Stack) |      |                 堆 (Heap)                  |
|----------------|      |-------------------------------------------|
|                |      |  [主干数组对象 (int[][])]                   |
|  arr: 0xAA     |----->|  0xAA: (长度为 3 的引用数组)                 |
|                |      |    +---------------------------------+    |
|                |      |    | arr[0] (引用): 0x11 ------------+---> |  [子数组对象 (int[]) - 行 0] |
|                |      |    | arr[1] (引用): 0x22 ------------+---> |  0x11: { 0, 0 }               |
|                |      |    | arr[2] (引用): 0x33 ------------+---> |  [ int | int ]                |
|                |      |    +---------------------------------+    |-------------------------------|
|                |      |                                           |  [子数组对象 (int[]) - 行 1] |
|                |      |                                           |  0x22: { 0, 0 }               |
|                |      |                                           |  [ int | int ]                |
|                |      |                                           |-------------------------------|
|                |      |                                           |  [子数组对象 (int[]) - 行 2] |
|                |      |                                           |  0x33: { 0, 0 }               |
|                |      |                                           |  [ int | int ]                |
+----------------+      +-------------------------------------------+
```

#### 2\. 重要推论

因为每一行都是独立的数组对象，所以：

1.  **地址不连续：** 第 1 行数据的内存地址和第 2 行数据的内存地址**不一定**是挨着的（这**与 C 语言的大块连续内存不同**）。
2.  **列数可以不同：** 每一行的长度可以不一样！这就构成了 **“不规则数组”** 。

---

### 三、 声明与初始化（三种方式）

#### 1\. 静态初始化（数据已知）

最直观，像写一个矩阵。

```java
int[][] arr = {
    {1, 2, 3},  // 第0行
    {4, 5, 6},  // 第1行
    {7, 8, 9}   // 第2行
};
```

#### 2\. 动态初始化 - 规则矩阵（行列固定）

最常用，创建一个矩形表格。

```java
// 创建一个 3行 4列 的数组
// 系统会自动把所有元素初始化为 0
int[][] arr = new int[3][4];
```

- **含义：** 创建一个包含 3 个元素的“主干数组”，并立即创建 3 个长度为 4 的“子数组”挂上去。

#### 3\. 动态初始化 - 不规则数组（列数未定）

这是 Java 的特色。只定义行数，不定义列数。
[Java 语言设计者在数组内存模型上的核心意图：角色分离](7.1Java中数组初始化的核心意图.md)

```java
// 1. 先只创建“主干数组“，包含3个引用的空间大小，每个引用目前的值系统默认是 null
int[][] arr = new int[3][];

// 2. 手动分别为每一行创建数组（长度可以不同）
arr[0] = new int[2];    // 第0行有2个元素
arr[1] = new int[4];    // 第1行有4个元素
arr[2] = new int[3];    // 第2行有3个元素
```

- **应用场景：** 杨辉三角、参差不齐的数据结构。

---

### 四、 访问与属性（length 的坑）

这是初学者最容易晕的地方，请务必分清两个 `length`。

假设 `int[][] arr = new int[3][4];`

| 代码                | 含义               | 值    | 解释                         |
| :------------------ | :----------------- | :---- | :--------------------------- |
| **`arr`**           | 二维数组本身       | 地址  | 指向堆中的主干数组。         |
| **`arr[0]`**        | 第一行（一维数组） | 地址  | 指向堆中的第一个子数组。     |
| **`arr[0][1]`**     | 具体数据           | `int` | 第一行第二列的数值。         |
| **`arr.length`**    | **行数**           | 3     | 主干数组的长度（有多少行）。 |
| **`arr[i].length`** | **当前行的列数**   | 4     | 第 `i` 个子数组的长度。      |

---

### 五、 遍历二维数组（标准套路）

结合我们之前的“嵌套循环四步法”，遍历二维数组是最典型的应用。

#### 1\. 普通 For 循环（最常用，可读写）

```java
int[][] matrix = { {1, 2}, {3, 4}, {5, 6} };

// 外层循环：遍历每一行 (控制 i)
// limit 是 matrix.length (行数)
for (int i = 0; i < matrix.length; i++) {

    // 内层循环：遍历当前行中的每一列 (控制 j)
    // limit 是 matrix[i].length (当前行的长度)
    for (int j = 0; j < matrix[i].length; j++) {
        System.out.print(matrix[i][j] + " ");
    }
    System.out.println(); // 换行
}
```

#### 2\. 增强 For 循环（仅读取，更简洁）

```java
// 读作：对于 matrix 中的每一个 int[] 行数组 row
for (int[] row : matrix) {
    // 读作：对于 row 中的每一个 int 元素 num
    for (int num : row) {
        System.out.print(num + " ");
    }
    System.out.println();
}
```

---

### 六、 常见操作与实战示例

#### 示例：杨辉三角（不规则数组的应用）

这是一个经典的二维数组练习，第一行 1 个数，第二行 2 个数，以此类推。

```java
public class YangHui {
    public static void main(String[] args) {
        // 1. 声明并初始化二维数组（只指定行数 5）
        int[][] yangHui = new int[5][];

        // 2. 遍历每一行，进行初始化和赋值
        for(int i = 0; i < yangHui.length; i++) {

            // 2.1 给每一行开辟空间：第 i 行有 i+1 个元素
            // 比如第0行有1个，第1行有2个...
            yangHui[i] = new int[i + 1];

            // 2.2 给元素赋值
            for(int j = 0; j < yangHui[i].length; j++) {
                // 首位和末位都是 1
                if (j == 0 || j == yangHui[i].length - 1) {
                    yangHui[i][j] = 1;
                } else {
                    // 中间的数 = 上一行同列 + 上一行前一列
                    yangHui[i][j] = yangHui[i-1][j] + yangHui[i-1][j-1];
                }
            }
        }

        // 3. 打印输出
        for(int[] row : yangHui){
            for(int num : row){
                System.out.print(num + "\t");
            }
            System.out.println();
        }
    }
}
```

---

### 七、 总结

1.  **本质：** 数组的数组。外层存地址，内层存数据。
2.  **声明：** `int[][] arr`。
3.  **内存：** 每一行在堆内存中是独立的对象，地址可以不连续。
4.  **遍历：**
    - 外层循环条件：`i < arr.length`
    - 内层循环条件：`j < arr[i].length` **(注意带上 `[i]`)**
