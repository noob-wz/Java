如果说一维数组是一条“线”，那么二维数组就是一个“面”。
在很多教材中，它被称为**矩阵 (Matrix)** 或 **表格**。但在 Java 的底层世界里，它的真实身份有点特殊——它是 **“数组的数组”**。

──────────────────────────────────

## 第1部分：建立认知（What & Why）

### 📦 1.1 核心语法 *💡 核心必学*

**目标**：掌握二维数组的声明与初始化。

你可以把二维数组想象成一个 **Excel 表格**，有行 (Row) 和列 (Column)。

#### 1. 声明与初始化

```java
public class TwoDimSyntax {
    public static void main(String[] args) {
        // 1. 静态初始化 (已知所有数据)
        // 场景：定义一个 3x3 的井字棋盘
        int[][] board = {
            {1, 0, 1}, // 第0行
            {0, 1, 0}, // 第1行
            {1, 1, 1}  // 第2行
        };

        // 2. 动态初始化 (只知大小)
        // 语法：new 类型[行数][列数]
        // 场景：创建一个 3行 4列 的教室座位表
        int[][] seats = new int[3][4];

        // 3. 访问元素
        // 语法：arr[行索引][列索引]
        seats[0][0] = 1; // 第一行第一列坐了人
        int val = board[2][1]; // 获取第3行第2列的值
    }
}

```

---

### ⚙️ 1.2 底层原理：数组的数组 *⭐ 进阶选学*

**目标**：理解为什么我说它不是“真正的表格”。

在 C 语言或数学中，矩阵是一块完整的连续内存。
但在 Java 中，**二维数组本质上是一个一维数组，只是这个一维数组里的每个元素，存的都是另一个一维数组的地址。**

**内存图解 (ASCII)**：

假设 `int[][] arr = new int[2][3];`

```text
Stack (栈)          Heap (堆 - 主数组)          Heap (堆 - 子数组)
+-------+          +----------------+          +------------------+
|  arr  |--------->| [0]: 0xA1      |--------->| 0xA1 [0, 0, 0]   | (第0行)
+-------+          | [1]: 0x82      |---+      +------------------+
                   +----------------+   |
                                        |      +------------------+
                                        +----->| 0x82 [0, 0, 0]   | (第1行)
                                               +------------------+

```

**关键点**：

* **主数组**（竖着的那个）存的是**引用（地址）**。
* **子数组**（横着的那些）才是真正存数据的。

---

## 第2部分：工程实践（How to Do Right）

### 🌍 2.1 真实场景：电影院选座 *💡 核心必学*

**场景**：我们要管理一个电影院的座位状态（0=空，1=已占）。需要打印座位表，并统计空座。

```java
public class CinemaManager {
    public static void main(String[] args) {
        // 模拟座位：3排，每排4个座
        int[][] cinema = {
            {0, 0, 1, 1},
            {0, 1, 0, 0},
            {1, 1, 1, 1}
        };

        System.out.println("--- 屏幕方向 ---");
        
        int emptySeats = 0;

        // 嵌套循环遍历
        // 外层循环：控制"行" (row)
        for (int i = 0; i < cinema.length; i++) {
            
            // 内层循环：控制"列" (col)
            // 注意：列的上限是 cinema[i].length (当前行的长度)
            for (int j = 0; j < cinema[i].length; j++) {
                
                System.out.print(cinema[i][j] + "  "); // 打印座位状态
                
                if (cinema[i][j] == 0) {
                    emptySeats++;
                }
            }
            System.out.println(); // 每打印完一行，换行
        }
        
        System.out.println("剩余空座: " + emptySeats);
    }
}

```

### ✅ 2.2 工程规范 *🔥 实战必备*

#### 1. 打印二维数组

不要自己写双层循环去打印调试信息，Java 提供了神器。

```java
int[][] matrix = {{1, 2}, {3, 4}};

// ❌ 错误：System.out.println(matrix); -> 输出地址 [[I@1b6d...
// ❌ 错误：Arrays.toString(matrix);    -> 输出 [[I@1..., [I@2...] (还是地址)

// ✅ 正确：Arrays.deepToString(matrix)
System.out.println(Arrays.deepToString(matrix)); 
// 输出: [[1, 2], [3, 4]]

```

#### 2. 遍历顺序

永远推荐 **先遍历行，再遍历列**（如 2.1 中的代码）。

* **原因**：符合人类阅读习惯，且符合 CPU 缓存局部性原理（Cache Locality），性能最好。

---

## 第3部分：避坑进阶（What to Avoid）

### ⚠️ 3.1 “不规则数组” (Jagged Array)

因为二维数组是“数组的数组”，Java 允许每一行的长度不一样！这被称为**锯齿状数组**。

```java
// 动态初始化：只指定行数，不指定列数
int[][] jagged = new int[3][]; 

jagged[0] = new int[2];    // 第0行有2个元素
jagged[1] = new int[100];  // 第1行有100个元素
jagged[2] = new int[5];    // 第2行有5个元素

```

**陷阱**：
如果你在循环时不使用 `array[i].length` 而使用固定数字，就会发生越界错误。

* **规则**：处理二维数组时，**永远不要假设每一行等长**（虽然大多数时候是等长的），始终使用 `arr[i].length` 获取当前行的实际长度。

### ⚠️ 3.2 空指针地狱

如果你声明了二维数组但只初始化了一半，会发生什么？

```java
// 声明了有3行，但还没给这3行分配具体的子数组
int[][] arr = new int[3][]; 

// arr[0] 此时是 null
System.out.println(arr[0][0]); // 💥 NullPointerException (NPE)

```

**底层原因**：
回到 1.2 的内存图，主数组里的“抽屉”虽然造好了，但里面是空的（`null`），没有指向任何子数组。你试图去一个不存在的子数组里拿数据，程序自然崩溃。

──────────────────────────────────    
💡 总结与预告   
──────────────────────────────────    

**二维数组口诀**：

* 二维数组是套娃，一层更比一层深。
* `int[][]` 是声明，`new` 出行来再 `new` 列。
* `deepToString` 查数据，行列遍历最稳妥。

