**数组复制和扩容都涉及动态内存分配**（在堆上创建新对象）。但是，Java 采用了一种机制，使得程序员无需手动释放内存。

---

## 🔒 动态内存分配与垃圾回收机制

### 1\. C/C++ 的内存管理模型：手动模式

| 机制                    | C 语言操作                                                                 | 后果                                                                                                               |
| :---------------------- | :------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------- |
| **分配 (Allocation)**   | 程序员使用 `malloc()` 或 `calloc()` 函数在堆上申请内存。                   | 内存地址返回给程序员（指针）。                                                                                     |
| **释放 (Deallocation)** | 程序员必须使用 `free()` 函数明确释放不再需要的内存。                       | **危险和负担**：如果忘记释放，导致**内存泄漏 (Memory Leak)**；如果多次释放或释放正在使用的内存，导致**程序崩溃**。 |
| **数组扩容**            | 必须手动 `malloc` 新空间，然后使用 `memcpy` 复制数据，最后 `free` 旧空间。 | 复杂，容易出错。                                                                                                   |

### 2\. Java 的内存管理模型：自动模式

| 机制                    | Java 对应操作                                                                  | 结果                                                                    |
| :---------------------- | :----------------------------------------------------------------------------- | :---------------------------------------------------------------------- |
| **分配 (Allocation)**   | 程序员使用 `new` 关键字（例如 `new int[4]` 或 `new Object()`）创建对象。       | JVM 负责在堆上找到空间并分配，将地址返回给引用变量。                    |
| **释放 (Deallocation)** | **不需要手动操作！** JVM 中的**垃圾回收器 (Garbage Collector, GC)** 自动完成。 | **安全和便捷**：程序员无需关心释放，GC 会自动识别并清理不再使用的对象。 |
| **数组扩容**            | `ArrayList` 等集合内部创建新数组后，旧数组失去了引用，自动成为 GC 的目标。     | 简单，高效，安全。                                                      |

---

## 🔍 Java 为什么不需要手动释放内存？

Java 的设计哲学是让程序员专注于业务逻辑，而不是底层资源管理。实现这一目标的核心就是 **垃圾回收器 (GC)**。

### 1\. 垃圾回收器的原理

垃圾回收器的工作原理很简单，总结为一句话就是：

> **“如果堆上的某个对象没有任何引用（指针）指向它了，那么它就是垃圾，可以被安全地回收。”**

### 2\. 在数组扩容中的体现

以数组扩容为例：

1.  **旧数组 A**：`ArrayList` 的内部引用 `elementData` 原本指向数组 A。
2.  **创建新数组 B**：执行 `B = new int[M];`。新数组 B 在堆上创建。
3.  **引用转移**：`ArrayList` 将内部引用 `elementData` 改为指向新数组 B。
    ```java
    // 假设 elementData 是 ArrayList 内部的引用
    elementData = newArrayB;
    ```
4.  **自动回收**：此时，旧数组 A 不再有任何引用变量指向它（`elementData` 已经指向 B 了）。GC 会将旧数组 A 标记为\*\*“不可达”\*\*，在下一次回收周期中，GC 会自动清除 A 占用的内存。

### 总结

因为 Java 的 GC 机制，Java 程序员不需要、也不能手动释放内存。`new` 出来的对象（包括新数组）都由 GC 自动管理，从而彻底解决了 C/C++ 中常见的内存泄漏和野指针问题。
