## 第1部分：建立认知（What & Why）

### 📦 1.1 自动化的“酒店管理”

**传统噩梦 (C/C++)**：
想象你去住酒店。在 C++ 中，你（程序员）不仅要办理入住（申请内存 `malloc`），退房时还必须亲自打扫房间并通知前台（释放内存 `free`）。如果你忘了退房，房间就一直被锁着，没人能用——这就是**内存泄漏**。

**Java 的福音**：
Java 引入了一个隐形的“保洁阿姨”——**垃圾回收器 (Garbage Collector)**。

1. **动态分配**：你只需要说 `new User()`（我要入住），Java 自动在**堆 (Heap)** 中给你找个空地。
2. **自动回收**：当你不再使用这个对象时，你不需要做任何事。“保洁阿姨”会定期巡逻，发现没人用的房间，自动清理掉。

### ⚙️ 1.2 内存模型：Stack vs Heap

我们在数组章节简单提过，这里需要深化理解。

* **栈 (Stack)**：
  * **存什么**：局部变量、方法调用链。
  * **特点**：**用完即焚**。方法执行完，栈帧直接弹出，不需要 GC。
  * **生命周期**：极短，毫秒级。
* **堆 (Heap)**：
  * **存什么**：`new` 出来的所有对象（数组、User、String）。
  * **特点**：**GC 的主战场**。内存大，生命周期长。
  * **生命周期**：直到没人引用它为止。



**ASCII 动态演示**：

```java
public void method() {
    User u = new User(); // u 在栈，User对象在堆
    u = null;            // 剪断引用
    // 此时堆里的 User 对象变成了"孤儿"（垃圾）
}

```

```text
时刻 1: 正常持有
Stack (u)  -------->  Heap (User Object)

时刻 2: u = null
Stack (u)  --x      Heap (User Object) 
                      ^
                      |__ 没人抓着这根线了，它成了垃圾

```

---

## 第2部分：核心机制（How GC Works）

### 🔍 2.1 谁是垃圾？（可达性分析）

Java 怎么知道哪个对象是垃圾？       
**❌ 错误理解**：引用计数法（Reference Counting）。即“有一个人引用它计数+1，变成0就回收”。（Java **不用**这个，因为它解决不了循环引用问题）。       
**✅ 正确理解**：**可达性分析 (Reachability Analysis)**。

**原理**：
GC 会从一组被称为 **"GC Roots"** 的活跃对象开始，像顺藤摸瓜一样向下搜索。

* 能摸到的瓜（对象） = **存活**。
* 摸不到的瓜（对象） = **垃圾**（即使它们之间互相引用）。

**什么是 GC Roots？**

1. 栈中正在使用的变量（Local Variables）。
2. 类的静态变量（`static` 字段）。
3. 常量引用。

**ASCII 可达性图解**：

```text
    [GC Root: Stack变量]      [GC Root: static变量]
            |                          |
            v                          v
       [对象 A] <------------------ [对象 B]
            |
            v
       [对象 C]      <--- 这一串都是"可达的" (存活)

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       [对象 D] <----> [对象 E]   <--- 即使互相引用，
                                       但连不上 Root，
                                       统统判定为"垃圾"！

```

---

## 第3部分：避坑进阶（What to Avoid）

### ⚠️ 3.1 真的不会内存泄漏吗？

这是一个经典的面试坑。     
**误区**：“Java 有 GC，所以不会内存泄漏。”        
**真相**：**Java 依然会内存泄漏**，而且比 C++ 更难排查。

**场景：长生不老的静态集合**        
如果你把对象放进一个 `static` 的 `List` 或 `Map` 中，GC 会认为“这个集合是静态的（GC Root），所以集合里的元素都有用”。
哪怕你在业务逻辑中再也不用这些元素了，它们也**永远不会被回收**。

**❌ 内存泄漏代码示例**：

```java
public class MemoryLeakDemo {
    // static 变量生命周期与程序一样长，是坚固的 GC Root
    private static final List<byte[]> CACHE = new ArrayList<>();

    public void processData() {
        byte[] data = new byte[1024 * 1024]; // 1MB 巨型对象
        // 业务处理...
        
        // 💀 致命操作：把数据加到 static 列表里，但忘了删除
        CACHE.add(data); 
    }
}
// 随着 processData 被多次调用，内存会被占满，最终抛出 OutOfMemoryError (OOM)

```

**✅ 修复方案**：

1. 用完记得 `remove`。
2. 或者使用 `WeakReference`（弱引用）。

### 🌍 3.2 垃圾回收的代价 (Stop-The-World)

GC 不是免费的。当“保洁阿姨”打扫房间时，为了防止你乱丢垃圾，她有时候需要**把所有人都定住**。

这叫 **Stop-The-World (STW)**。

* 表现：你的 Java 程序会**完全暂停**几毫秒到几秒。
* 后果：如果是高频交易系统或游戏服务器，这种卡顿是致命的。

**工程思维**：
虽然我们不手动释放内存，但我们要**少制造垃圾**。

* **不要**在循环里频繁创建临时对象。
* **能复用**对象就复用（比如我们在数组扩容那节讲的，预设容量避免频繁扩容）。
