# ☕ Java 参数传递的终极真理

在 Java 的世界里，关于参数传递，只有一条**铁律**，请刻在脑子里：

> **Java 只有值传递 (Pass-by-Value)。** > **Java 只有值传递 (Pass-by-Value)。** > **Java 只有值传递 (Pass-by-Value)。**

哪怕是传数组、传对象，本质上依然是**传值**。根本不存在所谓的“引用传递”这一说。

为了彻底讲清楚，我们将情况分为两种：**基本数据类型** 和 **引用数据类型**。

---

## 1\. 场景一：基本数据类型的传递

**(int, double, boolean, char, etc.)**

这是最简单、最符合直觉的“值传递”。

### 📝 规则

当你调用方法时，Java 会把变量里的**具体数值**（比如 10, 3.14, true），**复制（Copy）** 一份，塞给方法里的参数。

- **基本类型数据传递 & 赋值操作** 的本质是：**将操作数的二进制值加载到 CPU 寄存器或操作数栈等临时空间中进行复制，再将该值副本写入目标变量的新内存空间。**
- 影响：你在方法里把复印件涂改成什么样，都绝不会影响我手里的**原件**。

### 🌰 代码演示

```java
public class Demo1 {
    public static void change(int a) {
        System.out.println("方法里收到的是：" + a);
        a = 999; // 修改复印件
        System.out.println("方法里修改后是：" + a);
    }

    public static void main(String[] args) {
        int num = 10; // 原件
        change(num);  // 传递 num 的值（10）的副本
        System.out.println("主方法里的原件是：" + num);
    }
}
```

**运行结果：**

> 方法里收到的是：10
> 方法里修改后是：999
> 主方法里的原件是：10 **(毫发无损)**

---

## 2\. 场景二：引用数据类型的传递

**(数组、String、自定义对象)**

这是最容易让人产生“引用传递”错觉的地方。但请记住，它依然是**值传递**。

### 📝 规则

当你调用方法时，Java 传递的**值**是什么？是**地址**（Address）。

- **变量存的是什么？** 引用变量（如 `int[] arr`）在栈里存的是堆内存的**地址值**（比如 `0x11A`）。
- **传递的是什么？** Java 会把这个**地址值**（`0x11A`），**复制（Copy）** 一份，塞给方法里的参数。

**这里有两个完全不同的操作，一定要分清：**

#### 操作 A：拿着复制的地址，去修改堆里的数据（✅ 会影响原数组）

这就像我也给你一把**复配的钥匙**（地址副本）。你拿着钥匙进了屋，把电视砸了。那我回家用原配钥匙进屋，看到的就是被砸烂的电视。

#### 操作 B：把复制的地址改掉，指向别处（❌ 不会影响原引用）

这就像我给你一把**复配的钥匙**。你转手把这把钥匙扔了，自己买了一把通往**隔壁老王家**的新钥匙。这对我的原配钥匙有影响吗？没有，我依然只能开自家门。

### 🌰 代码演示（核心！）

```java
public class Demo2 {

    // 操作 A：修改数据（砸电视）
    public static void changeData(int[] temp) {
        // temp 拿到了地址 0x11A，找到了堆内存
        temp[0] = 999;
    }

    // 操作 B：修改引用（扔钥匙）
    public static void changeRef(int[] temp) {
        // temp 依然拿到了地址 0x11A
        // 但这里让 temp 指向了新地址 0x22B (新房子)
        temp = new int[]{6, 6, 6};
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3}; // arr 存的是地址 0x11A

        // 测试操作 A
        changeData(arr);
        System.out.println("操作A后：" + arr[0]); // 输出 999 (变了！)

        // 测试操作 B
        changeRef(arr);
        System.out.println("操作B后：" + arr[0]); // 依然是 999 (没变！)
        // 如果是引用传递，arr 应该变成 {6, 6, 6}，但它没有。
    }
}
```

---

## 3\. 为什么说“Java 没有引用传递”？

如果 Java 有引用传递，那么上面的 `changeRef` 方法里，`temp = new int[]{...}` 这行代码执行后，主方法里的 `arr` **必须**跟着变成新数组。

**但在 Java 里，你永远无法改变调用者（main 方法）栈帧里的那个引用变量本身。**

### 🖼️ 形象的比喻（遥控器）

1.  **变量 `arr`**：是一个原配遥控器，对准了电视机 A。
2.  **方法调用**：Java 买了一个**一模一样的新遥控器 `temp`**（地址副本），也对准了电视机 A。
3.  **修改数据 (`temp[0] = 99`)**：你用新遥控器换台。原配遥控器看的时候，台确实变了。（因为电视机本身变了）。
4.  **修改引用 (`temp = new ...`)**：你把新遥控器 `temp` 摔了，买了个控制空调的遥控器。这对我的原配遥控器 `arr` 有影响吗？**没有任何影响**，它还是对准电视机 A。

---

## 🎯 终极总结

忘记之前的混乱，只记这两点：

1.  **基本类型传值**：传递的是**数据的副本**。修改副本，原件**不变**。
2.  **引用类型传值**：传递的是**地址的副本**。
    - 通过地址副本改**数据**（堆内存） $\rightarrow$ 原件**受影响**。
    - 通过地址副本改**指向**（本身存的地址） $\rightarrow$ 原件**不受影响**。

这就是 Java **“只有值传递”** 的全部真相。逻辑闭环，无懈可击！(o ﾟ v ﾟ)ノ
