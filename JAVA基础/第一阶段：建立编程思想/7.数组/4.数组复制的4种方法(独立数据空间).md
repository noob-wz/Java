很多初学者（甚至有经验的开发者）在处理数组复制时，容易混淆 **“引用复制”**、**“浅拷贝”** 和 **“深拷贝”**。

──────────────────────────────────

## 第1部分：建立认知（What & Why）

### 📦 1.1 赋值不是复制

首先必须明确铁律：**直接使用 `=` 赋值，不是复制数组，只是复制了“钥匙”。**

```java
int[] a = {1, 2, 3};
int[] b = a; // ❌ 这不是复制！a 和 b 指向同一块内存

```

如果你想得到一个**独立的副本**（修改副本不影响原件），你需要开辟新的堆内存空间，并将数据搬运过去。

---

## 第2部分：工程实践（How to Do Right）

使用 `for` 循环，这是最原始、最直观的复制方式，也是实现深拷贝的根本原理。

```java
int[] original = {10, 20, 30};
int[] copy = new int[original.length]; // 1. 手动创建目标数组

for (int i = 0; i < original.length; i++) {
    // 2. 逐一赋值，确保数据独立
    copy[i] = original[i];
}

// 验证独立性
copy[0] = 11;
System.out.println("Original[0]: " + original[0]); // 10
```

### ✅ 2.1 三大主流复制方式 *🔥 实战必备*

在 Java 业界开发中，我们主要使用以下三种方式。

#### 方式 1：Arrays.copyOf (推荐首选)

**特点**：代码最简洁，语义最清晰。底层依然调用 `System.arraycopy`。

```java
import java.util.Arrays;

int[] source = {1, 2, 3, 4, 5};

// 1. 完整复制
int[] copy = Arrays.copyOf(source, source.length);

// 2. 扩容复制 (ArrayList 扩容原理)
int[] larger = Arrays.copyOf(source, source.length * 2); 
// larger 变成 [1, 2, 3, 4, 5, 0, 0, 0, 0, 0]

// 3. 截断复制
int[] smaller = Arrays.copyOf(source, 2); 
// smaller 变成 [1, 2]

```

#### 方式 2：System.arraycopy (性能之王)

**特点**：**Native 方法**（直接调用 C++ 底层代码），速度最快，但参数复杂，容易写错。它是 JDK 源码（如 `ArrayList`）内部最常用的方式。

```java
int[] source = {10, 20, 30, 40, 50};
int[] target = new int[5];

// 参数：源数组, 源起始位置, 目标数组, 目标起始位置, 拷贝长度
// 场景：将 source 的 [20, 30] 搬运到 target 的前两位
System.arraycopy(source, 1, target, 0, 2);

// target 变成 [20, 30, 0, 0, 0]

```

#### 方式 3：Object.clone() (简单粗暴)

**特点**：语法最简短，生成的数组长度与原数组一致。
*注意：虽然简单，但因为 `clone()` 在 Java 设计模式中口碑不佳（机制复杂），部分规范推荐用 `Arrays.copyOf` 代替，但在数组复制场景下它是安全的。*

```java
int[] source = {1, 2, 3};
int[] copy = source.clone();

```

---

### 📊 2.2 性能与选择决策

| 方式 | 性能 | 可读性 | 灵活性 | 推荐场景 |
| --- | --- | --- | --- | --- |
| **Arrays.copyOf** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 高 (可变长) | **日常业务开发首选** |
| **source.clone()** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 低 (定长) | 仅需生成完全一样的副本时 |
| **System.arraycopy** | ⭐⭐⭐⭐⭐ | ⭐⭐ | 极高 (可局部) | **写底层框架/算法**，或处理海量数据 |
| **for 循环手动搬** | ⭐⭐ | ⭐⭐ | - | 除非要在复制时修改数据，否则**不要用** |

---

## 第3部分：避坑进阶（浅拷贝 vs 深拷贝）

这是数组复制中最隐蔽的**核弹级陷阱**。

### ⚠️ 3.1 浅拷贝 (Shallow Copy) 陷阱

**所有上述三种方式（copyOf, clone, arraycopy），都是浅拷贝！**

* **对于基本类型 (`int[]`)**：没有问题，数据完全复制了。
* **对于引用类型 (`User[]`, `String[]`)**：**只复制了对象的地址，没有复制对象本身！**

**演示代码：**

```java
class Dog {
    String name;
    Dog(String name) { this.name = name; }
    
    @Override 
    public String toString() { return name; }
}

public class ShallowCopyTrap {
    public static void main(String[] args) {
        Dog[] kennel1 = { new Dog("小白"), new Dog("小黑") };
        
        // 复制数组
        Dog[] kennel2 = Arrays.copyOf(kennel1, kennel1.length);
        
        // 🚨 陷阱触发：修改 kennel2 中的对象
        kennel2[0].name = "大黄";
        
        // 😱 原数组 kennel1 也变了！
        System.out.println(kennel1[0]); // 输出 "大黄"
    }
}

```

**底层内存图解 (ASCII)**：

```text
kennel1 (Array)       Heap (Object)      kennel2 (Array)
+-------------+       +-----------+      +-------------+
| [0]: 0x1A   |------>| Dog: 小白 |<-----| [0]: 0x1A   |
+-------------+       +-----------+      +-------------+
| [1]: 0x2B   |--\                       | [1]: 0x2B   |
+-------------+   \   +-----------+      +-------------+
                   \->| Dog: 小黑 |
                      +-----------+

```

**结论**：`kennel1` 和 `kennel2` 是两个不同的数组盒子，但装的是**通往同一个 Dog 的遥控器**。

---

### 🚀 3.2 深拷贝 (Deep Copy) 解决方案

如果你需要两组完全独立的 `Dog`，必须手动进行**深拷贝**。

**Java 没有提供一行代码的深拷贝方法**，你必须自己写循环，手动 `new` 新对象。

```java
// ✅ 正确的深拷贝做法
Dog[] deepCopy = new Dog[kennel1.length];

for (int i = 0; i < kennel1.length; i++) {
    // 关键：手动 new 一个新对象，并复制属性
    deepCopy[i] = new Dog(kennel1[i].name);
}

// 现在修改 deepCopy 不会影响 kennel1
deepCopy[0].name = "大黄";
System.out.println(kennel1[0]); // 依然是 "小白"

```

──────────────────────────────────      
💡 总结        
──────────────────────────────────

1. **日常复制**：首选 `Arrays.copyOf(arr, len)`。
2. **高性能/局部复制**：使用 `System.arraycopy`。
3. **引用类型数组**：务必警惕**浅拷贝**！如果对象是可变的（如 `User`），复制数组后修改对象属性会影响原数组。

