一句话：**匿名内部类定义在“表达式 (Expression)”内部，而不是普通的“语句块”里。**

它就像是一个 **“寄生虫”**，必须依附在 `new` 关键字（创建对象的操作）上才能存活。它没有自己的地盘，只能挤在别人的语句里。

让我们看看它最常出现的**三个“藏身之处”**：

---

### 1. 📍 藏在“成员变量初始化”中 (作为字段)

这是它“地位最高”的时候。它直接作为外部类的一个成员变量（字段）的值存在。

**场景**：你需要一个全局通用的监听器或工具对象。

```java
public class Button {
    // 💡 这里：直接在定义成员变量 listener 时，顺手定义了一个匿名类
    // 它随着 Button 对象的创建而创建
    private ActionListener listener = new ActionListener() { 
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("默认点击行为");
        }
    }; // 👈 注意这里必须有分号，因为这是一句赋值语句！
    
    public void click() {
        listener.actionPerformed(null);
    }
}

```

* **位置特点**：定义在类体（Class Body）中，作为字段初始化的一部分。
* **生命周期**：跟随外部类对象（Button）共存亡。

---

### 2. 📍 藏在“局部变量赋值”中 (作为方法内的变量)

这是初学者最容易理解的形式。你在方法里需要一个对象，但不想新建一个类文件，于是“现场捏一个”。

**场景**：在方法内部逻辑中，临时需要一个对象。

```java
public void task() {
    // 💡 这里：定义在方法内部
    Runnable worker = new Runnable() {
        @Override
        public void run() {
            System.out.println("临时工干活...");
        }
    }; // 👈 同样需要分号
    
    new Thread(worker).start();
}

```

* **位置特点**：定义在方法体（Method Body）的局部变量赋值语句中。
* **生命周期**：方法执行时创建，如果没人引用它，方法结束就可能被回收。

---

### 3. 📍 藏在“方法参数”中 (最经典用法！)

这是匿名内部类最核心、最“骚气”的用法，也是 Java 试图模拟“函数式编程”的极限操作。

**场景**：我不需要把这个对象存下来，我只需要把它的**行为**传给另一个方法。

```java
File folder = new File("C:/tmp");

// 💡 这里：直接塞在方法的圆括号 ( ) 里面！
// 我们没有把 new FileFilter()... 赋值给任何变量，直接传进去了
folder.listFiles(new FileFilter() {
    @Override
    public boolean accept(File pathname) {
        return pathname.getName().endsWith(".txt");
    }
}); 

```

* **位置特点**：定义在方法调用的参数列表中。**这是“即用即毁”的极致体现。**
* **大厂视角**：在 Lambda 出现之前，这是 Android 开发和 GUI 编程中 90% 的代码形态（回调地狱的源头）。

---

### 🔬 深度辨析：它和“局部内部类”有什么区别？

很多人会把**匿名内部类**和 **局部内部类（Local Inner Class）** 搞混。位置很像，但有本质区别。

| 特性 | 局部内部类 (Local Inner Class) | 匿名内部类 (Anonymous Inner Class) |
| --- | --- | --- |
| **定义位置** | 方法体内，但在语句之间 | **表达式内部** (依附于 `new`) |
| **是否有名字** | **有** (如 `class Task {...}`) | **无** (只有 `new 接口/父类`) |
| **复用性** | 在该方法内可以 `new` 多次 | **只能 `new` 一次** (定义即实例化) |
| **代码形态** | 先定义类，再使用 | 定义类和创建对象同时发生 |

**对比代码：**

```java
public void test() {
    // 1. 局部内部类：我有名字，叫 Worker
    class Worker implements Runnable {
        public void run() {}
    }
    new Worker().run(); // 可以多次 new
    new Worker().run(); 

    // 2. 匿名内部类：我没名字，只能用这一次
    new Runnable() {
        public void run() {}
    }.run(); 
}

```

---

### 📊 总结图谱

匿名内部类的“物理位置”图谱：

```text
Class Body (类体)
 │
 ├─ Field Initializer (字段初始化) ────> 可以定义!
 │   └─ private Runnable r = new Runnable() { ... };
 │
 └─ Method Body (方法体)
     │
     ├─ Variable Assignment (变量赋值) ──> 可以定义!
     │   └─ Runnable r = new Runnable() { ... };
     │
     ├─ Method Argument (方法参数) ──────> 最常用!
     │   └─ thread.start(new Runnable() { ... });
     │
     └─ Return Statement (返回值) ───────> 可以定义!
         └─ return new Runnable() { ... };

```

**💡 经验法则：**
只要代码里能写 `new ClassName()` 的地方，就能把它扩展成匿名内部类 `new ClassName() { ... }`。它就是一种**就地展开**的语法糖。