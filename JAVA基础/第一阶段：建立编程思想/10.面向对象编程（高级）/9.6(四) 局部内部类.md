### 第四部：局部内部类 —— “一次性的专用工具”

#### 💡 1. 第一性原理：为什么要给“临时工”起名字？

我们在上一章讲过，**匿名内部类**（`new Interface() {...}`）是“临时工”，为了解决“一次性”的需求。

但如果你的需求变复杂了呢？

**场景推演：**
假设你在写一个 `solveMathProblem()` 方法。在这个方法里，你需要处理一种很特殊的数据结构，比如“复数（ComplexNumber）”。

1. 这个“复数”逻辑很复杂，需要有**构造函数**，有字段，有多个方法。
2. 而且，你在同一个方法里，需要创建**好几个**“复数”对象来运算。

**这时候你会陷入两难：**

* ❌ **用成员内部类？** 不行。这个“复数”逻辑只有 `solveMathProblem` 方法用，把它写在外面，会被别的同事看到，污染了类的命名空间（封装性不够极致）。
* ❌ **用匿名内部类？** 不行。匿名内部类没有名字，你没办法定义一次，然后 `new` 三次。而且匿名类没法写构造函数。

**🎯 设计者的方案：**
允许你在方法**内部**定义一个**有名字的类**。
这就是 **局部内部类**。

**【生活化比喻：木工的临时夹具】**

* **成员内部类**：木工坊里的**大锯台**。所有工人都看得到，都能用，是工坊的基础设施。
* **匿名内部类**：随手撕下来的**一张砂纸**。擦一下就扔了，不需要名字。
* **局部内部类**：木工为了做某件特定的家具，在现场用废料搭的一个**临时夹具**。
  * 它就在手边（方法内）。
  * 做这件家具时（方法执行中）可以用好几次。
  * 家具做完了，这堆废料就拆了，没人知道它的存在。

---

#### 🔬 2. 语法解剖：藏得最深的类

它的定义位置非常刁钻：**在方法的大括号 `{ ... }` 里面**。

```java
public class Carpenter { // 木工
    
    public void buildChair() { // 方法：做椅子
        
        // 🔒 1. 定义：这是一个局部内部类
        // 它藏在 buildChair 方法里，出了这个方法，没人认识它！
        class Jig { // 夹具
            int angle;
            
            // ✅ 可以有构造函数（匿名内部类做不到）
            public Jig(int angle) {
                this.angle = angle;
            }
            
            void fix() {
                System.out.println("使用夹具固定角度：" + angle);
            }
        }
        
        // 🔒 2. 使用：在方法内部，可以多次复用！
        Jig legFixer = new Jig(90);  // 做腿的夹具
        Jig backFixer = new Jig(105); // 做靠背的夹具
        
        legFixer.fix();
        backFixer.fix();
    }
    
    public void buildTable() {
        // ❌ 报错！
        // 隔壁方法根本不知道 Jig 的存在
        // Jig j = new Jig(90); 
    }
}

```

**🔍 关键特征（面试考点）：**

1. **没有修饰符**：它就像局部变量（`int a`）一样，不能加 `public`, `private`, `protected`，甚至不能加 `static`（Java 16 之前）。因为它的作用域被死死锁在方法里，谈论访问权限没有意义。
2. **双重访问权**：
   * 它能访问**外部类**的所有成员（包括 `private`）。
   * 它能访问**当前方法**的局部变量（必须是 `final` 或事实上的 `final`）。

---

#### 📊 3. 内存视角：它的“户口”在哪？

你可能会问：*“方法执行完，栈帧销毁了，局部变量都死了，这个类还存在吗？”*

这里的逻辑和匿名内部类**完全一样**（因为匿名类本质上就是特殊的局部内部类）。

1. **编译后**：会生成一个独立的 `.class` 文件。
   * 名字格式：`外部类$序号+内部类名.class`
   * 例如：`Carpenter$1Jig.class`（加序号是为了防止不同方法里有同名的局部类）。

2. **运行时**：
   * 当 `buildChair()` 执行时，`Jig` 类的定义被加载。
   * `new Jig()` 创建的对象存在于 **堆（Heap）** 中。
   * 如果 `Jig` 对象被传出去了（比如作为返回值返回），即使 `buildChair()` 方法结束了，`Jig` 对象依然活着！
   * **变量捕获**：同样，如果它用了方法的局部变量，也是**复制副本**，并要求变量不可变。

---

#### ⚔️ 4. 终极对比：四兄弟怎么选？

到现在为止，我们学完了 Java 所有的内部类。在实际开发（或大厂面试）中，如何快速决策用哪一个？

我为你总结了一张 **“决策决策树”**：

**🤔 你的需求是什么？**

1. **Q: 这个类需要访问外部类的实例变量（`this.xxx`）吗？**
   * **NO (不需要)** 👉 **静态嵌套类 (Static Nested Class)**
     * *理由*：最干净，省内存，防泄漏。比如 `Builder`，`Utils`。
   * **YES (需要)** 👉 继续下一题。

2. **Q: 这个类需要在很多方法里通用，还是只在一个方法里用？**
   * **很多方法通用** 👉 **成员内部类 (Member Inner Class)**
     * *理由*：就像心脏，属于整个身体。比如 `Iterator`。
   * **只在一个方法里用** 👉 继续下一题。

3. **Q: 这个逻辑需要用好几次（复用），或者需要构造函数吗？**
   * **YES (要复用/要构造器)** 👉 **局部内部类 (Local Inner Class)**
     * *理由*：有名字方便复用，定义在方法里保证封装。
   * **NO (只用一次)** 👉 **匿名内部类 (Anonymous Inner Class)**
     * *理由*：懒得起名，写完即扔。比如 `new Runnable()`, `new ActionListener()`。





---

### 总结

**局部内部类**是 Java 设计者对于“封装性”的一种执着体现。
它说：“如果这个逻辑只有你知道，那就把它烂在你的肚子里（方法里），不要让它去污染外面的世界。”

虽然在现代 Java 开发中，随着 Lambda 的普及，局部内部类和匿名内部类的出场率都在下降，但理解它们，是你理解 **Java 闭包（Closure）** 和 **作用域（Scope）** 机制的必经之路。

至此，Java 内部类家族（Inner Class Family）全员集结完毕！
你现在对它们的关系和底层原理是否已经胸有成竹了？