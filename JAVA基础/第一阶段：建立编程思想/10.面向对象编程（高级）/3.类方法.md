**类方法（Static Method）**，在 Java 世界里是一个非常特殊的存在。如果说实例方法是 **“对象的技能”**，那么类方法就是 **“上帝的工具”**。

──────────────────────────────────

## 第1部分：建立认知（What & Why）

### 📦 1.1 核心定义 *💡 核心必学*

**定义**：被 `static` 修饰的方法。
**本质**：它是一段**“无状态”**或者是**“操作类级数据”**的代码逻辑。

**它与普通方法的根本区别（JVM 视角）**：
还记得刚才我们聊的 `this` 传递吗？

* **实例方法**：JVM 会悄悄塞一个 `this` 引用进去（局部变量表第0位）。
* **类方法**：JVM **绝不会**塞 `this` 进去。它“六亲不认”，不知道是谁调用的它，只认输入参数。

```java
public class MathUtils {
    // 类方法：工具人
    // 翻译成机器语言：Input(a, b) -> Process -> Output
    // 这种方法也被称为“纯函数 (Pure Function)”
    public static int add(int a, int b) {
        return a + b;
    }

    // 实例方法：依赖对象状态
    // 隐含参数：(User this)
    public void sayHello() {
        // 只有这里能用 this
        System.out.println("Hello " + this.name); 
    }
}

```

---

### ⚙️ 1.2 底层原理：`invokestatic` *⭐ 进阶选学*

在字节码层面，Java 对这两种方法的调用指令是完全不同的。这决定了它们的多态特性。

**对比实验**：

```java
User u = new User();

// 1. 调用实例方法
u.sayHello(); 
// 字节码指令: invokevirtual
// 含义：去 u 指向的对象头里找，看它的实际类型是谁，然后决定调哪个方法（动态绑定）。

// 2. 调用类方法
User.add(1, 2);
// 字节码指令: invokestatic
// 含义：编译的时候就确定了！直接去 User 类的元空间找 add 方法。根本不看对象是谁。（静态绑定）

```

**关键推论**：
因为 `invokestatic` 是编译期确定的（静态绑定），所以**类方法不支持“重写（Override）”**。你不能通过子类覆盖父类的静态方法来实现多态。（详见阶段3）

---

## 第2部分：工程实践（How to Do Right）

### 🌍 2.1 真实场景：什么时候该用 Static？

**决策树**：

```
编写一个新方法时...
  |
  ├─ 1. 方法内部需要访问实例变量(this.xxx)吗？
  |      ├─ YES ─> 必须是实例方法 (非static)
  |      └─ NO  ─> 进入下一题
  |
  ├─ 2. 方法内部需要调用其他的实例方法(this.method())吗？
  |      ├─ YES ─> 必须是实例方法 (非static)
  |      └─ NO  ─> 进入下一题
  |
  └─ 3. 结论：这应该是一个 static 方法 (工具方法/工厂方法)

```

**✅ 场景 A：工具类 (Utility)**
不依赖任何对象状态，给个输入吐个输出。
例如：`Math.abs()`, `StringUtils.isEmpty()`, `Collections.sort()`.

**✅ 场景 B：静态工厂 (Static Factory Method)**
比构造器更优雅的对象创建方式。

```java
// 现代写法：使用静态方法代替构造器
public class User {
    private String type;
    
    // 私有化构造器
    private User(String type) { this.type = type; }

    // 静态工厂方法：名字具有业务含义
    public static User createAdmin() {
        return new User("ADMIN");
    }

    public static User createGuest() {
        return new User("GUEST");
    }
}

// 调用：语义清晰
User admin = User.createAdmin();

```

---

### ✅ 2.2 工程规范 *🔥 实战必备*

#### 🟢 GREEN（推荐）

**1. 优先将工具方法放入接口 (Java 8+)**
以前我们喜欢写 `XXXUtils` 类（如 `CollectionUtils`）。Java 8 以后，允许接口中有 `static` 方法。现在推荐直接把工具方法写在接口里。

```java
// Java 17+ 风格
public interface Calculator {
    
    // 接口里的静态方法，天然的工具箱
    static int add(int a, int b) {
        return a + b;
    }
}

```

#### 🔴 RED（禁止）

**1. 禁止通过对象引用调用静态方法**
虽然 Java 编译器允许 `user.add(1, 2)`，但这极具误导性。阅读代码的人会以为 `add` 依赖于 `user` 对象。

```java
User u = null;
// ❌ 极差的代码风格
// 诡异现象：u 是 null，但这里不会报空指针异常！
// 原因：编译器看到 u 的类型是 User，直接把它替换成了 User.sayHi()
u.sayHi(); 

// ✅ 正确写法
User.sayHi();

```

---

## 第3部分：避坑进阶（What to Avoid & Beyond）

### ⚠️ 3.1 常见陷阱：静态访问非静态

**报错信息**：
`Non-static field 'name' cannot be referenced from a static context`

**根本原因（生命周期维度）**：

* **Static Context**：类加载时就存在了（图纸阶段）。
* **Non-static**：`new` 出来之后才存在（造车阶段）。

你在“图纸”里通过 `System.out.println(name)` 喊一声，此时车还没造出来，哪里来的 `name`？

**❌ 错误示范**：

```java
public class App {
    String appName = "MyApp"; // 实例变量

    public static void main(String[] args) {
        // main 是 static 的
        // 试图访问 appName -> 编译器崩溃
        System.out.println(appName); 
    }
}

```

**✅ 修复方案**：
要么把 `appName` 也变成 `static`，要么创建对象去访问。

---

### ⚠️ 3.2 进阶面试题：静态方法能“重写”吗？

这是一个经典的坑。

**现象**：

```java
class Animal {
    public static void test() { System.out.println("Animal"); }
}

class Cat extends Animal {
    // 看起来像是重写，其实是“隐藏 (Hiding)”
    public static void test() { System.out.println("Cat"); }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Cat(); // 多态：引用是 Animal，实际是 Cat
        a.test(); // 输出什么？
    }
}

```

**输出结果**：
`Animal` (!!!)

**深度解析**：

1. **实例方法**：看**运行时**的实际对象（`new Cat()`），所以会调 `Cat` 的方法（动态绑定）。
2. **静态方法**：看**编译时**的引用类型（`Animal a`）。编译器看到 `a` 是 `Animal` 类型，且调用的是 `static` 方法，直接绑定死指令：`invokestatic Animal.test`。它根本不关心运行时 `a` 到底指向谁。

**结论**：
静态方法不存在多态，**永远不要试图通过继承来修改静态方法的行为**。

---

### 🎓 实战挑战

**场景**：
你需要设计一个简单的日志工具 `Logger`。

**要求**：

1. 提供一个 `log(String msg)` 方法。
2. 为了方便使用，不想让用户每次都 `new Logger()`。
3. **核心挑战**：需要在日志里记录下当前的时间戳（使用 `Instant.now()`），并且前缀是可以配置的（例如 `[INFO]`）。

**请补充/修复以下代码**：

```java
public class Logger {
    // TODO: 1. 这里应该用什么修饰符？
    String prefix = "[INFO] ";

    public static void log(String msg) {
        // TODO: 2. 这里能直接访问 prefix 吗？如果不能，该怎么办？
        System.out.println(prefix + Instant.now() + ": " + msg);
    }
}

```

📝 **请提交你的代码，我会从“JVM内存访问”的角度点评。**