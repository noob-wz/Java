# 匿名内部类 vs 局部内部类：深度对比与核心差异

---

## 第一部分：核心区别全景图

### 1.1 根本差异对照表

| 特性 | 局部内部类 | 匿名内部类 |
|------|-----------|-----------|
| **有无类名** | ✅ 有程序员指定的名字 | ❌ 无名字（编译器生成名字） |
| **能否定义构造器** | ✅ 可以 | ❌ 不可以 |
| **如何初始化** | 构造器 + 实例初始化块 | 仅实例初始化块 |
| **能否创建多个实例** | ✅ 可以（通过类名） | ✅ 可以（但需要重复定义语句） |
| **继承/实现限制** | 可以extends或implements | 只能extends一个类或implements一个接口 |
| **何时定义类** | 定义和使用分离 | 定义和实例化同时进行 |
| **编译后类名** | `Outer$N局部类名` | `Outer$N` |

### 1.2 定义语法对比

**局部内部类：**

```java
public void method() {
    // 定义局部内部类
    class LocalInner {
        private int value;
        
        // ✅ 可以定义构造器
        LocalInner(int value) {
            this.value = value;
        }
        
        void display() {
            System.out.println(value);
        }
    }
    
    // 使用类名创建实例
    LocalInner obj1 = new LocalInner(10);
    LocalInner obj2 = new LocalInner(20);
    LocalInner obj3 = new LocalInner(30);
}
```

**匿名内部类：**

```java
public void method() {
    // 定义并创建实例（同时进行）
    Runnable r1 = new Runnable() {
        private int value = 10;
        
        // ❌ 不能定义构造器
        // Runnable() { } // 编译错误
        
        // ✅ 使用实例初始化块
        {
            value = 100;
        }
        
        @Override
        public void run() {
            System.out.println(value);
        }
    };
    
    // 要创建第二个实例，必须重复整个定义
    Runnable r2 = new Runnable() {
        private int value = 20;
        {
            value = 200;
        }
        @Override
        public void run() {
            System.out.println(value);
        }
    };
}
```

---

## 第二部分：深入理解"创建多个实例"

这是最容易产生困惑的地方！

### 2.1 局部内部类：一个类，多个实例

```java
public void method() {
    class Counter {
        private int count;
        
        Counter(int count) {
            this.count = count;
        }
        
        void increment() {
            count++;
        }
        
        int getCount() {
            return count;
        }
    }
    
    // 同一个类Counter，创建3个不同的实例
    Counter c1 = new Counter(0);
    Counter c2 = new Counter(10);
    Counter c3 = new Counter(100);
    
    c1.increment();  // c1.count = 1
    c2.increment();  // c2.count = 11
    c3.increment();  // c3.count = 101
    
    System.out.println(c1.getClass());  // class Outer$1Counter
    System.out.println(c2.getClass());  // class Outer$1Counter (同一个类)
    System.out.println(c3.getClass());  // class Outer$1Counter (同一个类)
    
    System.out.println(c1.getClass() == c2.getClass());  // true
}
```

**编译后只生成一个类文件：**
```
Outer$1Counter.class
```

**关键点：**
- 定义一次，就是一个类
- 可以通过类名`Counter`创建任意多个实例
- 所有实例共享同一个类定义

### 2.2 匿名内部类：重复定义 vs 循环创建

这是你困惑的核心！让我们分三种情况讨论：

#### 情况1：重复定义（不同的匿名类）

```java
public void method() {
    Runnable r1 = new Runnable() {  // 第一个匿名类
        @Override
        public void run() {
            System.out.println("r1");
        }
    };
    
    Runnable r2 = new Runnable() {  // 第二个匿名类（定义完全一样）
        @Override
        public void run() {
            System.out.println("r2");
        }
    };
    
    System.out.println(r1.getClass());  // class Outer$1
    System.out.println(r2.getClass());  // class Outer$2 (不同的类！)
    
    System.out.println(r1.getClass() == r2.getClass());  // false
}
```

**编译后生成两个类文件：**
```
Outer$1.class
Outer$2.class
```

**关键点：**
- 每次写`new Runnable() { ... }`都定义了一个新的匿名类
- 即使代码完全相同，也是不同的类
- 这就是你说的"循环保证类名唯一"的含义，但不太准确

#### 情况2：循环中的匿名内部类（同一个类，多个实例）

```java
public void method() {
    List<Runnable> tasks = new ArrayList<>();
    
    for (int i = 0; i < 3; i++) {
        final int index = i;
        Runnable r = new Runnable() {  // 看起来定义了3次
            @Override
            public void run() {
                System.out.println("Task " + index);
            }
        };
        tasks.add(r);
    }
    
    // 关键问题：这3个Runnable是同一个类吗？
    System.out.println(tasks.get(0).getClass());  // class Outer$1
    System.out.println(tasks.get(1).getClass());  // class Outer$1 (同一个类！)
    System.out.println(tasks.get(2).getClass());  // class Outer$1 (同一个类！)
    
    System.out.println(
        tasks.get(0).getClass() == tasks.get(1).getClass()
    );  // true
}
```

**编译后只生成一个类文件：**
```
Outer$1.class
```

**为什么循环本应该执行三次，最后却只定义了一个匿名类？**

**答：类是在编译时定义的（看代码结构），对象是在运行时创建的（看执行逻辑）。**

```java
// 源代码
for (int i = 0; i < 3; i++) {
    // 编译器看到这里：
    // "哦，这里有一个 new Runnable() { ... } 的定义结构"
    // "好的，我把它单独提取出来，生成一个名为 Outer$1.class 的文件"
    Runnable r = new Runnable() { ... }; 
}

// ‼️ 编译器的视角：只数“位置”，不数“次数”
// 编译期，只看源代码几个地方定义了类，而不会动态运行，定义几次只看“固定的位置”

//  编译器的逻辑是这样的：
//  1. 它从上往下读代码。
//  2. 它在第 X 行看到了一个匿名内部类的语法结构（也就是那对 { ... }）。
//  3. 于是它生成一个 class 文件（比如 Outer$1.class）。
//  4. 它把源代码里的 new Runnable() { ... } 替换成类似 new Outer$1() 的指令。

//  编译器根本不去运行那个 for 循环！ 它不知道也不在乎这个循环是跑 1 次，100 万次，还是 0 次。它只知道：“在源代码的这个物理位置，有一个类定义。”
//  所以，源代码里写了一次 {}，就只有一个类。
```

#### 情况3：循环中的重复定义（多个不同的类）

```java
public void method() {
    // 注意：这不是循环，是手写3遍
    Runnable r1 = new Runnable() {  // 定义第1个匿名类
        public void run() { System.out.println("1"); }
    };
    
    Runnable r2 = new Runnable() {  // 定义第2个匿名类
        public void run() { System.out.println("2"); }
    };
    
    Runnable r3 = new Runnable() {  // 定义第3个匿名类
        public void run() { System.out.println("3"); }
    };
    
    System.out.println(r1.getClass());  // class Outer$1
    System.out.println(r2.getClass());  // class Outer$2
    System.out.println(r3.getClass());  // class Outer$3
}
```

**编译后生成三个类文件：**
```
Outer$1.class
Outer$2.class
Outer$3.class
```

### 2.3 关键结论

**局部内部类：**
```
定义1次 → 生成1个类 → 可以创建N个实例
```

**匿名内部类：**
```
情况1（循环）：定义1次 → 生成1个类 → 循环创建N个实例
情况2（重复定义）：定义N次 → 生成N个类 → 每个类1个实例
```

---

## 第三部分：编译机制深度对比

### 3.1 类名生成规则

**局部内部类：**

```java
public class Outer {
    public void method() {
        class Local1 { }  // 编译后：Outer$1Local1.class
        class Local2 { }  // 编译后：Outer$2Local2.class
    }
    
    public void anotherMethod() {
        class Local3 { }  // 编译后：Outer$3Local3.class
    }
}
```

**命名规则：** `外部类名$数字+局部类名.class`

**匿名内部类：**

```java
public class Outer {
    public void method() {
        Runnable r1 = new Runnable() { };  // 编译后：Outer$1.class
        Runnable r2 = new Runnable() { };  // 编译后：Outer$2.class
    }
    
    public void anotherMethod() {
        Runnable r3 = new Runnable() { };  // 编译后：Outer$3.class
    }
}
```

**命名规则：** `外部类名$数字.class`

### 3.2 混合使用时的编号

```java
public class Outer {
    public void method() {
        class Local1 { }              // Outer$1Local1.class
        
        Runnable r1 = new Runnable() { };  // Outer$2.class
        
        class Local2 { }              // Outer$3Local2.class
        
        Runnable r2 = new Runnable() { };  // Outer$4.class
    }
}
```

**规律：** 数字按照在源文件中出现的顺序递增，不区分类型。

### 3.3 字节码结构对比

**局部内部类编译后：**

```java
// 源代码
class LocalInner {
    private int value;
    
    LocalInner(int value) {
        this.value = value;
    }
}

// 编译后等价于
class Outer$1LocalInner {
    final Outer this$0;  // 外部类引用
    private int value;
    
    Outer$1LocalInner(Outer outer, int value) {  // 构造器添加外部类参数
        this.this$0 = outer;
        this.value = value;
    }
}
```

**匿名内部类编译后：**

```java
// 源代码
Runnable r = new Runnable() {
    private int value = 10;
    
    {
        value = 100;  // 实例初始化块
    }
    
    public void run() { }
};

// 编译后等价于
class Outer$1 implements Runnable {
    final Outer this$0;
    private int value;
    
    Outer$1(Outer outer) {
        this.this$0 = outer;
        this.value = 10;  // 字段初始化在构造器中
        this.value = 100; // 实例初始化块代码也在构造器中
    }
    
    public void run() { }
}
```

---

## 第四部分：初始化机制详解

### 4.1 局部内部类的初始化

局部内部类可以使用**三种**初始化方式：

```java
class LocalInner {
    private int a;
    private int b;
    private int c;
    
    // 1. 字段声明时初始化
    private int d = 40;
    
    // 2. 实例初始化块
    {
        b = 20;
    }
    
    // 3. 构造器
    LocalInner(int a) {
        this.a = a;
        this.c = 30;
    }
}

LocalInner obj = new LocalInner(10);
// obj.a = 10 (构造器)
// obj.b = 20 (实例初始化块)
// obj.c = 30 (构造器)
// obj.d = 40 (字段初始化)
```

**执行顺序：**

```
1. 字段声明时的初始化（d = 40）
2. 实例初始化块（b = 20）
3. 构造器（a = 10, c = 30）
```

### 4.2 匿名内部类的初始化

匿名内部类只能使用**两种**初始化方式：

```java
Runnable r = new Runnable() {
    private int a;
    private int b;
    
    // 1. 字段声明时初始化
    private int c = 30;
    
    // 2. 实例初始化块
    {
        a = 10;
        b = 20;
    }
    
    // ❌ 3. 不能定义构造器
    // Runnable() { } // 编译错误
    
    public void run() { }
};
```

**执行顺序：**

```
1. 字段声明时的初始化（c = 30）
2. 实例初始化块（a = 10, b = 20）
```

### 4.3 传递参数给父类构造器

这是两者的重要区别：

**局部内部类：**

```java
abstract class Base {
    protected String name;
    
    Base(String name) {
        this.name = name;
    }
}

// 局部内部类：可以在构造器中调用super
class LocalChild extends Base {
    private int age;
    
    LocalChild(String name, int age) {
        super(name);  // ✅ 调用父类构造器
        this.age = age;
    }
}

LocalChild obj = new LocalChild("Alice", 25);
```

**匿名内部类：**

```java
abstract class Base {
    protected String name;
    
    Base(String name) {
        this.name = name;
    }
}

// 匿名内部类：在new表达式中传参
Base obj = new Base("Bob") {  // ✅ 参数传给父类构造器
    private int age = 30;
    
    // 不能定义构造器，无法在构造器中调用super
};
```

---

## 第五部分：作用域与可见性

### 5.1 作用域范围

**局部内部类：**

```java
public void method() {
    // 定义位置
    class LocalInner {
        void display() {
            System.out.println("Local");
        }
    }
    
    // 作用域：从定义处到方法结束
    LocalInner obj1 = new LocalInner();  // ✅ 可以使用
    
    if (true) {
        LocalInner obj2 = new LocalInner();  // ✅ 仍然可以使用
    }
}

public void anotherMethod() {
    // LocalInner obj = new LocalInner();  // ❌ 编译错误：不可见
}
```

**匿名内部类：**

```java
public void method() {
    Runnable r1 = new Runnable() {
        public void run() { }
    };
    // 作用域：从定义处到方法结束
    
    // 但不知道类名是什么，想要创建同样的类的另一个实例？不可能！
    // 只能重新定义（创建新类）
}
```

### 5.2 访问外部变量

**两者完全相同：**

```java
public void method() {
    final int x = 10;
    String s = "hello";
    
    // 局部内部类
    class LocalInner {
        void display() {
            System.out.println(x);  // ✅ 可以访问
            System.out.println(s);  // ✅ 可以访问
        }
    }
    
    // 匿名内部类
    Runnable r = new Runnable() {
        public void run() {
            System.out.println(x);  // ✅ 可以访问
            System.out.println(s);  // ✅ 可以访问
        }
    };
    
    // x = 20;  // ❌ 如果取消注释，上面两处访问都会编译错误
}
```

**原因：** 变量捕获机制完全相同，都要求effectively final。

---

## 第六部分：实际使用场景对比

### 6.1 局部内部类适用场景

**场景1：需要构造器参数**

```java
public List<Runnable> createTasks(int count) {
    List<Runnable> tasks = new ArrayList<>();
    
    class Task implements Runnable {
        private final int id;
        private final String name;
        
        Task(int id, String name) {  // 构造器接收参数
            this.id = id;
            this.name = name;
        }
        
        public void run() {
            System.out.println("Task " + id + ": " + name);
        }
    }
    
    for (int i = 0; i < count; i++) {
        tasks.add(new Task(i, "Task-" + i));
    }
    
    return tasks;
}
```

**场景2：复杂的初始化逻辑**

```java
public void process() {
    class DataProcessor {
        private Connection conn;
        private PreparedStatement stmt;
        
        DataProcessor() throws SQLException {
            // 复杂的初始化逻辑
            conn = DriverManager.getConnection(url);
            conn.setAutoCommit(false);
            stmt = conn.prepareStatement(sql);
            stmt.setFetchSize(1000);
        }
        
        void execute() throws SQLException {
            // 处理逻辑
        }
    }
    
    try {
        DataProcessor processor = new DataProcessor();
        processor.execute();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```

**场景3：需要创建多个实例**

```java
public void demo() {
    class Point {
        private int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        double distanceTo(Point other) {
            int dx = this.x - other.x;
            int dy = this.y - other.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }
    
    Point p1 = new Point(0, 0);
    Point p2 = new Point(3, 4);
    Point p3 = new Point(6, 8);
    
    System.out.println(p1.distanceTo(p2));  // 5.0
    System.out.println(p2.distanceTo(p3));  // 5.0
}
```

### 6.2 匿名内部类适用场景

**场景1：一次性使用**

```java
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Clicked");
    }
});
```

**场景2：简单的回调**

```java
asyncOperation(new Callback() {
    @Override
    public void onSuccess(String result) {
        System.out.println("Success: " + result);
    }
    
    @Override
    public void onError(Exception e) {
        System.err.println("Error: " + e);
    }
});
```

**场景3：实现抽象类的简单变体**

```java
abstract class Template {
    abstract void step1();
    abstract void step2();
    
    final void execute() {
        step1();
        step2();
    }
}

Template t = new Template() {
    @Override
    void step1() {
        System.out.println("Step 1");
    }
    
    @Override
    void step2() {
        System.out.println("Step 2");
    }
};

t.execute();
```

---

## 附录：完整对比速查表

| 特性 | 局部内部类 | 匿名内部类 |
|------|-----------|-----------|
| **定义方式** | `class Name { }` | `new Type() { }` |
| **有无名字** | ✅ 有 | ❌ 无 |
| **编译后类名** | `Outer$N类名` | `Outer$N` |
| **构造器** | ✅ 可以定义 | ❌ 不能定义 |
| **初始化方式** | 构造器 + 初始化块 | 仅初始化块 |
| **创建多个实例** | ✅ 通过类名 | ⚠️ 通过循环或重复定义 |
| **继承限制** | 可extends和implements | 只能二选一 |
| **使用次数** | 多次 | 通常一次 |
| **代码可读性** | 有名字，较清晰 | 无名字，嵌套可读性差 |
| **访问外部变量** | effectively final | effectively final |
| **持有外部引用** | ✅ 是（非静态上下文） | ✅ 是（非静态上下文） |
| **作用域** | 定义处到方法结束 | 仅定义表达式 |
| **适用场景** | 需要复用、有构造逻辑 | 一次性使用、简单实现 |

---
