**问：** 元数据空间和Class类在堆中是双向绑定的。一般实例对象通过对象头找到元数据空间在通过元数据空间找到Class中的静态变量。那么继承后子类实例是如何访问到的，子类对象的对象头数据空间指向的是子类的元数据空间，难道在类加载的时候，子类的元空间也会绑定到父类的Class堆吗

**直接回答你的猜测：**
子类的元空间（Child Metaspace）**不会**直接绑定到父类的 Heap Class 对象。
它是绑定到 **父类的元空间（Father Metaspace）**。

JVM 的设计哲学是：**元数据找元数据，对象找对象。**

---

### 1. 核心缺失的一环：`_super` 指针

在元空间里的 `InstanceKlass`（也就是类的图纸）中，不仅仅有双向绑定到堆的指针，还有一个至关重要的指针：**`_super` 指针**。

* `Child InstanceKlass`（子类图纸）持有一个指针，指向 `Father InstanceKlass`（父类图纸）。
* 这就是 JVM 维护继承关系的物理基础。

---

### 2. 完整的“Z”字形寻址路径

假设我们有 `Child extends Father`，且 `Father` 有静态变量 `static int money`。
当你通过 `Child` 实例去访问 `money` 时，JVM 在底层经历了以下步骤（逻辑视角）：

#### 步骤一：从对象到子类图纸

* **动作**：从堆里的 `new Child()` 对象出发。
* **路径**：通过对象头的 Klass Pointer。
* **到达**：元空间里的 `Child InstanceKlass`。

#### 步骤二：在图纸中查找字段（Field Lookup）

* **动作**：JVM 问 `Child InstanceKlass`：“你有 `money` 这个静态字段的定义吗？”
* **结果**：没有。

#### 步骤三：顺藤摸瓜（关键的一步）

* **动作**：JVM 沿着 **`_super` 指针** 向上爬。
* **到达**：元空间里的 `Father InstanceKlass`。
* **动作**：JVM 问 `Father InstanceKlass`：“你有 `money` 吗？”
* **结果**：**有！** 找到了字段描述信息。

#### 步骤四：跨界取数据（Mirror Jump）

* **动作**：既然确认是 `Father` 定义的，那就找存放数据的容器。
* **路径**：通过 `Father InstanceKlass` 的 **`_java_mirror` 指针**（就是你说的双向绑定）。
* **到达**：堆里的 **`Father.class` 对象**。
* **结果**：在 `Father.class` 对象的内存偏移量中，取出了 `money` 的值。

---

### 3. 高清 ASCII 内存全景图

这张图能解开你所有的困惑。请注意看左侧元空间的 **`Super` 箭头**。

```text
       【Metaspace (元空间) - 本地内存】                  【Heap (堆) - JVM内存】
      +-----------------------------+                +-----------------------------+
      | Father InstanceKlass (父图纸)|  ---mirror-->  | Father.class 对象            |
      |-----------------------------|                |-----------------------------|
      | _super: null                |  <--mirror---  | 1. [Header]                 |
 A    | _fields: [static money]     |                | 2. static money = 100       | <---💰终点
 |    +-----------------------------+                +-----------------------------+
 |               ^
 |               | (Super 指针: 继承的关键)
 |               |
 |    +-----------------------------+                +-----------------------------+
 |    | Child InstanceKlass (子图纸) |  ---mirror-->  | Child.class 对象             |
 |    |-----------------------------|                |-----------------------------|
 |    | _super: -> Father Klass     |  <--mirror---  | (这里是空的，没静态变量)       |
 |    | _fields: []                 |                +-----------------------------+
 |    +-----------------------------+
 |               ^
 |               | (Klass Pointer: 对象头)
 |               |
 |               |                                   +-----------------------------+
 |                                                   | Child 实例对象 (new Child)   |
 └---------------(逻辑起点)-------------------------- | 1. [Header] -> 指向Child图纸 |
                                                     | 2. 实例字段...               |
                                                     +-----------------------------+

```

### 4. 深度解析：为什么不让子类直接连父类 Class？

你的猜想是：`Child Metaspace` -> `Father Class (Heap)`。
如果这么设计，会有两个巨大的逻辑硬伤：

1. **层级混乱**：Metaspace 是 C++ 级别的元数据层，Heap 是 Java 对象层。如果元数据层的继承关系依赖于堆里的对象，那么当堆发生 GC（垃圾回收）或者对象移动时，元空间的继承结构就会动荡不安。
2. **职责单一原则**：`InstanceKlass` 负责描述“类的结构”（字段叫什么、方法有什么、父类是谁）。它只需要知道父类的**结构**（Father InstanceKlass）就够了。至于父类的**数据**在哪，那是父类图纸自己的事，子类不需要越俎代庖。

### 5. 补充：性能优化（解析缓存）

你可能会担心：*“天哪！每次访问个静态变量都要走这么复杂的 Z 字形弯路吗？”*

**不用担心。**
上面描述的是**第一次解析（Resolution）**的过程。

一旦 JVM 找到了 `money` 实际上是在 `Father.class` 里：

1. JVM 会把这个结果（`Father.class` 的地址 + `money` 的偏移量）**缓存**到常量池或者直接修补字节码。
2. **第二次访问时**：指令会直接指向 `Father.class` 里的那个内存地址。直捣黄龙，不再绕路。

### 总结

* 子类元空间 **指向** 父类元空间（通过 `_super`）。
* 父类元空间 **指向** 父类 Heap Class（通过 `_java_mirror`）。
* **访问链路**：`Obj` -> `Child元数据` -> `Father元数据` -> `Father堆对象` -> `数据`。

这就是为什么子类能访问父类静态变量，但实际上用的是父类口袋里的钱。

---

补充：**静态变量的特点：**

* **可以被继承**。子类的实例和子类可以直接访问父类的静态变量
* **被继承后也没有副本**。子类和父类共享堆内存中唯一的那一份 `Father.class` 里的数据。
* **不能重写**。如果在子类定义同名静态变量，叫 **“隐藏”** ，这时候子类就有了自己的内存空间，和父类彻底断开联系（根据上面类变量继承的内存图解可以知道）
  * **在同一个类作用域内，不能有两个同名的字段**，无论是否带有 `static` 修饰符。也就是说，同一个类中，如果存在一个静态变量name和一个实例变量name，编译器会直接报错