在前两部，我们已经建立了两个清晰的角色：

1. **心脏（成员内部类）**：必须依赖身体存活，能直接访问身体的秘密（`this$0`）。
2. **义肢（静态嵌套类）**：虽然属于身体的范畴，但是个独立的零件，不依赖具体的身体（无 `this$0`）。

现在，我们要面对的是 **Java 语法中最“反直觉”、最“偷懒”的设计** —— **匿名内部类（Anonymous Inner Class）**。

这一章的第一性原理是：**“去形式化”**。

---

### 第二部（下）：匿名内部类 —— “一次性的隐形特工”

#### 💡 1. 第一性原理：为什么要有“匿名”类？

想象你是这个“身体宇宙”的指挥官（`Main` 方法）。突然，你需要派一个人去执行一个**非常简单、且只做一次**的任务，比如“收到外星信号后，打印一条日志”。

**按照传统的 Java 规矩（繁琐的官僚主义）：**

1. **建档**：你必须先新建一个 `.java` 文件。
2. **起名**：给这个类起个名字，比如 `SignalPrinter`。
3. **定义**：写 `class SignalPrinter implements SignalHandler...`。
4. **招聘**：`new SignalPrinter()`。
5. **执行**：调用它的方法。

**设计者的反思：**
“我就为了打印一行字，至于这么大动干戈吗？我能不能**跳过‘起名’和‘建档’的步骤，直接定义逻辑并执行？**”

**这就是匿名内部类的本质：**
它不是为了创造一种可以在多处使用的“零件”（像义肢），也不是为了创造一种长期的“器官”（像心脏）。
它是为了**“就地解决”**某个临时需求。

---

#### 🔬 2. 语法解剖：最“诡异”的代码

很多新手看到这段代码会懵：**“接口（Interface）不是不能被 `new` 吗？为什么这里 `new Runnable()` 了？”**

```java
public class Body {
    public void react() {
        // 目标：我想创建一个线程，打印一句话

        // ⚡️ 匿名内部类
        // 这一大坨代码，其实只是为了创建一个对象
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("肌肉发生抽搐！");
            }
        });

        t.start();
    }
}
```

**🔍 显微镜下的真相：**

当你写出 `new Runnable() { ... }` 时，你并没有违反“接口不能实例化”的规则。你实际上是在命令编译器做**三件脏活**：

1. **定义（Define）**：编译器偷偷在后台生成了一个**真正的类**（类名通常叫 `Body$1`），这个类 `implements` 了 `Runnable` 接口。
2. **起名（Name）**：因为它没有名字，编译器给它编了个号（`$1`）。
3. **实例化（Instantiate）**：编译器立刻 `new` 了一个 `Body$1` 的实例，并把它塞给了 `Runnable`。

**通俗比喻：**

* **普通类**：是你正式去人才市场招聘一个叫“张三”的员工。
* **匿名内部类**：是你在这个路口，随便抓了一个**戴面具的路人**，把任务清单（代码逻辑）塞给他，让他去干活。你不知道他叫什么，干完这次活，他也消失了。

---

#### 📊 3. 内存视角：它的“身份”是什么？

虽然它叫“匿名”，但在 JVM 的内存里，它必须有户口。

我们来看编译后的样子：

* **源码**：`new Runnable() { ... }`
* **编译后**：你会发现目录下多了一个文件 `Body$1.class`。

**它到底是谁的孩子？**       
这就涉及到了它的本质属性。匿名内部类，在**绝大多数情况下**，本质上是一个**成员内部类（Heart）**。

* **它持有外部类的引用吗？** **持有！**（除非它是在静态方法里定义的）。       
* 这意味着：你在匿名内部类里，依然可以调用 `Body.this.blood`。

**⚠️ 既然是“心脏”，为什么说它是“一次性”的？**
因为它没有名字！        
你没办法在代码的其他地方写 `new Body$1()`。           
这个类定义的**唯一目的**，就是为了生成那**唯一的一个对象**。      

---

#### 👻 4. 核心难点：变量捕获（The Capture）

这是面试中关于匿名内部类最难的考点。

**场景：**
你在外部定义了一个变量，想让这个“临时工”带走使用。

```java
public class TimeTravelDemo { // 👈 类名确认

    public static void main(String[] args) {
        new TimeTravelDemo().createTask();
    }

    public void createTask() {
        int secretCode = 999; // 局部变量（Stack）

        // 创建一个线程（承载了匿名内部类）
        Thread t = new Thread(new Runnable() { // 👈 这里 new 的是 JDK 的 Runnable
            @Override
            public void run() {
                // 模拟耗时操作，确保 createTask 方法先结束
                try { Thread.sleep(1000); } catch (Exception e) {}

                // 试图读取外部的 secretCode
                // 此时 createTask 早就弹栈销毁了，secretCode 已死
                System.out.println("机密代号：" + secretCode);
            }
        });

        t.start(); // 👈 关键！必须启动，让它活得比方法更久！

        System.out.println("主线程任务发布完毕，方法结束！");
        // secretCode = 888; // ❌ 此时修改会破坏数据一致性（因为内部类存的是旧副本）
    }
}
```

**❓ 为什么以前要求必须加 `final`，现在虽然不用加，但也不准改？**

**第一性原理推导：**

1. **生命周期不匹配**：
   * `secretCode` 是**局部变量**，活在 **栈（Stack）** 里。方法执行完，栈帧销毁，这个变量就灰飞烟灭了。
   * `worker` 是**对象**，活在 **堆（Heap）** 里。哪怕方法结束了，这个对象可能还在某个线程里跑着。

2. **矛盾**：如果方法结束了，变量没了，`worker` 还在跑，它去哪里读 `secretCode`？
3. **Java 的解决方案（欺骗）**：
   * 当编译器生成 `Body$1` 类时，它偷偷在里面加了一个字段 `int val`。
   * 它把外部的 `secretCode` 的值，**复制（Copy）** 了一份，存进了 `Body$1` 的字段里。

4. **这就导致了“数据一致性”问题**：
   * 如果外部改了 `secretCode`，内部不知道（因为存的是副本）。
   * 如果内部改了副本，外部也不知道。
   * **为了避免这种“我以为我改了，其实没改”的混乱，Java 设计者一刀切：**


> **“在这个场景下，只允许读，不允许写！大家都把这个变量当成常量（final）看，谁也不许动！”**


**通俗比喻：**
你派特工（匿名类）去执行任务。
你给了他一张**照片**（变量的副本），说“去找这个人”。
特工走了之后，你不能整容（修改变量），特工也不能在照片上画画（修改副本）。大家必须保证拿着的是**同一张不可变的照片**，任务才不会乱。

---

### 总结：匿名内部类

到这里，我们的 Java 内部类三部曲就完整了：

1. **成员内部类（心脏）**：
   * **特征**：有名字，非静态。
   * **本质**：寄生。持有 `this$0`。
   * **用途**：需要频繁访问外部数据的功能模块（如迭代器）。

2. **静态嵌套类（义肢/取卡针）**：
   * **特征**：有名字，有 `static`。
   * **本质**：独立。不持有 `this$0`。
   * **用途**：逻辑相关的辅助类、工具类、Builder。

3. **匿名内部类（临时工/隐形特工）**：
   * **特征**：**没名字**，定义即实例化。
   * **本质**：**一次性**。通常持有 `this$0`，且会**捕获**外部变量（拷贝副本）。
   * **用途**：回调函数、事件监听、线程任务。

---

此时，你可能会觉得匿名内部类的写法（`new Interface() { ... }`）还是太啰嗦了，充满了样板代码。

* “为什么要写 `new Runnable`？明明只有一个方法，傻子都知道我要覆盖哪一个。”
* “能不能只写核心逻辑 `() -> ...`？”

这就是 **Lambda 表达式** 的诞生。
它不仅仅是匿名内部类的“缩写”，它在**底层字节码**上通过 `invokedynamic` 指令，实现了一种比匿名内部类**更高效、更轻量**的机制。
