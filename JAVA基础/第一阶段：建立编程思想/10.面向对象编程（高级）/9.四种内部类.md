# Java 内部类详解

Java中的内部类是定义在另一个类内部的类。内部类可以访问外部类的成员，包括私有成员，这是它的主要优势之一。

## 一、内部类的分类

Java中主要有四种内部类：

### 1. 成员内部类（Member Inner Class）

成员内部类是最常见的内部类，定义在外部类的成员位置。

```java
public class Outer {
    private int outerField = 10;
    
    // 成员内部类
    class Inner {
        private int innerField = 20;
        
        public void display() {
            System.out.println("外部类字段: " + outerField);
            System.out.println("内部类字段: " + innerField);
        }
    }
    
    public void createInner() {
        Inner inner = new Inner();
        inner.display();
    }
}

// 使用
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();  // 必须通过外部类实例创建
```

**特点：**
- 可以访问外部类的所有成员（包括私有成员）
- 不能定义静态成员（除了静态常量）
- 创建内部类实例必须先有外部类实例

### 2. 静态内部类（Static Nested Class）

使用static修饰的内部类，严格来说叫"静态嵌套类"。

```java
public class Outer {
    private static int staticField = 10;
    private int instanceField = 20;
    
    // 静态内部类
    static class StaticInner {
        public void display() {
            System.out.println("静态字段: " + staticField);
            // System.out.println(instanceField);  // 错误！不能直接访问外部类的非静态成员
        }
    }
}

// 使用
Outer.StaticInner inner = new Outer.StaticInner();  // 可以直接创建，不需要外部类实例
```

**特点：**
- 只能访问外部类的静态成员
- 可以定义静态成员
- 创建时不需要外部类实例
- 实际上是一个独立的类，只是命名空间在外部类内

### 3. 局部内部类（Local Inner Class）

定义在方法或代码块中的类。

```java
public class Outer {
    public void method() {
        final int localVar = 30;  // JDK 8之前必须是final
        
        // 局部内部类
        class LocalInner {
            public void display() {
                System.out.println("局部变量: " + localVar);
            }
        }
        
        LocalInner inner = new LocalInner();
        inner.display();
    }
}
```

**特点：**
- 作用域仅限于定义它的方法或代码块
- 可以访问外部类成员和方法中的局部变量（局部变量必须是final或事实上的final）
- 不能使用访问修饰符
- 外部无法直接访问

### 4. 匿名内部类（Anonymous Inner Class）

没有名字的内部类，通常用于创建接口或抽象类的实例。

```java
// 接口
interface Greeting {
    void sayHello();
}

public class Test {
    public static void main(String[] args) {
        // 匿名内部类实现接口
        Greeting greeting = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello!");
            }
        };
        
        greeting.sayHello();
        
        // 匿名内部类继承类
        Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println("线程运行中");
            }
        };
    }
}
```

**特点：**
- 没有类名，直接new接口或抽象类
- 只能使用一次
- 不能定义构造器（因为没有类名）
- 常用于事件监听、回调等场景

## 二、内部类的访问规则

```java
public class AccessDemo {
    private int outerPrivate = 1;
    protected int outerProtected = 2;
    public int outerPublic = 3;
    
    class Inner {
        public void accessOuter() {
            // 内部类可以访问外部类的所有成员
            System.out.println(outerPrivate);
            System.out.println(outerProtected);
            System.out.println(outerPublic);
            
            // 访问外部类的this
            System.out.println(AccessDemo.this.outerPrivate);
        }
    }
    
    public void accessInner() {
        Inner inner = new Inner();
        // 外部类可以访问内部类的成员（需要创建实例）
    }
}
```

## 三、内部类的应用场景

1. **封装性增强**：将只在一个类中使用的辅助类隐藏起来
2. **事件处理**：GUI编程中的事件监听器
3. **迭代器模式**：集合框架中的迭代器实现
4. **回调机制**：匿名内部类实现回调接口

```java
// 迭代器示例
public class MyList {
    private Object[] elements;
    
    // 内部类实现迭代器
    private class MyIterator implements Iterator {
        private int index = 0;
        
        public boolean hasNext() {
            return index < elements.length;
        }
        
        public Object next() {
            return elements[index++];
        }
    }
    
    public Iterator iterator() {
        return new MyIterator();
    }
}
```

## 四、注意事项

1. **内存泄漏风险**：非静态内部类持有外部类的引用，可能导致外部类无法被GC回收
2. **序列化问题**：内部类的序列化依赖于外部类
3. **性能考虑**：每个内部类实例都会持有外部类引用，占用额外内存
4. **命名冲突**：内部类和外部类有同名变量时，使用`外部类名.this.变量名`区分

内部类是Java提供的强大特性，合理使用可以提高代码的封装性和可读性，但也要注意避免过度使用导致代码复杂度增加。