## 第1部分：建立认知（What & Why）

### 📦 1.1 核心语法 *💡 核心必学*

**目标**：理解“类变量”与“实例变量”的区别。

**基础定义**：
被 `static` 关键字修饰的成员变量，称为**类变量**（或静态变量）。

* **属于谁**：属于类（Class）本身，所有对象共享**同一份**数据。
* **生命周期**：类加载时创建，程序结束（或类卸载）时销毁。
* **默认值**：如果不赋值，编译器会自动给默认值（`int`是0，`boolean`是false，对象是`null`）。

```java
public class User {
    // 1. 类变量 (static修饰)
    // 特点：全服共享。比如：统计总用户数
    // 访问方式：推荐用 User.totalCount (类名.变量名)
    public static int totalCount = 0;

    // 2. 实例变量 (无static)
    // 特点：人手一份。比如：每个用户的名字
    // 访问方式：user.name (对象.变量名)
    public String name;
}

```

---

### 🔗 1.2 关联概念 *💡 核心必学*

**目标**：理解 `static` 及其组合用法。

**1. 实例变量（Instance Variable）**

* **定义**：在1.1中我们看到没有 `static` 修饰的变量。
* **对比**：
* 实例变量 = 每个对象**私有**的小金库。
* 类变量 = 所有对象**共享**的公共账户。



**2. `static` 关键字**

* **含义**：静态的，意味着“在编译期就确定位置，不依赖对象存在”。
* **编译器行为**：JVM 在加载类时，就会为 `static` 变量分配内存。此时还没有任何对象（`new`）产生。

**3. 常量（`static final`）**

* **定义**：既共享（`static`）又不可修改（`final`）。
* **场景**：这是类变量最常用的场景，用于定义配置项。

```java
public class AppConfig {
    // 关联概念演示：
    
    // 1. 实例变量：如果不new对象，这个变量就不存在
    public int timeout = 1000; 

    // 2. 类变量：即使不new对象，它也存在
    public static String appName = "MyApp";

    // 3. 常量（static + final）：
    // 命名规范：通常全大写，用下划线分隔
    public static final String MAX_VERSION = "v1.0";
}

```

---

### 🚀 1.3 快速上手 *💡 核心必学*

**目标**：通过一个“在线人数统计器”体验数据共享。

```java
/**
 * 场景：游戏服务器
 * 需求：不管创建了多少个玩家对象，需要一个总数记录当前在线人数。
 */
public class GameServer {
    // 类变量：所有玩家共享这个计数器
    public static int onlineCount = 0;
    
    // 实例变量：每个玩家的名字不同
    public String playerName;

    public GameServer(String name) {
        this.playerName = name;
        // 核心：每次创建对象，共享计数器 +1
        // 注意：这里推荐使用 类名.变量名
        GameServer.onlineCount++;
    }

    public static void main(String[] args) {
        // 1. 初始状态
        System.out.println("初始在线: " + GameServer.onlineCount); // 输出 0

        // 2. 玩家A上线
        GameServer player1 = new GameServer("Player_A");
        System.out.println("玩家A上线后总数: " + GameServer.onlineCount); // 输出 1

        // 3. 玩家B上线
        GameServer player2 = new GameServer("Player_B");
        System.out.println("玩家B上线后总数: " + GameServer.onlineCount); // 输出 2

        // 4. 验证共享性：通过 player1 也能看到 player2 带来的变化
        // (虽然可以这样写，但IDE会警告，建议用类名访问)
        System.out.println("通过A看总数: " + player1.onlineCount); // 依然输出 2
    }
}

```

---

### 💡 1.4 它解决了什么问题 *💡 核心必学*

**目标**：理解为什么不能只用实例变量。

**历史背景/痛点**：
如果没有 `static`，想要在多个对象间共享数据（例如全局配置、计数器），我们必须把这个数据对象传给每一个新建的对象。

**对比演示**：

**🔴 没有类变量 (麻烦且浪费内存)**

```java
class Config { String appName = "WeChat"; }

class User {
    Config config; // 每个用户都要持有一个 Config 对象引用
    User(Config c) { this.config = c; } // 必须通过构造器传递
}
// 创建时极其繁琐：
// User u1 = new User(sharedConfig);
// User u2 = new User(sharedConfig);

```

**🟢 使用类变量 (优雅)**

```java
class Config { static String appName = "WeChat"; }

class User {
    // 不需要持有 Config 对象
    void showApp() {
        System.out.println(Config.appName); // 直接访问，哪里都能用
    }
}

```

**设计收益**：

1. **内存节省**：全JVM只存一份，而不是每个对象存一份。
2. **访问便捷**：无需传递引用，任何地方通过 `类名.` 即可获取。

---

### ⚙️ 1.5 底层原理 *⭐ 进阶选学*

**目标**：理解内存分布，明白为什么它“不属于对象”。

**内存模型 (Java 8+)**：

```
   Stack (线程栈)              Heap (堆内存)
+----------------+      +-------------------------+
| main() Frame   |      |                         |
|                |      |  [Class Object: User]   |<--- 💡 类加载时创建
| player1 (ref) -|----->|  +-------------------+  |     存储在这里！
|                |      |  | static count: 2   |  |
| player2 (ref) -|--+   |  +-------------------+  |
+----------------+  |   |                         |
                    |   |  [Instance: player1]    |
                    +-->|  +-------------------+  |
                        |  | name: "Player_A"  |  |
                        |  +-------------------+  |
                        |                         |
                        |  [Instance: player2]    |
                        |  +-------------------+  |
                        |  | name: "Player_B"  |  |
                        |  +-------------------+  |
                        +-------------------------+

```

**执行流程**：

1. **类加载**：JVM 读取 `User.class`，在堆中创建 `User` 的类对象（Class Object），并为 `static count` 分配空间，初始化为 0。
2. **对象创建**：执行 `new User()` 时，在堆中分配实例内存（`name`），**但不包含** `count`。
3. **访问**：当访问 `User.count` 时，JVM 直接去类对象中找，而不是去实例中找。

**关键结论**：
`static` 变量的生命周期远长于任何一个对象。**对象死了，类变量还活着。**

## 第2部分：工程实践（How to Do Right）

在阶段1中，我们学习了类变量（Static Variable）是属于"类"的共享数据。
在工程开发中，`static` 是一把双刃剑：**用好了是"全局配置"，用坏了是"并发灾难"**。

---

### 🔍 前置知识检查

```
──────────────────────────────────
📚 前置知识回顾
──────────────────────────────────
本阶段会用到以下概念（已在阶段1学过）：
· 类变量 (static)：所有对象共享一份数据
· 实例变量 (非static)：每个对象私有一份数据
· 常量 (final)：初始化后不能修改

如果不记得了，建议先回顾第1部分。
──────────────────────────────────

```

---

### 🌍 2.1 真实场景 *💡 核心必学*

**目标**：识别什么时候该用 `static`，什么时候绝不能用。

#### 场景 A：全局配置（✅ 推荐）

**业务需求**：电商系统中，订单状态码是固定的，不需要每个订单对象都存一份。

```java
public class OrderStatus {
    // 场景：定义全局通用的状态码
    // 优势：节省内存，语义清晰
    public static final int PENDING_PAYMENT = 10;
    public static final int PAID = 20;
    public static final int SHIPPED = 30;
}

// 使用
if (currentOrder.status == OrderStatus.PAID) { ... }

```

#### 场景 B：Web应用的用户上下文（❌ 致命错误）

**业务需求**：在处理网页请求时，记录当前登录的用户。

**错误做法**：试图用 `static` 变量存储当前用户。

```java
// ❌ 灾难性代码示范
public class UserContext {
    // 致命错误：用 static 存储请求级数据
    public static String currentUserName; 
}

// 模拟 Web 服务器处理流程
// 线程A（用户小明）处理中...
UserContext.currentUserName = "XiaoMing";

// 💥 就在这时，线程B（用户小红）进来了
UserContext.currentUserName = "XiaoHong"; // 覆盖了小明！

// 线程A继续执行，想获取当前用户
// 结果：小明的数据被保存到了小红的账号下！
System.out.println("Saving data for: " + UserContext.currentUserName);

```

**ASCII 图解灾难现场**：

```
Thread A (小明)        Static Memory (共享)         Thread B (小红)
      |                       |                         |
      |--写("XiaoMing")-----> | [currentUserName]       |
      |                       | <----写("XiaoHong")-----| 💥 覆盖！
      |                       |                         |
      |----读()-------------> | 值为 "XiaoHong"         |
      | 😱 A读到了B的数据!      |                         |

```

**决策标准**：

* **是所有对象都一样的公共属性吗？** -> YES -> 用 `static`。
* **是随着用户/请求/时间变化的状态吗？** -> YES -> **绝对禁止**用 `static`。

---

### ✅ 2.2 工程规范 *🔥 实战必备*

基于 Java 17+ 标准，我们采用红绿灯分级：

#### 🔴 RED（禁止操作）

**1. 禁止使用 `public static` 定义可变变量**

* **后果**：代码变得极其难以测试，且多线程下 100% 会出 Bug。
* **修正**：如果必须共享可变数据，请封装在单例模式（Singleton）或 `private` 静态变量中，通过 `synchronized` 方法访问。

```java
// ❌ 绝对禁止：公开的可变大杂烩
public class GlobalData {
    public static List<String> users = new ArrayList<>(); // 线程不安全！
}

// ✅ 修正：如果不涉及并发，至少要封装；如果涉及并发，参考阶段3
private static final List<String> users = new ArrayList<>();

```

#### 🟢 GREEN（推荐风格）

**1. 常量必须是 `public static final**`

* **规范**：命名必须全大写，单词间用下划线分隔（UPPER_SNAKE_CASE）。

```java
// ✅ 标准写法
public class AppConfig {
    // 必须加 final，确保不可修改
    public static final int MAX_RETRY_COUNT = 3; 
    public static final String DEFAULT_CURRENCY = "CNY";
}

```

**2. 仅用于内部辅助的 `private static**`

* **场景**：Logger（日志对象）或内部缓存。

```java
public class OrderService {
    // ✅ 标准写法：类级资源，私有，不可变
    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);
}

```

---

### 🔄 2.3 版本演进 *💡 核心必学*

Java 在不断进化，类变量的定义位置也在扩展。

| 特性维度 | 传统写法 (Java 8 之前) | 现代写法 (Java 17+) | 优势 |
| --- | --- | --- | --- |
| **接口常量** | 默认 `public static final` | 保持不变 | 接口定义契约 |
| **记录类(Record)** | 不支持 | 支持 `static` 变量 | 数据类也能带配置 |
| **内部类** | 只有静态内部类能有 `static` | 任何内部类均可 (Java 16+) | 更灵活的结构 |

**代码对比：Record 中的类变量**

```java
// 现代写法（Java 17）：Record 类型
// Record 通常用于不可变数据载体，但也可以包含静态配置
public record DatabaseConfig(String host, int port) {
    
    // ✅ Record 中允许定义静态常量
    // 场景：定义默认配置
    public static final DatabaseConfig LOCAL_DEFAULT = 
        new DatabaseConfig("localhost", 3306);
        
    // 也可以定义静态方法
    public static DatabaseConfig ofDefault() {
        return LOCAL_DEFAULT;
    }
}

// 使用
var config = DatabaseConfig.LOCAL_DEFAULT;

```

