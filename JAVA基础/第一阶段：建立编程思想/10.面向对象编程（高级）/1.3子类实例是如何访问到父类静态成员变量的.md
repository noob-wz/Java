不管你是访问静态方法，还是静态属性，只要沾上了 **"Static"** 这两个字，JVM 就彻底 **“脸盲”** 了——它根本不看（也不需要）堆内存里的那个对象实例。

---

### ❌ 常见错误路径（依然是虚方法的路径）

1. **实例堆空间**：拿着引用找到堆里的对象。
2. **对象头**：读取对象头里的类型指针。
3. **元空间**：找到子类 Class。
   ... （后面是对的）

**为什么错？**
因为字节码指令 `getstatic` **不依赖栈顶的对象引用**。即便是 `obj.staticField`，编译器也会把它翻译成“去这个类的地盘拿数据”，而不是“去这个对象的肚子里拿数据”。

---

### ✅ 正确的路径（静态属性的路径）

假设代码如下：

```java
class Father { static int age = 50; }
class Son extends Father {}

Son s = new Son();
int x = s.age; // 通过子类实例访问父类静态属性

```

#### 第一阶段：编译期 (javac 的“多管闲事”)

这是最关键的一步，**大部分工作在这里就被“截胡”了**。

当 `javac` 编译 `s.age` 时：

1. 它看到 `s` 是 `Son` 类型。
2. 它去 `Son` 里找 `age`。没找到。
3. 它顺着继承链去 `Father` 里找 `age`。**找到了！**
4. **关键动作**：编译器直接生成字节码 `getstatic Father.age`。

> **注意**：虽然源代码写的是 `s.age`（看起来是通过子类），但编译器生成的字节码直接指向了 **定义该属性的类 (Father)**。

#### 第二阶段：运行期 (JVM 的直捣黄龙)

1. **无视对象**：执行到 `getstatic` 时，JVM 根本不看堆里的 `s` 对象（哪怕 `s` 是 null 也不报错）。
2. **符号解析**：JVM 看到指令参数指向 `Father`。
3. **直接定位**：直接去元空间找到 `Father` 的元数据，然后去堆中找到 `Father` 的 `Class` 对象（JDK 8+ 静态变量存在这里）。
4. **取值**：直接把值拿走。

**在这个标准流程里，连 `Son` 的元空间都不需要进，更别提 `_super` 指针了。**

---

### 🔬 特殊情况：什么时候会用到 `_super`？

只有一种极其特殊的情况，JVM 才会像你描述的那样，在元空间里顺藤摸瓜。那就是 **“运行时解析 (Resolution)”** 的时候。

假设字节码里（可能是动态生成的，或者被手动修改过）写的是 `getstatic Son.age`，但 `Son` 里其实没有 `age`（只有 `Father` 有）。

这时候的路径：

1. **无视对象**：依然不看堆里的对象实例。
2. **找子类**：直接定位到元空间里的 `Son` (`InstanceKlass`)。
3. **查表**：在 `Son` 的字段表里找 `age`。 -> **没找到**。
4. **找爸爸 (`_super`)**：JVM 沿着 `Son` 元数据的 `_super` 指针找到 `Father`。
5. **查父类**：在 `Father` 里找到了！
6. **取值**。

**结论**：即使在这种情况下，也是 **Class (Son) -> Class (Father)** 的查找，完全绕过了 **Instance (Heap Object)**。

---

### ⚡️ 再次验证：空指针测试

静态属性和静态方法一样，都具备“抗空指针”的超能力。

```java
public class Test {
    public static void main(String[] args) {
        Son s = null; 
        // s 是 null，如果是访问实例属性 (s.name)，这里必死无疑。
        // 但这是静态属性，毫发无伤。
        System.out.println(s.age); 
    }
}

```

这直接证明了：**访问静态属性，第一步绝对不是去堆里找对象。**

---

### 🎯 总结常见的思维误区

常见的的思维误区通常是在试图用 **“多态（Polymorphism）”** 的逻辑去理解 **“静态（Static）”**。

* **实例属性/方法 (Instance)**：是 **Runtime** 决定的。必须看堆里的对象是谁，必须查对象头，必须走虚方法表。这是 **"Late Binding" (晚绑定)**。
* **静态属性/方法 (Static)**：是 **Compile-time** 决定的。编译器早就定好了要去哪个类拿数据。这是 **"Early Binding" (早绑定)**。

**修正后的最终路径（针对静态属性）：**

1. **编译器**：通常直接把“目标类”写死在字节码里（直接指向父类）。
2. **运行期**：
* **Skip**: 跳过堆对象。
* **Direct**: 直接找目标类的元数据。
* **Fallback (如有必要)**: 如果目标类没找到，才在元空间里通过 `_super` 找父类。


