要理解类变量（Static Variable）的内存模型，核心在于搞清楚**三个区域**的关系：

1. **Metaspace（元空间）**：存“死”的图纸数据。
2. **Heap（堆）**：存“活”的对象数据（这里有玄机）。
3. **Stack（栈）**：存当前正在执行的方法和局部变量。

---

### 1. 颠覆认知的核心事实（Java 8+）

很多旧教程（Java 7及以前）会告诉你：静态变量放在“方法区/PermGen”里。
**请把这个概念忘掉！在 Java 8 之后，变天了。**

**核心结论：** **静态变量（Static Variables）存储在堆（Heap）中的 `Class` 对象里。**

并不是飘在空中，也不是在什么神秘的元空间里，它就在**堆**里，寄生在一个特殊的“大对象”身上。

---

### 2. 深度拆解：从加载到访问

为了讲清楚，我们看下面这行简单的代码在内存里到底发生了什么：

```java
public class User {
    // 静态变量：一个引用类型
    public static String appName = new String("WeChat");
    // 静态变量：一个基本类型
    public static int count = 0;
}

```

#### 步骤一：类加载（Loading）

当你第一次用到 `User` 类时，JVM 做了两件事：

1. **读取图纸（存入 Metaspace）**：
   JVM 把 `User.class` 文件读进来，把类的方法代码、字段名、修饰符等**元数据（Metadata）** 扔进了 **Metaspace（元空间）**。这是本地内存，不在堆里。
2. **制造“模具”（存入 Heap）**：
   JVM 在 **堆（Heap）** 中生成了一个特殊的 `java.lang.Class` 对象（我们姑且叫它 **`User.class` 对象**）。
   * 这个对象是所有 `User` 实例的“总管”。
   * **重点来了**：`static` 变量（`appName` 的引用 和 `count` 的值）就存在这个 `User.class` 对象肚子里，作为这个对象的“成员变量”。



#### 步骤二：初始化（Initialization）

执行静态赋值：

1. **基本类型**：`count = 0` 直接写在堆里的 `User.class` 对象内部。
2. **引用类型**：
   * 先在堆里 `new String("WeChat")`，开辟一块空间。
   * 然后把这个字符串的**地址（0x999）**，存到 `User.class` 对象里的 `appName` 字段中。



---

### 3. 高清无码内存图（Java 8+）

请仔细看这张图，这是理解一切的关键：

```
【Metaspace (元空间)】 <--- 本地内存，存死数据
+---------------------------+
| User类的元数据 (Metadata)   |
| - 方法字节码 (code)        | <---- 只有代码逻辑在这里
| - 字段描述信息             |
+---------------------------+
           ^
           | (描述)
           |
【Heap (堆内存)】 <--- 存活数据，GC主要工作区
+-------------------------------------------------------+
|                                                       |
|   1.【User 的 Class 对象】 (大管家)                     |
|   +---------------------------------------+           |
|   | (Header)                              |           |
|   | 引用 -> 指向 Metaspace (我是谁的类对象)   |           |
|   |---------------------------------------|           |
|   | static int count = 0;                 | <--- ⭐ 就在这！
|   | static String appName = 0x999; (地址)  |----|      |
|   +---------------------------------------+    |      |
|                                                |      |
|   2.【String 对象】 (实际数据)                   |      |
|   +-------------------+ <----------------------+      |
|   | "WeChat"          | (地址: 0x999)                 |
|   +-------------------+                               |
|                                                       |
|   3.【User 普通实例对象】 (new User())                  |
|   +-------------------+                               |
|   | (Header) -> 指向 User InstanceKlass --> Class对象   |
|   | name = "张三"      |                               |
|   +-------------------+                               |
+-------------------------------------------------------+

【Stack (栈)】 <--- 线程私有
+-------------------+
| main() 栈帧        |
| 变量 u = 0x123     | ---> 指向堆里的普通实例对象
+-------------------+

```

### 4. 关键点总结（为什么这么设计？）

#### Q1: 为什么说 `User.count` 不属于 `u` (普通对象)？

你看图上的 **3.【User 普通实例对象】**，它的肚子里只有 `name`，根本没有 `count`。
当你写 `u.count` 时，JVM 会顺着对象头的指针，找到 **1.【User 的 Class 对象】**，然后从那里把 `count` 读出来。

#### Q2: 为什么 Java 8 把静态变量从“方法区/PermGen”搬到了“堆”里？

这是一个非常硬核的优化：

* **Java 7 及以前**：静态变量放在 PermGen（永久代）。这块内存很小，而且垃圾回收很难触发。如果你的静态变量存了大对象（比如一个很大的静态 Map），很容易导致 **OOM: PermGen space** 崩溃。
* **Java 8 以后**：静态变量搬到了 **堆（Heap）** 中。堆内存很大，而且垃圾回收机制（GC）非常成熟。如果静态变量存了太多东西，GC 可以更容易地回收掉不再使用的类和变量，防止内存溢出。

---

### 5. 补充说明

#### Q1: Java 8 前后，方法区是如何变迁的？

在 **Java 7 及之前**（永久代 PermGen 时代）：
所有的东西（类定义、方法代码、静态变量、常量池）都挤在一块叫“永久代”的内存里。

在 **Java 8 及之后**（元空间 Metaspace 时代），这里发生了一个 **“大分家”** ：

1. **类的元数据（Metadata）** ➡️ **搬到了本地元空间（Metaspace）**。
   * 包括：类名、访问修饰符、字段描述、方法描述。
   * *这部分正如你所说，调整到了本地内存。*

2. **静态变量（Static Variables）** ➡️ **搬到了堆（Heap）**。
   * *这部分没有去元空间！* 它们回到了堆里，寄生在 `Class` 对象中（就是我上一条回复重点讲的内容）。

**📌 总结**： 类加载时，**描述信息**去了元空间，但**静态数据**留在了堆里。

#### Q2：以前无论是对象的方法还是类的方法都是公用的，也是存储在方法区中的，那么现在时存储在哪里的呢，本地元空间吗？

无论是**实例方法**（Instance Method）还是**静态方法**（Static Method），它们本质上都是相同的**代码指令（Bytecode/Instructions）**。它们存储的位置是**完全一样**的（都在 Metaspace），区别仅在于**调用方式**（在栈 Stack 里）：

* **静态方法**：调用时不需要 `this` 指针，直接根据元空间的地址执行代码。
* **实例方法**：调用时，栈帧里会多传一个隐式的参数 `this`，指向堆里的对象，但执行的代码指令依然是去元空间拿的。

#### Q3: 既然数据分家了，那对象头的地址指向是不是也要增加？ 

**直接给结论：** **对象头里依然只有「一个」指向类的指针。** 它并没有因为数据分家而变成两个地址。

JVM 在设计时建立了一个**双向连接**：

* **元空间**里的 `InstanceKlass`（图纸）持有一个指针，指向 **堆**里的 `java.lang.Class`（大管家）。
* **堆**里的 `java.lang.Class`（大管家）持有一个指针，指向 **元空间**里的 `InstanceKlass`（图纸）。

所以，普通对象的查找路线是“曲线救国”的：

```
普通对象实例 -> 元空间(InstanceKlass) -> 堆(Class对象) -> 静态变量
```

```
   【Metaspace (元空间)】                    【Heap (堆)】
   (C++层面的类定义)                        (Java层面的类对象)
+----------------------+               +-----------------------+
| InstanceKlass        | ------------> | java.lang.Class 对象   |
| (我是元数据)          | (引用)         | (我是大管家)           |
|                      |               |                       |
| [方法代码指令]        | <------------ | static count = 0      | <--- 目标在这里！
+----------------------+ (引用)         +-----------------------+
          ^
          | (Klass Pointer)
          |
+----------------------+
| 普通对象 (User u1)    |
| - Mark Word          |
| - Klass Pointer      | <--- 对象头里只有这一个类指针！
| - name = "张三"       |
+----------------------+
       【Heap (堆)】

```

（*注：实际上现代 JVM 极其聪明，在 JIT 编译后，它会发现 `u.count` 其实就是 `User.count`，直接优化成对特定内存地址的访问，连上面这些绕弯的步骤都省了。*）
