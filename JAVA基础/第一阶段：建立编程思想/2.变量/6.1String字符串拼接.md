这是 Java 开发中最高频的操作，也是**性能问题的重灾区**。表面看是连连看，底层其实是内存攻防战。

---

### 💡 核心全景图

在 Java 中，拼接字符串主要有 **4 种方式**。每种方式的底层实现和适用场景完全不同。

| 方式 | 典型写法 | 关键词 | 推荐指数 |
| --- | --- | --- | --- |
| **1. 加号拼接** | `"A" + "B"` | 语法糖、编译器优化 | ⭐⭐⭐⭐ (仅限单行) |
| **2. StringBuilder** | `sb.append("A")` | 可变、非线程安全、**快** | ⭐⭐⭐⭐⭐ (循环/大量) |
| **3. StringBuffer** | `sb.append("A")` | 可变、线程安全、**慢** | ⭐ (极少使用) |
| **4. String.join** | `String.join(",", list)` | Java 8+、分隔符 | ⭐⭐⭐⭐ (特定场景) |

---

### 🔬 深度解剖：加号 `+` 的底层魔法

很多人以为 `+` 就是简单的把两个东西粘在一起，其实这是 Java 编译器给你的**语法糖 (Syntactic Sugar)**。

#### 1. 场景 A：字面量直接相加 (编译期优化)

```java
String s = "Hello" + " " + "World";

```

* **底层真相**：编译器非常聪明，在编译成 `.class` 文件时，直接把它合并成了 `"Hello World"`。
* **性能**：极快，没有任何运行时开销。
* **结论**：如果全是常量，放心用 `+`。

> **字符串常量从编译到运行过程中发生了什么？**
> 
> 字符串字面量**在编译期被写入 .class 文件的常量池中**；当**类被加载（或首次使用）时**，JVM 根据这些常量池信息**在堆中创建对应的 String 对象，并放入字符串常量池**；程序**运行到使用该字面量的代码时，只是直接复用常量池中已有的字符串引用**，而不会再创建新的对象。

#### 2. 场景 B：变量相加 (运行期优化)

```java
String s1 = "Hello";
String s = s1 + " World";

```

* **JDK 8 及之前的底层**：
  编译器会悄悄把这行代码改成：
  `new StringBuilder().append(s1).append(" World").toString();`
* **JDK 9 及之后的底层 (新特性)**：
  改为使用 `InvokeDynamic` 指令和 `StringConcatFactory`，动态决定拼接策略（可能不用 StringBuilder，直接操作字节数组），**速度更快，内存更省**。

---

### ⚠️ 关键性能陷阱：循环中的 `+`

这是新手最容易踩的坑，也是**大厂面试必问**。

#### ❌ 错误写法 (性能杀手)

```java
String result = "";
for (int i = 0; i < 1000; i++) {
    // 每一轮循环，JVM 都会新建一个 StringBuilder 对象，append 完再 toString 抛弃
    // 结果：产生了 1000 个 StringBuilder 垃圾对象，内存狂跳
    result = result + i; 
}

```

#### ✅ 正确写法 (StringBuilder)

```java
// 只创建一个容器，复用这一个对象
StringBuilder sb = new StringBuilder(); 
for (int i = 0; i < 1000; i++) {
    sb.append(i); // 往容器里倒水，不换杯子
}
String result = sb.toString();

```

---

### ⚙️ StringBuilder 的扩容机制 (底层原理)

为什么 `StringBuilder` 快？因为它本质上是一个**动态数组**。

1. **初始化**：`new StringBuilder()` 默认创建一个长度为 **16** 的字符数组（JDK 9+ 是字节数组）。
2. **存入**：`append()` 只是往数组空位填数据。
3. **扩容**：如果数组满了，它会创建一个**新数组**（通常是 `旧长度 * 2 + 2`），把旧数据拷贝过去，丢弃旧数组。

**💡 优化技巧**：
如果你预知字符串会很长（比如大概 1000 个字），直接指定初始容量，避免中间发生扩容（数组拷贝），性能拉满。

```java
// 预先分配 1024 个空间，避免中间扩容
StringBuilder sb = new StringBuilder(1024); 

```

---

### 💼 大厂编码规范 (Alibaba & Google)

#### 1. 循环体内，禁止使用 `+`

> **【强制】** 循环体内，字符串的连接方式，使用 `StringBuilder` 的 `append` 方法进行扩展。
> * **说明**：反编译出的字节码文件显示，循环体内的 `+` 会反复创建 `StringBuilder` 对象。
>
>

#### 2. 线程安全的选择

> **【推荐】** 绝大多数业务逻辑是在单线程内完成的（例如一个 HTTP 请求的处理方法内），**优先使用 `StringBuilder`**。
> * **例外**：只有在多个线程同时修改同一个字符串变量时（极少见），才使用 `StringBuffer`。
>
>

---

### 💻 现代 Java 的优雅写法 (JDK 8+)

有时候 `StringBuilder` 写起来太啰嗦，Java 8 提供了更优雅的 API。

#### 场景：把 List 里的名字用逗号连起来

**老写法 (笨重):**

```java
StringBuilder sb = new StringBuilder();
for (String name : names) {
    sb.append(name).append(",");
}
// 还要处理去掉最后一个逗号的逻辑...麻烦！

```

**新写法 (优雅):**

```java
List<String> names = List.of("Alice", "Bob", "Charlie");

// 1. 使用 String.join (最推荐)
String result = String.join(", ", names); 
// 结果: "Alice, Bob, Charlie"

// 2. 使用 Stream API
String result2 = names.stream().collect(Collectors.joining(", "));

```

---

### 🎯 最终决策树 (Decision Tree)

当你需要拼接字符串时，请按此逻辑选择：

1. **是一行代码内的简单拼接吗？**
   * 👉 是：直接用 `+` (可读性最好)。
   * 👉 否：进入下一步。

2. **是在 `for`/`while` 循环里吗？**
   * 👉 是：必须用 `StringBuilder`。
   * 👉 否：进入下一步。

3. **是把 List/数组用分隔符连起来吗？**
   * 👉 是：用 `String.join()`。
   * 👉 否：进入下一步。

4. **涉及多线程共享修改吗？**
   * 👉 是：用 `StringBuffer` (极少见)。
   * 👉 否：用 `StringBuilder`。

