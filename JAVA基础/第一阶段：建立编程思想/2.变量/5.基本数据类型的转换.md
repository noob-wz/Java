Java 中的基本数据类型（Primitive Data Types）转换是程序设计的基础。转换主要分为两大类：**拓宽转换（Widening Conversion）** 和 **窄化转换（Narrowing Conversion）**，也可以称为**隐式转换** 和**显示转换**

### 核心原则：数据容量（Capacity）

转换的本质是解决 **数据容量** 的问题。

- **小容量 $\rightarrow$ 大容量：** 安全，自动进行。
- **大容量 $\rightarrow$ 小容量：** 危险，必须手动确认（强制转换）。

---

## 1. 拓宽转换/隐式转换（Widening Conversion）

概念：**将存储容量较小的数据类型转换为存储容量较大的数据类型** 。

| 特性       | 描述                                                       |
| :--------- | :--------------------------------------------------------- |
| **安全性** | 绝对安全，不会丢失数值的**大小**。                         |
| **方式**   | 隐式（Implicit），**自动进行**，不需要程序员编写任何代码。 |

### 转换路径

拓宽转换是单向的。数据只能沿着下图所示的方向自动转换：

$$
\text{byte} \xrightarrow{} \text{short} \xrightarrow{} \text{int} \xrightarrow{} \text{long} \xrightarrow{} \text{float} \xrightarrow{} \text{double}
$$

$$\text{char} \xrightarrow{} \text{int} \xrightarrow{} \text{long} \xrightarrow{} \text{float} \xrightarrow{} \text{double}$$

### 拓宽转换/隐式转换的例外情况

虽然拓宽转换通常是安全的，但两种整型转化成浮点型的场景下可能涉及**精度丢失（Precision Loss）**：

1.  **`int` / `long` $\rightarrow$ `float`：**
    - `float` 只有 23 位有效数字，而 `int` 是 32 位，`long` 是 64 位。当 `long` 转换为 `float` 时，虽然 **数值大小** 能容纳，但 **尾数（精度）** 可能会被截断。
2.  **`long` $\rightarrow$ `double`：**
    - `double` 尾数有 52 位，通常能够精确表示，但对于极大的 `long` 整数，同样可能发生精度丢失。

---

## 2. 窄化转换/显式转换（Narrowing Conversion）

概念：**将存储容量较大的数据类型转换为存储容量较小的数据类型** 。

| 特性       | 描述                                                                                   |
| :--------- | :------------------------------------------------------------------------------------- |
| **安全性** | **危险**，可能导致**数据溢出**（数值失真）或 **精度丢失** ，本质都是**数据截断**造成的 |
| **方式**   | **显式（Explicit）**，必须使用 **强制类型转换（Type Cast）** 运算符 `(type)`。         |

### 语法和风险

```java
// 语法：(目标类型) 表达式
int largeNum = 257;

// 强制窄化转换，可能导致溢出
byte smallNum = (byte)largeNum;
// 结果：largeNum 超过了 byte 的范围 (-128 到 127)，
// smallNum 的值将变为 1 (257 = 256 + 1, 溢出 256 后剩下 1)

double pi = 3.14159;
int intPi = (int)pi;
// 结果：intPi 的值为 3 (小数部分被直接截断，不是四舍五入)
```

### 窄化转换的路径

**除布尔类型外，所有类型之间都可以通过强制转换互相转换**，但都伴随风险。

---

## 3. 特殊转换规则

### A. 表达式中的自动提升

**只要涉及算数运算，算数运算符首先会把两边操作数统一为其中精度最高的数据类型**。不过需要注意的是，当 ** `byte`, `short`, `char` 类型参与算术运算**（`+`, `-`, `*`, `/`）时，它们会**自动提升为`int`** 类型再进行计算，而不是以他们中的最高精度来看。因为在二元算数运算中，操作数最低精度保证为`int`

```java
byte b1 = 10;
byte b2 = 20;

// 编译错误：b1 + b2 的结果是 int 类型，b1 和 b2 是变量，不能直接赋给 byte
// byte b3 = b1 + b2;

// 正确写法：需要强制转换回 byte
byte b3 = (byte)(b1 + b2);
```

### B. `char` 与 `int` 的转换

- `char` 转 `int`：自动拓宽，`char` 会将其 **Unicode 码点值**（0 到 65535 之间的整数）赋给 `int` 变量。
- `int` 转 `char`
  - **如果是整型变量赋值字符变量：** 需要强制转换（因为四个字节的空间是明确的，虽然实际使用不到 4 个，但是编译器不知道这个整型变量的值发生改变后会不会超过`char`变量） ，JVM 只取 `int` 值中最低的 16 位作为 `char` 的码点。
  - **如果是字面量整数**，当字面量整数没有超过字符变量的范围时（因为这个数是固定的，使用空间大小明确不会改变），不需要强制转换
  - 以上两行规则适用于`int` 转 `short`和`int` 转 `byte`

### C. 布尔类型

- **`boolean` 类型不能与任何其他基本数据类型（数值类型）进行互相转换。**

## 总结

1\. 有多种数据类型进行混合运算的时候，系统首先会自动把数据类型转换成操作数中 **精度最高(容量最大)** 的那种数据类型，然后再进行计算;  
2\. 当把精度高（容量大）的数据转化成精度低的数据时，会报错，所以必须进行**强制类型转换**，或者从一开始就**增加字面量后缀**来定义数据类型;  
3\. **`byte/short`和`char`彼此之间不会发生自动转换** （所以直接赋值会报错，这是 **规则** ）;  
4\. `byte`, `short` 和 `char` 它们三者可以计算，在计算时会首先升为 `int` 类型
5\. `boolean` 不参与类型转换
