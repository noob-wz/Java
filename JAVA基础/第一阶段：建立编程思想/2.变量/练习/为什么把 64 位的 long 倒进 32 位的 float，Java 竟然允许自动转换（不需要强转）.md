请看这行代码：

```java
long num = 100000000L;  // long 占 64 位 (8字节)
float f = num;          // float 占 32 位 (4字节)

```

**提问：**

1. `long` 是 64 位的“大杯子”。
2. `float` 是 32 位的“小杯子”。
3. **为什么把 64 位的 `long` 倒进 32 位的 `float`，Java 竟然允许自动转换（不需要强转）？** 这不是大杯倒小杯吗？

#### 架构师的揭秘：由于“存储机制”不同

**不能光看字节数（占地面积），要看它能表示的范围（射程）。**

- **long (整数)：** 它是实打实地存数字。哪怕它有 64 位，它最大也就是存到 $9 \times 10^{18}$ 左右。
- **float (浮点数)：** 它是用**科学计数法**存的（一部分存基数，一部分存指数）。
- 就好比，`float` 存的是 $1.5 \times 10^{38}$ 。

**结论：**
虽然 `float` 只有 32 位（占地小），但因为它是指数级增长，它的 **“射程”（数值范围）** 比 64 位的 `long` 大得多！

**代价是什么？**
天下没有免费的午餐。`long` 转 `float` 虽然不会溢出（射程够），但会丢失 **精度** 。

- `long`：我是精准的 123456789123456789。
- `float`：我看不到那么细，我就记个大概吧，变成 。最后几位数字可能就不准了。
