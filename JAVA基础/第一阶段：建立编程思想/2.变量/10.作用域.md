## 第1部分：建立认知 (What & Why)

### 📦 1.1 核心概念 *💡 核心必学*

**目标**：记住 Java 的四层“同心圆”结构。

Java 的作用域遵循 **“大盒套小盒”** 的规则。内层可以看到外层，但外层看不到内层。

**四层作用域图解**：

```text
+-------------------------------------------------------+
| 1. 类级作用域 (Class/Static Scope)                    |
|    生命周期：程序运行期间一直存在                     |
|                                                       |
|    +---------------------------------------------+    |
|    | 2. 对象/实例作用域 (Instance Scope)         |    |
|    |    生命周期：对象创建 -> 对象被垃圾回收     |    |
|    |                                             |    |
|    |    +-----------------------------------+    |    |
|    |    | 3. 方法作用域 (Method Scope)      |    |    |
|    |    |    生命周期：方法调用 -> 方法结束 |    |    |
|    |    |                                   |    |    |
|    |    |    +-------------------------+    |    |    |
|    |    |    | 4. 块级作用域 (Block)   |    |    |    |
|    |    |    |    范围：if/for 的 {} 内|    |    |    |
|    |    |    +-------------------------+    |    |    |
|    |    +-----------------------------------+    |    |
|    +---------------------------------------------+    |
+-------------------------------------------------------+

```

**代码演示**：

```java
public class ScopeDemo {
    // 1. 类级变量 (静态变量)
    // 只要类在，它就在。全公司只有这一份。
    static int classVar = 100;

    // 2. 实例变量 (成员变量/字段)
    // 每个对象各有一份。
    String instanceVar = "Hello";

    public void testMethod() {
        // 3. 方法级变量 (局部变量)
        // 只有调用这个方法时才创建，方法运行完立即销毁
        int methodVar = 20;

        if (methodVar > 10) {
            // 4. 块级变量
            // 只有在这个 if 的花括号里有效
            // 出了这个 } 就不认识 blockVar 了
            int blockVar = 5; 
            System.out.println(blockVar);
        }
        
        // System.out.println(blockVar); // ❌ 报错！找不到 symbol
    }
}

```

---

### 💡 1.2 为什么需要作用域？

**如果不区分作用域（所有变量都是全局的）：**

1. **命名灾难**：你必须给每个变量起不同的名字（`i1`, `i2`, `temp_for_loop_1`...）。
2. **内存爆炸**：变量永远无法释放，内存会被迅速占满。
3. **安全隐患**：任何地方的代码都能随意修改关键数据，Bug 难以追踪。

**设计收益**：

* **隔离性**：不同方法里的变量互不干扰（即使都叫 `i`）。
* **及时回收**：方法执行完，局部变量立即从**栈 (Stack)** 中弹出销毁，腾出内存。

---

## 第2部分：工程实践 (How to Do Right)

### ✅ 2.1 最小权限原则 *🔥 实战必备*

**规范**：**变量的作用域越小越好。**

如果一个变量只在 `if` 块里用到，就不要把它定义在方法开头；如果只在方法里用到，就不要定义成成员变量。

**🔴 RED（错误示范）：变量“大材小用”**

```java
public class BadScope {
    // ❌ 坏味道：temp 只是个临时计算变量，却占用了对象的内存空间
    private int temp; 

    public void calculate() {
        temp = 10 + 20;
        System.out.println(temp);
    }
}

```

**🟢 GREEN（推荐风格）：随用随定义**

```java
public class GoodScope {
    public void calculate() {
        // ✅ 只有在真正需要的时候才声明
        int temp = 10 + 20; 
        System.out.println(temp);
    } // calculate 结束，temp 立即销毁
}

```

---

### 🔍 2.2 变量遮蔽 (Shadowing) *💡 核心必学*

**场景**：当**局部变量**和**成员变量**重名时，Java 遵循“就近原则”（Nearness Principle），局部变量会“遮住”成员变量。

**如何破局**：使用 `this` 关键字。

```java
public class User {
    String name = "Member Name"; // 成员变量

    public void setName(String name) { // 局部变量 (参数)
        // 此时，直接写 name 指的是参数（局部变量）
        
        System.out.println(name);      // 输出参数的值
        System.out.println(this.name); // 输出成员变量的值
        
        // 常见用法：将参数赋值给成员变量
        this.name = name; 
    }
}

```

**ASCII 助记**：

```text
[ name (成员) ]  <-- 被挡住了 (Shadowed)
      |
    (墙)
      |
[ name (局部) ]  <-- 也就是这里，优先看到最近的
      |
   代码位置

```

---

## 第3部分：避坑进阶 (What to Avoid)

### ⚠️ 3.1 静态与非静态的“时空隔阂”

这是初学者最容易犯的错误之一。

**规则**：

* **静态方法 (static)**：属于类，类加载时就存在。
* **实例变量 (非 static)**：属于对象，`new` 了之后才存在。

**陷阱**：你想在 `main` 方法（静态）里直接访问一个普通的成员变量。

```java
public class ScopeTrap {
    String message = "Hello"; // 非静态变量 (跟着对象走)

    public static void main(String[] args) {
        // ❌ 编译报错：
        // Non-static field 'message' cannot be referenced from a static context
        System.out.println(message); 
    }
}

```

**原理图解**：

```text
时间轴 --------------------------------->
[类加载] main方法存在了
   |
   |      (对象还没 new 出来，message 根本不存在！)
   |                 |
   v                 v
调用 main()  -----> 试图找 message (空) --> 💥 报错

```

**✅ 修复方案**：

1. 要么把 `message` 也变成 `static`。
2. 要么先 `new` 一个对象，再通过对象访问。

```java
// 修复方案 2
ScopeTrap obj = new ScopeTrap();
System.out.println(obj.message); // ✅ 通过对象找，找到了

```

---

### 🎓 实战挑战

**场景**：请阅读以下代码，判断控制台会输出什么？（考查变量遮蔽和作用域生命周期）

```java
public class ScopeChallenge {
    static int x = 10; // 静态变量
    int y = 20;        // 实例变量

    public void test(int x) {
        // 这里的 x 是参数
        System.out.println(x);       // A: ?
        System.out.println(this.y);  // B: ?
        System.out.println(ScopeChallenge.x); // C: ?
    }

    public static void main(String[] args) {
        ScopeChallenge obj = new ScopeChallenge();
        obj.test(5);
    }
}

```

> **A: 局部变量，输出 5**
> **B: 实例作用域，输出20**
> **C: 类作用域，输出10**