所有现代编程语言（包括 C、C++、Java、Python 等）和硬件都采用 `IEEE 754 标准` 来确保浮点运算的一致性，但**这种表示方法是导致精度问题的根本原因。**

**由于精度缺失，会进一步导致其他问题**

1.  **十进制小数无法精确表示：** 许多在十进制中有限的小数（如 0.1, 0.2, 0.7 等），在转换成二进制时会变成无限循环小数。由于存储空间有限，只能截断存储，从而导致精度损失。
2.  **累积误差：** 即使是微小的初始误差，在经过多次浮点运算后也可能**累积放大**，导致最终结果与预期相差较大。
3.  **比较问题：** 由于精度损失，直接使用 `==` 比较两个浮点数是否相等是很危险的，因为**表面上相等的两个数在二进制存储上可能存在微小差异**。

```java
// 问题1: 十进制小数无法精确表示为二进制小数
public class FloatingPointProblem1 {
    public static void main(String[] args) {
        float f1 = 0.1f;
        float f2 = 0.2f;
        float sum = f1 + f2;

        System.out.printf("0.1 + 0.2 = %.10f%n", sum);
        // 注意：同C语言一样，在 Java 中，浮点数的直接比较同样是危险的
        System.out.printf("0.1 + 0.2 == 0.3? %s%n", sum == 0.3f ? "true" : "false");

        // 查看实际存储的值
        System.out.printf("实际的0.1: %.20f%n", 0.1f);
        System.out.printf("实际的0.2: %.20f%n", 0.2f);
        System.out.printf("实际的0.3: %.20f%n", 0.3f);
    }
}
```

```java
// 问题2: 大数吃小数
public class FloatingPointProblem2 {
    public static void main(String[] args) {
        float large = 1.0e7f;      // 1000万
        float small = 1.0f;        // 1

        // 理论上：large + small = 10,000,001
        float result1 = large + small;
        float result2 = small + large;

        System.out.printf("大数 + 小数: %.1f%n", result1); // 10000000.0
        System.out.printf("小数 + 大数: %.1f%n", result2); // 10000000.0
        // float的有效数字大约是7位，10,000,001超出了精度范围，被四舍五入为10,000,000。
        System.out.printf("两者相等吗? %s%n", result1 == result2 ? "是" : "否");

        // 当小数足够小时，会被完全忽略
        float tiny = 0.001f;
        float sum = large + tiny;
        System.out.printf("%.0f + %.3f = %.0f (小数被忽略了!)%n", large, tiny, sum);

        /*
        原理（在代码中作为注释）：
        1. 当两个浮点数进行加法或减法时，计算机必须首先对它们的指数进行对齐，然后才能对尾数进行加减。
        2. 对齐规则： 小数的指数需要向大数的指数看齐，这意味着小数的尾数必须向右移动。
        3. 超出了尾数存储空间（23位）时，最低位的有效数字就会被舍弃或截断，这就是“吃掉”的过程。
        */
    }
}
```

```java
// 问题 3: 累计误差
public class FloatingPointProblem3 {
    public static void main(String[] args) {
        // 方法 1：多次累加
        float sum1 = 0.0f;
        for (int i = 0; i < 10000; i++) {
            sum1 += 0.1f;
        }

        // 方法2：直接乘法
        float sum2 = 0.1f * 10000.0f;

        System.out.printf("累加10000次0.1: %.2f%n", sum1);
        System.out.printf("0.1 × 10000:     %.2f%n", sum2);
        System.out.printf("理论值:          %.2f%n", 1000.0f);
        System.out.printf("sum1 和 sum2 相等吗? %s%n", sum1 == sum2 ? "是" : "否");
        System.out.printf("误差:            %.5f%n", sum1 - 1000.0f); // 误差通常是负值
    }

}
```

```java
// 问题4: 比较操作的不可靠性
import static java.lang.Math.abs;

public class FloatingPointProblem4 {
    public static void main(String[] args) {
        float a = 1.0f;
        float b = 0.0f;

        // 危险：浮点数不能直接比较相等
        for (int i = 0; i < 10; i++) {
            b += 0.1f; // 累加10次0.1，理论上等于1.0
        }

        System.out.printf("a = %.10f%n", a);
        System.out.printf("b = %.10f%n", b);
        System.out.printf("a == b? %s%n", a == b ? "true" : "false");
        System.out.printf("a - b = %.10f%n", a - b);

        // 正确的比较方法：使用误差范围 (epsilon)
        float epsilon = 1e-6f; // 设置一个极小的误差范围
        if (abs(a - b) < epsilon) {
            System.out.printf("在误差范围内(%.0e)，a 和 b 相等%n", epsilon);
        } else {
            System.out.println("a 和 b 不相等");
        }
    }
}
```

---

要想了解浮点数为什么存在精度缺失，就先要了解浮点数在计算机中的存储形式。

### 第一步，先了解浮点数在计算机中的存储形式

浮点数类型 `float`（单精度，32 位）和 `double`（双精度，64 位）都基于 IEEE 754 标准，浮点数通常采用 IEEE 754 标准存储，分为三个部分：

- **符号位**（1 位）：0 表示正数，1 表示负数
- **指数位**（`float` **8 位** 或 `double`**11 位** ）：表示 2 的幂次，存储指数的移码，决定**数值的大小**
- **尾数位**（`float`**23 位** 或 `double`**52 位**）：表示**有效数字**，决定数值的**精读**
  - 标准规定，尾数通常是 $1.M$ 的形式，其中整数部分的 1 会隐藏，只存储**尾数的小数部分**

![浮点数存储形式](../../Images/浮点数存储形式.png)

$$
\text{数} = (-1)^{\text{符号位}(S)} \times \text{尾数}(M) \times 2^{\text{指数}(E)}
$$

---

### 第二步，分析浮点数精度缺失的两个原因

#### 1. 十进制小数无法用有限的二进制位精确表示，所以在某个位置会“舍入或截断”

这是最常见、最核心的精度问题：

- **问题所在：** 我们习惯使用的十进制系统是基于 10 的幂（$10^0, 10^{-1}, 10^{-2}$...），而计算机的二进制系统是基于 2 的幂（$2^0, 2^{-1}, 2^{-2}$...）。
- 举例说明 (0.1)：
  - **十进制的 $1/10$ 无法用有限个 $1/2^n$ 之和来精确表示**。
  - 当计算机尝试将 $0.1$ 转换为二进制小数时，会得到一个**无限循环**的二进制表示：$0.0001100110011001100110011...$
  - 由于 `float` 只有 23 位的尾数空间（加上隐藏的 1 共 24 位有效数字），它**必须在某个位置截断或舍入**这个无限循环，这就造成了**存储误差**。

#### 2. 尾数位数有限 (有效数字限制)

- **问题所在：** 尾数的位数决定了浮点数可以表示的**有效数字的个数**。
  - `float` (单精度) 大约有 **6 到 7 位有效十进制数字**。
  - `double` (双精度) 大约有 **15 到 17 位有效十进制数字**。
- **举例说明：** 如果一个非常大的数包含超过 7 位的有效数字，使用 `float` 类型存储时，**最低几位**将会因为尾数空间不足而被**舍弃**，造成精度损失。

### ✅ 如何避免或处理精度问题？

- **使用 `double` 代替 `float`：** 在不严格限制内存和性能的情况下，尽量使用 `double`，因为它有更长的尾数和指数，精度和范围都更高。
- **避免直接比较 (`==`)：** 永远不要直接使用 `==` 来比较浮点数是否相等。应该检查它们的**差的绝对值**是否小于一个很小的阈值（被称为 $\epsilon$ (epsilon)，通常取 $10^{-6}$ 或 $10^{-9}$）。

---

**总结来说，C 语言浮点数的精度问题，最根本的原因有两个**：
1\. **十进制小数无法用有限的二进制位精确表示**
2\. 有限的存储空间（特别是尾数），对应的**有效数字存在限制**
