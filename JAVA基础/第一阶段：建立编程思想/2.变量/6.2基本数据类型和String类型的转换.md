这是实际开发中**最繁忙的桥梁**：前端传来的数据永远是 `String`（比如 "18"），而后台计算需要的是 `int`（18）；算完之后，又要转回 `String` 显示给用户。

---

### 💡 核心全景图

这两种转换，方向不同，使用的工具也不同。请记住这个 **“包装类 (Wrapper Class)”** 的概念，它是转换的中介。

1. **基本类型 → String**：将数字“格式化”为文本。
   * *场景*：显示在屏幕上、写入日志文件。

2. **String → 基本类型**：将文本“解析”为数字。
   * *场景*：读取表单输入、解析 JSON 数据。



---

### 🔄 方向一：基本类型转 String (数字变文字)

有三种常见写法，大厂面试官通常会问你哪种性能最好。

| 写法 | 代码示例 | 原理 | 推荐指数 |
| --- | --- | --- | --- |
| **1. String.valueOf()** | `String s = String.valueOf(10);` | **调用底层静态方法，清晰直观** | ⭐⭐⭐⭐⭐ (官方推荐) |
| **2. 拼接空字符串** | `String s = 10 + "";` | 实际上创建了 StringBuilder，有轻微开销 | ⭐⭐⭐ (偷懒专用) |
| **3. 包装类 toString** | `String s = Integer.toString(10);` | 效果等同于第一种，但写法略长 | ⭐⭐⭐⭐ |

**🔬 导师建议**：
养成习惯使用 `String.valueOf(val)`。

* 它能处理各种类型 (`int`, `double`, `boolean`...)。
* 它比 `+ """` 少创建临时的 StringBuilder 对象，**不仅更“专业”，而且在海量数据下性能更好**。

---

### 🔄 方向二：String 转基本类型 (文字变数字)

这里需要请出 Java 为每个基本类型配备的**包装类 (Wrapper Class)**。它们提供了静态的 `parse` 方法。

| 目标类型 | 包装类 | 核心方法 | 示例 |
| --- | --- | --- | --- |
| **int** | **Integer** | `Integer.parseInt(str)` | `int i = Integer.parseInt("123");` |
| **double** | **Double** | `Double.parseDouble(str)` | `double d = Double.parseDouble("3.14");` |
| **boolean** | **Boolean** | `Boolean.parseBoolean(str)` | `boolean b = Boolean.parseBoolean("true");` |
| **long** | **Long** | `Long.parseLong(str)` | `long l = Long.parseLong("99999");` |

**⚙️ 底层原理 (parseInt 是怎么做到的？)**
它其实是一个简单的数学循环。

1. 遍历字符串的每一个字符 `char`。
2. 利用 ASCII 码计算：`'9' - '0' = 9`。
3. 公式推导：`result = result * 10 + digit`。

---

### 💻 生产级代码示例

在String到基础类型实际转换中，**最可怕的是字符串格式不对**（比如把 "abc" 转成整数）。所以必须要有异常处理。

```java
public class TypeConversionDemo {
    public static void main(String[] args) {
        // --- 场景 1: 前端传来了用户输入的年龄 (String) ---
        String inputAge = "25";
        String inputBad = "25岁"; // 带有非数字字符

        // ❌ 危险写法：不做校验直接转
        // int age = Integer.parseInt(inputBad); // 会崩溃！

        // ✅ 推荐写法：捕获异常
        try {
            int age = Integer.parseInt(inputAge);
            System.out.println("明年年龄: " + (age + 1)); // 只有转成 int 才能做加法
            
            // 尝试解析错误格式
            int badAge = Integer.parseInt(inputBad); 
        } catch (NumberFormatException e) {
            // 🚨 捕获特定的转换异常
            System.err.println("转换失败！请输入纯数字。错误详情: " + e.getMessage());
        }

        // --- 场景 2: 计算结果存入日志 (int -> String) ---
        double salary = 15000.50;
        
        // 推荐写法
        String logData = String.valueOf(salary);
        System.out.println("日志记录: " + logData);
    }
}

```

---

### ⚠️ 常见踩坑指南

#### 1. NumberFormatException (数字格式异常)

这是 Java 开发中最常见的异常之一。

* **触发**：`Integer.parseInt("12.5")` (整数不能带点) 或 `Integer.parseInt("abc")`。
* **注意**：`Integer.parseInt(" 123 ")` 也会报错！因为它包含空格。
* **解决**：在解析前，先用 `.trim()` 去除首尾空格。
```java
int i = Integer.parseInt(" 123 ".trim()); // ✅ 安全

```



#### 2. boolean 的宽容性

`Boolean.parseBoolean(String)` 是个特例，它**不会抛异常**。

* 只有输入 `"true"` 或 `"TRUE"` (忽略大小写) 才是 `true`。
* 输入任何其他东西（"abc", "123", "null"），它统统返回 `false`。

#### 3. 各种 valueOf 的区别 (面试进阶)

* `Integer.parseInt("123")` 返回 `int` (基本类型)。
* `Integer.valueOf("123")` 返回 `Integer` (对象)。
  * 虽然有自动拆箱 (装箱/拆箱：基本类型 ↔ 包装类型)，但在追求极致性能的场景下，**想要基本类型就用 parseXXX**，想要对象就用 valueOf。
  
---

### 💼 大厂编码规范

1. **防御性编程**：
   在将 String 转为数字之前，如果不能 100% 保证来源可靠（如用户输入），必须使用 `try-catch` 包裹，或者使用正则预先校验 `str.matches("\\d+")`。
2. **避免魔术转换**：
   不要写 `int x = Integer.valueOf(str)` 然后又把它赋值给 int。虽然能跑，但多了“自动拆箱”的步骤。直接用 `parseInt` 更纯粹。

---

### 🧠 一句话总结

**基本类型和 String 的转换不是“类型转换”，而是“值的解析与格式化”，必须通过标准 API 显式完成。**
