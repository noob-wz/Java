// 目的：（1）了解浮点型常量赋值时需要严格的安全的精度转化问题；
//      （2）了解浮点数的精度缺失

/* TODO(2025-11-15 22:21:30) 
 * 
 * 总结：
 * （1）小精度可以自动转换成大精度，大精度不能自动转换成小精度（C语言中可以）。
 *      1. 可以通过“强制类型转换”把高精度转化成低精度 或者 使用字面量后缀
 *      2. 整型数据（编译期确定的值）可以直接赋值给char类型，因为char本质就是整数类型
 * （2）浮点数是存在精度缺失的，主要表现在
 *      1. 十进制小数无法精确表示
 *      2. 累积误差：当对多个浮点数进行运算，误差会放大
 *      3. 比较问题：当运算结果是小数的，对其进行运算，要小心
 *      4. 大数吃小数
 */


public class FloatDetail {
    public static void main(String[] args){

        // 浮点型常量默认是 double 类型，如果要声明 float类型变量时初始化，必须加‘f'或‘F'
        float num = 1.1F;
        // float num = 1.1; //会报错 ，精度不匹配
        float num4 = (float)1.1; // 强制类型转换，可以把高精度转化为低精度
        float num5 = 1.1f; // 使用字面量后缀，定义数据原始类型
        double num1 = 1.1f; // 低进度赋值高精度是允许的（因为低精度最多只需要4个字节存储，存放到8个字节的double类型空间绰绰有余），会自动转化成高精度
        double num2 = 2.7; 
        double num3 = 8.1 / 3; // 会造成累计误差现象，数学上没有错误，但是计算机存储存在缺陷，输出值非2.7

        System.out.println(num); // 输出 1.1，
        System.out.println(num1); // 输出1.100000023841858
        System.out.println(num2); // 输出2.7 ，虽然看上去没有误差，实际上是因为double类型精度够高，误差足够小的情况下，Java标准打印机制会抑制微小误差的显示
        System.out.println(num3); // 输出2.6999999999999997 ，和num2同样都是双精度，但因为乘除法是两个有误差的进行乘除，会把误差放大，是典型的误差累积现象
        System.out.println(num4); // 输出 1.1，
        System.out.println(num5); // 输出 1.1，


        // 常见的浮点型误区 —— 运算比较
        // 上面可以看到计算机存储浮点数是存在精度缺失的，所以不能直接对运算结果是浮点值的数进行相等比较
        // 而是要用两个数的差值的绝对值和一个足够小的数(1e-6 或 1e-9）进行比较，小于这个数可以理解为相等
        if (Math.abs(num2 - num3) < 1e-6) {
            System.out.println("num2和num3相等");
        }

        if (num2 == 2.7 ){ // 这种是允许的
            // 因为num2和2.7在内存中存储的形式一模一样，即使存在误差
            System.out.println("完全相等"); 
        }
    }
}

/* 运行结果：
--------------------------------
1.1
1.100000023841858
2.7
2.6999999999999997
1.1
1.1
num2和num3相等
--------------------------------
*/
