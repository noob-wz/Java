### 💡 核心概念

**【定义】**
`String` 是 Java 中用于存储文本数据的类。
本质上，它是一个**不可变 (Immutable)** 的字符序列。

**【与基本类型的区别】**      
* **基本类型 (int, double...)**：变量里存的是**具体的值**。         
* **引用类型 (String)**：变量里存的是**地址引用**（就像拿着一把钥匙），指向堆内存中真正的对象。

**【生活化比喻：写死的告示牌】**
`String` 就像一块刻了字的石碑。

* 一旦刻好（创建好），字就不能改了。
* 如果你想改上面的字，只能把旧石碑扔了，重新刻一块新的。这就是**不可变性**。

---

### 🔬 内存解剖与底层

#### 1. 内部结构 (Java 9 的重大变革)

很多教材还在讲 `char[]`，但在 JDK 9 之后，Java 做了一次底层大手术：

* **Java 8 及之前**：底层是 `char[]` 数组。每个字符占 2 字节（UTF-16）。
* **Java 9 及之后**：底层是 `byte[]` 数组 + `coder` 编码标记。
* **优化原理**：如果字符串只包含英文字母（ASCII），改用 `byte` 存，每个字符只占 1 字节。**内存最高节省 50%**。



#### 2. 内存布局图谱

这是 String 最难理解的部分：**栈 (Stack)**、**堆 (Heap)** 和 **常量池 (String Pool)** 的关系。

```text
代码:
String s1 = "Hello";
String s2 = new String("Hello");

       栈 (Stack)                         堆 (Heap)
  ┌──────────────────┐           ┌────────────────────────────┐
  │ 变量名: s1       │           │ 🟢 字符串常量池 (String Pool) │
  │ 存地址: 0x999    ├──────────►│    地址: 0x999             │
  └──────────────────┘           │    内容: "Hello"           │
                                 └──────────────▲─────────────┘
  ┌──────────────────┐                          │ (逻辑上的关联)
  │ 变量名: s2       │           ┌──────────────┴─────────────┐
  │ 存地址: 0x555    ├──────────►│ 🟡 普通堆对象 (Heap Object)   │
  └──────────────────┘           │    地址: 0x555             │
                                 │    内容: 包装了 "Hello"      │
                                 └────────────────────────────┘
```

> 在现代 Java（JDK 7 及以后）中，**字符串常量池是在堆（Heap）中**，而不再属于方法区（Method Area/PermGen）。
> 
> 顺便提一句，**静态变量 (static variables) 在 JDK 7 时也跟着字符串常量池一起搬到了堆中。**

---

### ⚙️ 关键机制：字符串常量池 (String Pool)

Java 为了省内存，设计了一个特殊的缓存区。

1. **字面量创建** (`String s = "abc";`)：
   * JVM 会先去池子里找有没有 "abc"。
   * **有**：直接把地址给你（不创建新对象）。
   * **没有**：在池子里创建一个 "abc"，然后把地址给你。
   * **特点**：高效，推荐使用。


2. **new 创建** (`String s = new String("abc");`)：
   * **强制**在堆的普通区域创建一个新对象。
   * 哪怕池子里已经有 "abc" 了，它也会新建一个“马甲”对象。
   * **特点**：浪费内存，除非特殊需求，**大厂严禁这样写字面量**。



---

### 💻 常用操作实战

```java
public class StringDemo {
    public static void main(String[] args) {
        String str = "Java,Core";

        // 1. 获取长度
        System.out.println(str.length()); // 输出 9

        // 2. 查找位置
        System.out.println(str.indexOf("Core")); // 输出 5

        // 3. 截取 (左闭右开区间: 含头不含尾)
        System.out.println(str.substring(0, 4)); // 输出 "Java"

        // 4. 比较 (重点！)
        String s1 = "Java";
        String s2 = "Java";
        String s3 = new String("Java");

        // == 比较的是【地址】
        System.out.println(s1 == s2); // true (都指向常量池同一个)
        System.out.println(s1 == s3); // false (s3 是堆里的新对象)

        // equals 比较的是【内容】
        System.out.println(s1.equals(s3)); // true (字面也是 Java)
    }
}

```

---

### ⚙️ String 拼接的真相（高频坑）
见：[String字符串拼接](6.1String字符串拼接.md)

---

### ⚠️ 性能陷阱：不可变性的代价

因为 String 不可变，每次拼接都会产生**垃圾对象**。

#### ❌ 错误做法

```java
String s = "";
// 在循环中直接拼接 String
// 每次循环都会创建一个 StringBuilder，append 完转成 String，再丢弃旧的...
// 产生几千个垃圾对象，GC (垃圾回收) 压力山大
for (int i = 0; i < 1000; i++) {
    s = s + i; 
}

```

#### ✅ 推荐做法

使用 `StringBuilder` (线程不安全，快) 或 `StringBuffer` (线程安全，慢)。它们是“可变的字符数组”。

```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i); // 直接在原有数组上修改，不产生垃圾
}
String result = sb.toString();

```

---

### 💼 大厂编码规范 (Alibaba)

1. **比较的艺术**：
   * **规范**：`"常量".equals(变量)`
   * **原因**：防止空指针异常 (NullPointerException)。
   * **反例**：`input.equals("success")` -> 如果 input 是 null，程序直接崩溃。
   * **正例**：`"success".equals(input)` -> 如果 input 是 null，返回 false，程序安全。
2. **拼接的限制**：
   * **规范**：循环体内，字符串的连接方式，使用 `StringBuilder` 的 `append` 方法进行扩展。
   * **原因**：如上所述，避免内存浪费。



---
