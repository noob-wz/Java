### 💡 核心概念

**【定义】**
Java 语言内置的、最基础的数据单元。它们直接存储**数据值**本身，而不是对象的引用（地址）。

**【分类逻辑】**
为了方便记忆，我们将这 8 种类型分为 **4 大类**：

1. **整数型**：存没有小数点的数字 (byte, short, int, long)，**分 8 / 16 / 32 / 64 位**
2. **浮点型**：存有小数点的数字 (float, double)，  **遵循 `IEEE 754`标准** 
3. **字符型**：存单个文字/符号 (char)，**直接支持 Unicode**
4. **布尔型**：存真/假逻辑 (boolean)，**语义优先，不暴露底层**

---

### 🔬 全景参数矩阵

请重点关注**默认类型**（Java 默认使用的类型）和**特殊后缀**。

#### 1. 整数类型 (Integer)

| 类型 | 占用内存 | 取值范围 (约) | 适用场景 | 备注 |
| --- | --- | --- | --- | --- |
| **byte** | 1 字节 | -128 ~ 127 | 文件流处理、底层二进制传输 | 极小，像火柴盒 |
| **short** | 2 字节 | -3万 ~ 3万 | 极少使用 (历史遗留) | 略 |
| **int** | **4 字节** | **-21亿 ~ 21亿** | **大部分整数场景的首选** | **默认整数类型** |
| **long** | 8 字节 | 很大 (19位数字) | 时间戳、身份证号、大额统计 | **需加后缀 `L`** |

#### 2. 浮点类型 (Floating Point)

| 类型 | 占用内存 | 精度 | 适用场景 | 备注         |
| --- | --- | --- | --- |------------|
| **float** | 4 字节 | 7 位有效数字 | 极少使用 (图形处理/游戏) | **需加后缀 `f`** |
| **double** | **8 字节** | **15 位有效数字** | **大部分小数场景的首选** | **默认浮点类型** |

#### 3. 字符类型 (Character) ——本质是无符号16位整数

| 类型 | 占用内存 | 内容示例 | 适用场景 | 备注 |
| --- | --- | --- | --- | --- |
| **char** | 2 字节 | 'A', '中', '9' | 存储单个字符 | 使用**单引号** |

#### 4. 布尔类型 (Boolean)

| 类型 | 占用内存 | 内容 | 适用场景 | 备注          |
| --- | --- | --- | --- |-------------|
| **boolean** | JVM相关* | true / false | 逻辑判断、流程控制 | **不能参与运算**，防止 C 语言那种“0 / 1 混用导致逻辑灾难” |

> **注**：`boolean` 在内存中的具体大小取决于 Java 虚拟机 (JVM) 的实现，通常在数组中占 1 字节，单独使用时可能占 4 字节 (int)。

---

### 📊 内存视角 (Stack Memory)

基本数据类型的特点是 **“快”且“小”**。它们直接分配在**栈内存 (Stack)** 中。

```java
int a = 10;
long b = 20L;
```

```text
Stack Frame（局部变量表）
┌───────────────┐
│ slot0: a = 10 │   ← int 占 1 slot
│ slot1: b 高位 │
│ slot2: b 低位 │   ← long 占 2 slot
└───────────────┘
```

> **说明：** 学习阶段可以理解为 **a 和 b 是两块不同的内存空间**。
> 
> **更严谨的说法需要修正为：a 和 b 是同一个栈帧中“局部变量表的不同 slot”**，即：
>  * 都在同一个栈桢
>  * 不是两个“独立内存区”， 但逻辑上完全独立

*对比预告：以后学的 `String` 或 `Array` 是引用类型，栈里存的是地址，值在堆里。*

---

### 💻 生产级代码示例

请注意代码中的后缀和注释说明。

```java
public class PrimitiveTypesDemo {
    public static void main(String[] args) {
        // --- 1. 整数型 ---
        // 推荐：普通整数直接用 int
        int salary = 15000;
        
        // 强制：超过 int 范围(21亿)必须用 long，且末尾加 'L'
        // 阿里巴巴规范：必须用大写 'L'，因为小写 'l' 容易被看成数字 '1'
        long worldPopulation = 7800000000L; 

        // --- 2. 浮点型 ---
        // 推荐：普通小数直接用 double
        double price = 99.9;
        
        // 强制：如果非要用 float，必须加 'f'，否则报错 (因为默认是 double)
        float height = 175.5f; 

        // --- 3. 字符型 ---
        // 只能存 1 个字，且必须用单引号 ''
        char level = 'A';
        char nameStart = '中'; 

        // --- 4. 布尔型 ---
        // 只有 true 或 false，不能用 0 或 1 代替 (这点和 C 语言不同)
        boolean isPassed = true;

        System.out.println("世界人口: " + worldPopulation);
        System.out.println("是否通过: " + isPassed);
    }
}

```

---

### ⚠️ 常见踩坑指南

#### 1. 整数溢出 (Overflow)

* **现象**：`int` 最大值 + 1 变成了最小值。
* **原理**：二进制进位导致符号位翻转（类似汽车里程表归零）。
* **代码**：
```java
int max = 2147483647; // int 最大值
System.out.println(max + 1); // 输出 -2147483648 (也就是 int 最小值)

```


* **避免**：预估数值可能过大时，直接使用 `long`。

#### 2. 浮点数精度丢失

* **现象**：`0.1 + 0.2` 不等于 `0.3`。
* **代码**：
```java
System.out.println(0.1 + 0.2); // 输出 0.30000000000000004

```


* **根因**：计算机用二进制存小数，无法精确表示 0.1 等十分位。
* **大厂规范**：**严禁**使用 `float` 和 `double` 进行金额计算。

#### 3.迷信 byte / short 省内存

```java
byte b = 1;
b = b + 1; // ❌ 编译错误
```

* **根因**：运算时自动提升为 int

* **大厂规范**：现代 JVM 下，除非 IO 协议，否则直接用 int



---

### 💼 大厂技术规范 (Alibaba & Google)

1. **金额处理**：
   * **规范**：涉及货币计算，必须使用 `BigDecimal` 类，或者将单位转为“分”使用 `long` 类型存储。
   * **理由**：避免上述的浮点数精度丢失导致账目对不上。


2. **Long 定义**：
   * **规范**：`long` 类型的字面量必须使用大写 `L`。
   * **反例**：`long id = 1l;` (看起来像 11)
   * **正例**：`long id = 1L;`


3. **魔法值**：
   * **规范**：代码中不要直接出现 `long timeout = 86400000L;` 这种不明觉厉的数字。
   * **正例**：定义常量 `static final long ONE_DAY_MS = 86400000L;`。


---

